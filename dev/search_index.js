var documenterSearchIndex = {"docs":
[{"location":"DislocationType/#Types-1","page":"Dislocation Types","title":"Types","text":"","category":"section"},{"location":"DislocationType/#","page":"Dislocation Types","title":"Dislocation Types","text":"DDD.jl makes extensive use of Julia's type system to provide a performant and user-error proof dislocation plasticity simulations.","category":"page"},{"location":"DislocationType/#Primitive-Types-1","page":"Dislocation Types","title":"Primitive Types","text":"","category":"section"},{"location":"DislocationType/#","page":"Dislocation Types","title":"Dislocation Types","text":"nodeType","category":"page"},{"location":"DislocationType/#DDD.nodeType","page":"Dislocation Types","title":"DDD.nodeType","text":"@enum nodeType begin\n    none = 0    # Undefined node, value at initialisation.\n    intMob = 1  # Internal mobile node.\n    intFix = 2  # Internal fixed node.\n    srfMob = 3  # Mobile surface node.\n    srfFix = 4  # Fixed surface node.\n    ext = 5     # External node.\n    tmp = 6     # Temporary flag, used during topological operations.\nend\n\nDifferent types of nodes behave differently. There are only a finite number of them so an enumerated type provides safety and efficiency. Each value represents a different type of node and therefore its behaviour.\n\nMeaning\n\nnone are uninitialised nodes.\nintMob are mobile nodes internal to the convex hull of the domain. They take part in tractions, displacements and dislocation interactions.\nintFix are fixed nodes internal to the convex hull of the domain. They participate in the same way as intMob nodes except for the fact that their velocities is fixed are zero.\nsrfMob are mobile nodes that live on the surface of the convex hull of the domain, they are used to track slip steps and therefore participate in the same things as internal nodes but their velocities are restricted to the convex hull surface.\nsrfFix are fixed surface nodes and have the same characteristics as mobile surface nodes except for having zero velocity.\next are external nodes that do not participate in dislocation interactions or forces but are used to calculate displacements and track slip steps.\ntmp are nodes that are temporarily flagged before they are assigned another type.\n\n\n\n\n\n","category":"type"},{"location":"DislocationType/#","page":"Dislocation Types","title":"Dislocation Types","text":"AbstractDlnSeg","category":"page"},{"location":"DislocationType/#DDD.AbstractDlnSeg","page":"Dislocation Types","title":"DDD.AbstractDlnSeg","text":"abstract type AbstractDlnSeg end\nstruct segNone <: AbstractDlnSeg end    # Undefined segment\nstruct segEdge <: AbstractDlnSeg end    # Edge segment\nstruct segEdgeN <: AbstractDlnSeg end   # Edge segment\nstruct segScrew <: AbstractDlnSeg end   # Screw segment\nstruct segMixed <: AbstractDlnSeg end   # Mixed segment\n\nThese types are used to automatically generate segments out of Burgers vectors bmb, slip planes bmn, and/or line direction bml.\n\nMeaning\n\nsegEdge have bmb  bmt ,\nsegEdgeN have bmb  bmt and bmb  bmn ,\nsegScrew have bmb  bmt ,\nsegMixed have none of the above.\n\n\n\n\n\n","category":"type"},{"location":"DislocationType/#","page":"Dislocation Types","title":"Dislocation Types","text":"AbstractDlnStr","category":"page"},{"location":"DislocationType/#DDD.AbstractDlnStr","page":"Dislocation Types","title":"DDD.AbstractDlnStr","text":"abstract type AbstractDlnStr end\nstruct loopPrism <: AbstractDlnStr end\nstruct loopShear <: AbstractDlnStr end\nconst loopPure = Union{loopPrism,loopShear}\nstruct loopMixed <: AbstractDlnStr end\nstruct loopJog <: AbstractDlnStr end\nstruct loopKink <: AbstractDlnStr end\nconst loopImpure = Union{loopMixed,loopJog,loopKink}\nconst loopDefined = Union{loopPrism,loopShear,loopMixed,loopJog,loopKink}\nstruct loopDln <: AbstractDlnStr end\n\nThese types are used to automatically generate dislocation loops for simulation initialisation.\n\nMeaning\n\nloopPrism are prismatic loops, their Burgers vectors are perpendicular to the their line direction. They are idealised loops that can be automatically generated as n-gons.\nloopShear are shear loops, their line direction goes through edge, screw and line segments as the loop goes round. They are idealised loops that can be automatically generated as n-gons.\nloopPure are idealised loops.\nloopMixed are loops with prismatic and shear character. They have to be hand-made or require a heuristic to automatically generate.\nloopDln is a generic loop used for adding methods to Base functions.\nloopKink and loopJog are structures formed by colliding dislocations. They are not currently used.\nloopImpure are non-idealised loops.\nloopDefined are defined loop types.\n\n\n\n\n\n","category":"type"},{"location":"DislocationType/#","page":"Dislocation Types","title":"Dislocation Types","text":"AbstractDistribution","category":"page"},{"location":"DislocationType/#DDD.AbstractDistribution","page":"Dislocation Types","title":"DDD.AbstractDistribution","text":"abstract type AbstractDistribution end\nstruct Zeros <: AbstractDistribution end\nstruct Rand <: AbstractDistribution end\nstruct Randn <: AbstractDistribution end\nstruct Regular <: AbstractDistribution end\n\nSpatial distributions for dislocation sources. These are used to automatically generate networks with a given distribution.\n\nMeaning\n\nZeros makes the network generation functions place the center of the generated dislocation loops at the origin. This can be used to generate a network and loops can be manually or pseudo-manually distributed in the domain.\nRand makes the network generation functions uniformly distribute the dislocations according to the range and buffer values in the dislocation loop structure.\nRand makes the network generation functions normally distribute the dislocations according to the range and buffer values in the dislocation loop structure.\nRand TBA, will regularly distribute dislocations according to the range, buffer and other args given to the dislocation network generator.\n\n\n\n\n\n","category":"type"},{"location":"DislocationType/#","page":"Dislocation Types","title":"Dislocation Types","text":"AbstractMobility","category":"page"},{"location":"DislocationType/#DDD.AbstractMobility","page":"Dislocation Types","title":"DDD.AbstractMobility","text":"abstract type AbstractMobility end\nstruct mobBCC <: AbstractMobility end\nstruct mobFCC <: AbstractMobility end\nstruct mobHCP <: AbstractMobility end\n\nTypes to dispatch different mobility functions.\n\nMeaning\n\nmobBCC is used to dispatch the default BCC mobility function.\nmobFCC is used to dispatch the default FCC mobility function.\nmobHCP is used to dispatch the default HCP mobility function.\n\n\n\n\n\n","category":"type"},{"location":"DislocationType/#Data-Storage-1","page":"Dislocation Types","title":"Data Storage","text":"","category":"section"},{"location":"DislocationType/#","page":"Dislocation Types","title":"Dislocation Types","text":"SlipSystem","category":"page"},{"location":"DislocationType/#DDD.SlipSystem","page":"Dislocation Types","title":"DDD.SlipSystem","text":"struct SlipSystem{T1, T2}\n    crystalStruct::T1   # Crystal structure\n    slipPlane::T2       # Slip plane\n    bVec::T2            # Burgers vector\nend\n\nStores slip systems. \n\n\n\n\n\n","category":"type"},{"location":"DislocationType/#","page":"Dislocation Types","title":"Dislocation Types","text":"DislocationParameters","category":"page"},{"location":"DislocationType/#DDD.DislocationParameters","page":"Dislocation Types","title":"DDD.DislocationParameters","text":"struct DislocationParameters{T1,T2,T3,T4}\n    coreRad::T1         # Dislocation core radius.\n    coreRadSq::T1       # Square of the dislocation core radius.\n    coreRadMag::T1      # Magnitude of the core radius (real units for post-processing).\n    minSegLen::T1       # Minimum segment length.\n    maxSegLen::T1       # Maximum segment length.\n    twoMinSegLen::T1    # Twice the minimum segment length.\n    minArea::T1         # Minimum area for remeshing.\n    maxArea::T1         # Maximum area for remeshing.\n    minAreaSq::T1       # Square of the minimum area.\n    maxAreaSq::T1       # Square of the maximum area.\n    edgeDrag::T1        # Edge drag coefficient.\n    screwDrag::T1       # Screw drag coefficient.\n    climbDrag::T1       # Climb drag coefficient.\n    lineDrag::T1        # Line drag coefficient.\n    maxConnect::T2      # Maximum connectivity of nodes.\n    mobility::T3        # Dislocation mobility.\n    remesh::T4          # Remesh flag.\n    collision::T4       # Collision flag.\n    separation::T4      # Separation flag.\n    virtualRemesh::T4   # Virtual remeshing flag.\n    parCPU::T4          # Parallelise on CPU flag.\n    parGPU::T4          # Parallelise on GPU flag.\n    slipStepCritLen::T1 # Critical length for slip step tracking.\n    slipStepCritArea::T1    # Critical area for slip step tracking.\nend\n\nStores the dislocation parameters.\n\n\n\n\n\n","category":"type"},{"location":"DislocationType/#","page":"Dislocation Types","title":"Dislocation Types","text":"DislocationLoop","category":"page"},{"location":"DislocationType/#DDD.DislocationLoop","page":"Dislocation Types","title":"DDD.DislocationLoop","text":"struct DislocationLoop{T1,T2,T3,T4,T5,T6,T7,T8,T9,T10}\n    loopType::T1    # Loop type.\n    numSides::T2    # Number of sides in the loop.\n    nodeSide::T2    # Nodes per side of the loop.\n    numLoops::T2    # Number of loops to generate when making the network.\n    segLen::T3      # Segment lengths.\n    slipSystem::T4  # Slip system.\n    links::T5       # Links.\n    slipPlane::T6   # Slip planes.\n    bVec::T6        # Burgers vectors.\n    coord::T6       # Coordinates.\n    label::T7       # Node labels.\n    buffer::T8      # Buffer for distributions.\n    range::T9       # Range for distributions.\n    dist::T10       # Distribution.\nend\n\nStores a dislocation loop and parameters used to generate a DislocationNetwork.\n\n\n\n\n\n","category":"type"},{"location":"DislocationType/#","page":"Dislocation Types","title":"Dislocation Types","text":"DislocationNetwork","category":"page"},{"location":"DislocationType/#DDD.DislocationNetwork","page":"Dislocation Types","title":"DDD.DislocationNetwork","text":"struct DislocationNetwork{T1,T2,T3,T4,T5,T6}\n    links::T1\n    slipPlane::T2\n    bVec::T2\n    coord::T2\n    label::T3\n    nodeVel::T2\n    nodeForce::T2\n    numNode::T4\n    numSeg::T4\n    maxConnect::T5\n    connectivity::T1\n    linksConnect::T1\n    segIdx::T1\n    segForce::T6\nend\n\nStores the dislocation network generated from DislocationLoop.\n\n\n\n\n\n","category":"type"},{"location":"MaterialConstructor/#Constructors-1","page":"Material Constructors","title":"Constructors","text":"","category":"section"},{"location":"MaterialConstructor/#","page":"Material Constructors","title":"Material Constructors","text":"MaterialParameters(\n    μ::T1,\n    μMag::T1,\n    ν::T1,\n    E::T1,\n    crystalStruct::T2,\n    σPN::T1 = 0,\n) where {T1,T2 <: AbstractCrystalStruct}","category":"page"},{"location":"MaterialConstructor/#DDD.MaterialParameters-Union{Tuple{T2}, Tuple{T1}, Tuple{T1,T1,T1,T1,T2}, Tuple{T1,T1,T1,T1,T2,T1}} where T2<:AbstractCrystalStruct where T1","page":"Material Constructors","title":"DDD.MaterialParameters","text":"MaterialParameters(\n    μ::T1,\n    μMag::T1,\n    ν::T1,\n    E::T1,\n    crystalStruct::T2,\n    σPN::T1 = 0,\n) where {T1,T2 <: AbstractCrystalStruct}\n\nConstructor for MaterialParameters automatically calculates derived quantities and sets the Peierls-Nabarro stress to a default of σPN = 0.\n\n\n\n\n\n","category":"method"},{"location":"MaterialConstructor/#","page":"Material Constructors","title":"Material Constructors","text":"MaterialParameters(;\n    μ::T1,\n    μMag::T1,\n    ν::T1,\n    E::T1,\n    crystalStruct::T2,\n    σPN::T1 = 0,\n) where {T1,T2 <: AbstractCrystalStruct}","category":"page"},{"location":"MaterialConstructor/#DDD.MaterialParameters-Union{Tuple{}, Tuple{T2}, Tuple{T1}} where T2<:AbstractCrystalStruct where T1","page":"Material Constructors","title":"DDD.MaterialParameters","text":"MaterialParameters(;\n    μ::T1,\n    μMag::T1,\n    ν::T1,\n    E::T1,\n    crystalStruct::T2,\n    σPN::T1 = 0,\n) where {T1,T2 <: AbstractCrystalStruct}\n\nKeyword constructor for MaterialParameters.\n\n\n\n\n\n","category":"method"},{"location":"FEMType/#Finite-Element-Types-1","page":"FEM Types","title":"Finite Element Types","text":"","category":"section"},{"location":"FEMType/#Primitive-1","page":"FEM Types","title":"Primitive","text":"","category":"section"},{"location":"FEMType/#","page":"FEM Types","title":"FEM Types","text":"AbstractMesh","category":"page"},{"location":"FEMType/#DDD.AbstractMesh","page":"FEM Types","title":"DDD.AbstractMesh","text":"abstract type AbstractMesh end\nabstract type AbstractRegularCuboidMesh <: AbstractMesh end\nstruct DispatchRegularCuboidMesh <: AbstractRegularCuboidMesh end\n\nFE mesh types for dispatch.\n\n\n\n\n\n","category":"type"},{"location":"FEMType/#","page":"FEM Types","title":"FEM Types","text":"AbstractElementOrder","category":"page"},{"location":"FEMType/#DDD.AbstractElementOrder","page":"FEM Types","title":"DDD.AbstractElementOrder","text":"abstract type AbstractElementOrder end\nstruct LinearElement <: AbstractElementOrder end\n\nElement orders for dispatch.\n\n\n\n\n\n","category":"type"},{"location":"FEMType/#","page":"FEM Types","title":"FEM Types","text":"AbstractShapeFunction","category":"page"},{"location":"FEMType/#DDD.AbstractShapeFunction","page":"FEM Types","title":"DDD.AbstractShapeFunction","text":"abstract type AbstractShapeFunction end\nabstract type AbstractShapeFunction3D <: AbstractShapeFunction end\nabstract type AbstractShapeFunction2D <: AbstractShapeFunction end\nstruct LinearQuadrangle3D <:AbstractShapeFunction3D end\nstruct LinearQuadrangle2D <:AbstractShapeFunction2D end\n\nShape function types for dispatch.\n\n\n\n\n\n","category":"type"},{"location":"FEMType/#Storage-1","page":"FEM Types","title":"Storage","text":"","category":"section"},{"location":"FEMType/#","page":"FEM Types","title":"FEM Types","text":"FEMParameters","category":"page"},{"location":"FEMType/#DDD.FEMParameters","page":"FEM Types","title":"DDD.FEMParameters","text":"struct FEMParameters{T1,T2,T3,T4}\n    type::T1    # Mesh type.\n    order::T2   # Element order.\n    model::T3   # M\n    dx::T3      # Size in x.\n    dy::T3      # Size in y.\n    dz::T3      # Size in z.\n    mx::T4      # Number of elements in x.\n    my::T4      # Number of elements in y.\n    mz::T4      # Number of elements in z.\nend\n\nStores the FE parameters.\n\n\n\n\n\n","category":"type"},{"location":"FEMType/#","page":"FEM Types","title":"FEM Types","text":"RegularCuboidMesh","category":"page"},{"location":"FEMType/#DDD.RegularCuboidMesh","page":"FEM Types","title":"DDD.RegularCuboidMesh","text":"struct RegularCuboidMesh{T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15} <: AbstractRegularCuboidMesh\n    order::T1           # Element order.\n    vertices::T2        # Vertices.\n    faces::T3           # Faces.\n    faceMidPt::T4       # Face midpoints.\n    faceNorm::T4        # Face normals.\n    C::T5               # Stiffness tensor.\n    dx::T6              # Size in x.  \n    dy::T6              # Size in y.\n    dz::T6              # Size in z.\n    scale::T7           # Length scale.\n    mx::T8              # Number of elements in x.\n    my::T8              # Number of elements in y.\n    mz::T8              # Number of elements in z.\n    numElem::T8         # Total number of elements.\n    numNode::T8         # Total number of nodes.\n    w::T6               # Element width (size in x).\n    h::T6               # Element height (size in y).\n    d::T6               # Element depth (size in z).\n    coord::T9           # Node coordinates.\n    connectivity::T10   # Node connectivity.\n    corners::T11        # Corner labels.\n    edges::T12          # Edge labels.\n    faces::T13          # Face labels.\n    K::T14              # Stiffness matrix.\nend\n\nStores data for a regular cuboid mesh.\n\n\n\n\n\n","category":"type"},{"location":"FEMType/#","page":"FEM Types","title":"FEM Types","text":"ForceDisplacement","category":"page"},{"location":"FEMType/#DDD.ForceDisplacement","page":"FEM Types","title":"DDD.ForceDisplacement","text":"mutable struct ForceDisplacement{T1,T2,T3,T4}\n    uTilde::T1  # Dislocation displacements.\n    uHat::T2    # Corrective displacements.\n    u::T3       # Displacement.\n    fTilde::T4  # Dislocation tractions.\n    fHat::T5    # Corrective tractions.\n    f::T6       # Force.\nend\n\nStores displacements and forces on the FE nodes.\n\n\n\n\n\n","category":"type"},{"location":"FEMType/#","page":"FEM Types","title":"FEM Types","text":"Boundaries","category":"page"},{"location":"FEMType/#DDD.Boundaries","page":"FEM Types","title":"DDD.Boundaries","text":"struct Boundaries{T1,T2,T3,T4,T5,T6}\n    uGamma::T1  # Nodes with displacement boundaries.\n    tGamma::T2  # Nodes with traction boundaries.\n    mGamma::T3  # Nodes with displacement and traction boundaries.\n    uDofs::T4   # Degrees of freedom with specified displacements.\n    tDofs::T5   # Degrees of feedom with specified tractions.\n    mDofs::T6   # Degrees of feedom with specified displacements and tractions.\nend\n\nStores the nodes and degrees of freedom upon which the different boundary conditions are applied.\n\n\n\n\n\n","category":"type"},{"location":"DislocationConstructor/#Constructors-1","page":"Dislocation Constructors","title":"Constructors","text":"","category":"section"},{"location":"DislocationConstructor/#","page":"Dislocation Constructors","title":"Dislocation Constructors","text":"SlipSystem(crystalStruct::T1, slipPlane::T2, bVec::T2) where {T1 <: AbstractCrystalStruct,T2}","category":"page"},{"location":"DislocationConstructor/#DDD.SlipSystem-Union{Tuple{T2}, Tuple{T1}, Tuple{T1,T2,T2}} where T2 where T1<:AbstractCrystalStruct","page":"Dislocation Constructors","title":"DDD.SlipSystem","text":"SlipSystem(crystalStruct::T1, slipPlane::T2, bVec::T2) \n    where {T1 <: AbstractCrystalStruct,T2}\n\nConstructor for SlipSystem. Checks for orthogonality of the burgers vector and slip plane. It assumes each column corresponds to a slip system.\n\n\n\n\n\n","category":"method"},{"location":"DislocationConstructor/#","page":"Dislocation Constructors","title":"Dislocation Constructors","text":"SlipSystem(;crystalStruct::T1, slipPlane::T2, bVec::T2) where {T1 <: AbstractCrystalStruct,T2}","category":"page"},{"location":"DislocationConstructor/#DDD.SlipSystem-Union{Tuple{}, Tuple{T2}, Tuple{T1}} where T2 where T1<:AbstractCrystalStruct","page":"Dislocation Constructors","title":"DDD.SlipSystem","text":"SlipSystem(; crystalStruct::T1, slipPlane::T2, bVec::T2) \n    where {T1 <: AbstractCrystalStruct,T2}\n\nKeyword constructor for SlipSystem.\n\n\n\n\n\n","category":"method"},{"location":"DislocationConstructor/#","page":"Dislocation Constructors","title":"Dislocation Constructors","text":"DislocationParameters(\n    coreRad::T1,\n    coreRadMag::T1,\n    minSegLen::T1,\n    maxSegLen::T1,\n    minArea::T1,\n    maxArea::T1,\n    edgeDrag::T1,\n    screwDrag::T1,\n    climbDrag::T1,\n    lineDrag::T1,\n    maxConnect::T2,\n    mobility::T3,\n    remesh::T4 = true,\n    collision::T4 = true,\n    separation::T4 = true,\n    virtualRemesh::T4 = true,\n    parCPU::T4 = false,\n    parGPU::T4 = false,\n    slipStepCritLen::T1 = maxSegLen / 2,\n    slipStepCritArea::T1 = 0.5 * (slipStepCritLen^2) * sin(2 * π / 360),\n) where {T1,T2 <: Int,T3 <: AbstractMobility,T4 <: Bool}","category":"page"},{"location":"DislocationConstructor/#DDD.DislocationParameters-Union{Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T2,T3}, Tuple{T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T2,T3,T4}, Tuple{T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T2,T3,T4,T4}, Tuple{T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T2,T3,T4,T4,T4}, Tuple{T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T2,T3,T4,T4,T4,T4}, Tuple{T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T2,T3,T4,T4,T4,T4,T4}, Tuple{T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T2,T3,T4,T4,T4,T4,T4,T4}, Tuple{T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T2,T3,T4,T4,T4,T4,T4,T4,T1}, Tuple{T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T2,T3,T4,T4,T4,T4,T4,T4,T1,T1}} where T4<:Bool where T3<:AbstractMobility where T2<:Int64 where T1","page":"Dislocation Constructors","title":"DDD.DislocationParameters","text":"DislocationParameters(\n    coreRad::T1,\n    coreRadMag::T1,\n    minSegLen::T1,\n    maxSegLen::T1,\n    minArea::T1,\n    maxArea::T1,\n    edgeDrag::T1,\n    screwDrag::T1,\n    climbDrag::T1,\n    lineDrag::T1,\n    maxConnect::T2,\n    mobility::T3,\n    remesh::T4 = true,\n    collision::T4 = true,\n    separation::T4 = true,\n    virtualRemesh::T4 = true,\n    parCPU::T4 = false,\n    parGPU::T4 = false,\n    slipStepCritLen::T1 = maxSegLen / 2,\n    slipStepCritArea::T1 = 0.5 * (slipStepCritLen^2) * sin(2 * π / 360),\n) where {T1,T2 <: Integer,T3 <: AbstractMobility,T4 <: Bool}\n\nThe constructor for DislocationParameters provides a few default values and calculates derived quantities.\n\n\n\n\n\n","category":"method"},{"location":"DislocationConstructor/#","page":"Dislocation Constructors","title":"Dislocation Constructors","text":"DislocationParameters(;\n    coreRad::T1,\n    coreRadMag::T1,\n    minSegLen::T1,\n    maxSegLen::T1,\n    minArea::T1,\n    maxArea::T1,\n    edgeDrag::T1,\n    screwDrag::T1,\n    climbDrag::T1,\n    lineDrag::T1,\n    maxConnect::T2,\n    mobility::T3,\n    remesh::T4 = true,\n    collision::T4 = true,\n    separation::T4 = true,\n    virtualRemesh::T4 = true,\n    parCPU::T4 = false,\n    parGPU::T4 = false,\n    slipStepCritLen::T1 = maxSegLen / 2,\n    slipStepCritArea::T1 = 0.5 * (slipStepCritLen^2) * sin(2 * π / 360),\n) where {T1,T2 <: Int,T3 <: AbstractMobility,T4 <: Bool}","category":"page"},{"location":"DislocationConstructor/#DDD.DislocationParameters-Union{Tuple{}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}} where T4<:Bool where T3<:AbstractMobility where T2<:Int64 where T1","page":"Dislocation Constructors","title":"DDD.DislocationParameters","text":"DislocationParameters(;\n    coreRad::T1,\n    coreRadMag::T1,\n    minSegLen::T1,\n    maxSegLen::T1,\n    minArea::T1,\n    maxArea::T1,\n    edgeDrag::T1,\n    screwDrag::T1,\n    climbDrag::T1,\n    lineDrag::T1,\n    maxConnect::T2,\n    mobility::T3,\n    remesh::T4 = true,\n    collision::T4 = true,\n    separation::T4 = true,\n    virtualRemesh::T4 = true,\n    parCPU::T4 = false,\n    parGPU::T4 = false,\n    slipStepCritLen::T1 = maxSegLen / 2,\n    slipStepCritArea::T1 = 0.5 * (slipStepCritLen^2) * sin(2 * π / 360),\n) where {T1,T2 <: Integer,T3 <: AbstractMobility,T4 <: Bool}\n\nKeyword constructor for DislocationParameters. Calls the positional constructor internally.\n\n\n\n\n\n","category":"method"},{"location":"DislocationConstructor/#","page":"Dislocation Constructors","title":"Dislocation Constructors","text":"DislocationLoop(\n    loopType::T1,\n    numSides::T2,\n    nodeSide::T2,\n    numLoops::T2,\n    segLen,\n    slipSystem::T2,\n    _slipPlane,\n    _bVec,\n    label::T3,\n    buffer,\n    range,\n    dist::T4,\n) where {\n    T1 <: AbstractDlnStr,\n    T2 <: Int,\n    T3 <: AbstractVector{nodeType},\n    T4 <: AbstractDistribution,\n}","category":"page"},{"location":"DislocationConstructor/#DDD.DislocationLoop-Union{Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T2,T2,T2,Any,T2,Any,Any,T3,Any,Any,T4}} where T4<:AbstractDistribution where T3<:AbstractArray{nodeType,1} where T2<:Int64 where T1<:AbstractDlnStr","page":"Dislocation Constructors","title":"DDD.DislocationLoop","text":"DislocationLoop(\n    loopType::T1,\n    numSides::T2,\n    nodeSide::T2,\n    numLoops::T2,\n    segLen,\n    slipSystem::T2,\n    _slipPlane,\n    _bVec,\n    label::T3,\n    buffer,\n    range,\n    dist::T4,\n) where {\n    T1 <: AbstractDlnStr,\n    T2 <: Integer,\n    T3 <: AbstractVector{nodeType},\n    T4 <: AbstractDistribution,\n}\n\nGeneral constructor for DislocationLoop.\n\n\n\n\n\n","category":"method"},{"location":"DislocationConstructor/#","page":"Dislocation Constructors","title":"Dislocation Constructors","text":"DislocationLoop(\n    loopType::T1,\n    numSides::T2,\n    nodeSide::T2,\n    numLoops::T2,\n    segLen,\n    slipSystem::T2,\n    _slipPlane::T3,\n    _bVec::T3,\n    label::T4,\n    buffer,\n    range,\n    dist::T5,\n) where {\n    T1 <: loopPure,\n    T2 <: Int,\n    T3 <: AbstractArray{T,N} where {T,N},\n    T4 <: AbstractVector{nodeType},\n    T5 <: AbstractDistribution,\n}","category":"page"},{"location":"DislocationConstructor/#DDD.DislocationLoop-Union{Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T2,T2,T2,Any,T2,T3,T3,T4,Any,Any,T5}} where T5<:AbstractDistribution where T4<:AbstractArray{nodeType,1} where T3<:(AbstractArray{T,N} where N where T) where T2<:Int64 where T1<:Union{loopPrism, loopShear}","page":"Dislocation Constructors","title":"DDD.DislocationLoop","text":"DislocationLoop(\n    loopType::T1,\n    numSides::T2,\n    nodeSide::T2,\n    numLoops::T2,\n    segLen,\n    slipSystem::T2,\n    _slipPlane::T3,\n    _bVec::T3,\n    label::T4,\n    buffer,\n    range,\n    dist::T5,\n) where {\n    T1 <: loopPure,\n    T2 <: Integer,\n    T3 <: AbstractArray{T,N} where {T,N},\n    T4 <: AbstractVector{nodeType},\n    T5 <: AbstractDistribution,\n}\n\nConstructor for loopPure loops DislocationLoop.\n\n\n\n\n\n","category":"method"},{"location":"DislocationConstructor/#","page":"Dislocation Constructors","title":"Dislocation Constructors","text":"DislocationLoop(\n    loopType::T1,\n    numSides::T2,\n    nodeSide::T2,\n    numLoops::T2,\n    segLen,\n    slipSystem::T2,\n    _slipPlane::T3,\n    _bVec::T3,\n    label::T4,\n    buffer,\n    range,\n    dist::T5,\n) where {\n    T1 <: loopImpure,\n    T2 <: Int,\n    T3 <: AbstractArray{T,N} where {T,N},\n    T4 <: AbstractVector{nodeType},\n    T5 <: AbstractDistribution,\n}","category":"page"},{"location":"DislocationConstructor/#DDD.DislocationLoop-Union{Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T2,T2,T2,Any,T2,T3,T3,T4,Any,Any,T5}} where T5<:AbstractDistribution where T4<:AbstractArray{nodeType,1} where T3<:(AbstractArray{T,N} where N where T) where T2<:Int64 where T1<:Union{DDD.loopJog, DDD.loopKink, DDD.loopMixed}","page":"Dislocation Constructors","title":"DDD.DislocationLoop","text":"DislocationLoop(\n    loopType::T1,\n    numSides::T2,\n    nodeSide::T2,\n    numLoops::T2,\n    segLen,\n    slipSystem::T2,\n    _slipPlane::T3,\n    _bVec::T3,\n    label::T4,\n    buffer,\n    range,\n    dist::T5,\n) where {\n    T1 <: loopImpure,\n    T2 <: Integer,\n    T3 <: AbstractArray{T,N} where {T,N},\n    T4 <: AbstractVector{nodeType},\n    T5 <: AbstractDistribution,\n}\n\nA fallback DislocationLoop constructor for other as of yet unimplemented loopType.\n\n\n\n\n\n","category":"method"},{"location":"DislocationConstructor/#","page":"Dislocation Constructors","title":"Dislocation Constructors","text":"DislocationLoop(;\n    loopType::T1,\n    numSides::T2,\n    nodeSide::T2,\n    numLoops::T2,\n    segLen::T3,\n    slipSystem::T2,\n    _slipPlane::T4,\n    _bVec::T4,\n    label::T5,\n    buffer::T6,\n    range::T7,\n    dist::T8,\n) where {\n    T1 <: AbstractDlnStr,\n    T2 <: Int,\n    T3 <: Union{T where {T},AbstractArray{T,N} where {T,N}},\n    T4 <: AbstractArray{T,N} where {T,N},\n    T5 <: AbstractVector{nodeType},\n    T6,\n    T7 <: AbstractArray{T,N} where {T,N},\n    T8 <: AbstractDistribution,\n}","category":"page"},{"location":"DislocationConstructor/#DDD.DislocationLoop-Union{Tuple{}, Tuple{T8}, Tuple{T7}, Tuple{T6}, Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}} where T8<:AbstractDistribution where T7<:(AbstractArray{T,N} where N where T) where T6 where T5<:AbstractArray{nodeType,1} where T4<:(AbstractArray{T,N} where N where T) where T3 where T2<:Int64 where T1<:AbstractDlnStr","page":"Dislocation Constructors","title":"DDD.DislocationLoop","text":"DislocationLoop(;\n    loopType::T1,\n    numSides::T2,\n    nodeSide::T2,\n    numLoops::T2,\n    segLen::T3,\n    slipSystem::T2,\n    _slipPlane::T4,\n    _bVec::T4,\n    label::T5,\n    buffer::T6,\n    range::T7,\n    dist::T8,\n) where {\n    T1 <: AbstractDlnStr,\n    T2 <: Integer,\n    T3 <: Union{T where {T},AbstractArray{T,N} where {T,N}},\n    T4 <: AbstractArray{T,N} where {T,N},\n    T5 <: AbstractVector{nodeType},\n    T6,\n    T7 <: AbstractArray{T,N} where {T,N},\n    T8 <: AbstractDistribution,\n}\n\nKeyword DislocationLoop constructor calls the positional constructor, which dispatches the appropriate method.\n\n\n\n\n\n","category":"method"},{"location":"DislocationConstructor/#","page":"Dislocation Constructors","title":"Dislocation Constructors","text":"DislocationNetwork(\n    links::T1,\n    slipPlane::T2,\n    bVec::T2,\n    coord::T2,\n    label::T3,\n    nodeVel::T2,\n    nodeForce::T2,\n    numNode::T4 = zeros(Int, 1),\n    numSeg::T4 = zeros(Int, 1),\n    maxConnect::T5 = 4,\n    connectivity::T1 = zeros(Int, 1 + 2 * maxConnect, length(label)),\n    linksConnect::T1 = zeros(Int, 2, size(links, 2)),\n    segIdx::T1 = zeros(Int, size(links, 2), 3),\n    segForce::T6 = zeros(3, size(links)...),\n) where {\n    T1 <: AbstractArray{T,N} where {T,N},\n    T2 <: AbstractArray{T,N} where {T,N},\n    T3 <: AbstractVector{nodeType},\n    T4 <: Union{Int,AbstractVector{Int}},\n    T5 <: Int,T6 <: AbstractArray{T,N} where {T,N},\n}","category":"page"},{"location":"DislocationConstructor/#DDD.DislocationNetwork-Union{Tuple{T6}, Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T2,T2,T2,T3,T2,T2}, Tuple{T1,T2,T2,T2,T3,T2,T2,T4}, Tuple{T1,T2,T2,T2,T3,T2,T2,T4,T4}, Tuple{T1,T2,T2,T2,T3,T2,T2,T4,T4,T5}, Tuple{T1,T2,T2,T2,T3,T2,T2,T4,T4,T5,T1}, Tuple{T1,T2,T2,T2,T3,T2,T2,T4,T4,T5,T1,T1}, Tuple{T1,T2,T2,T2,T3,T2,T2,T4,T4,T5,T1,T1,T1}, Tuple{T1,T2,T2,T2,T3,T2,T2,T4,T4,T5,T1,T1,T1,T6}} where T6<:(AbstractArray{T,N} where N where T) where T5<:Int64 where T4<:Union{Int64, AbstractArray{Int64,1}} where T3<:AbstractArray{nodeType,1} where T2<:(AbstractArray{T,N} where N where T) where T1<:(AbstractArray{T,N} where N where T)","page":"Dislocation Constructors","title":"DDD.DislocationNetwork","text":"DislocationNetwork(\n    links::T1,\n    slipPlane::T2,\n    bVec::T2,\n    coord::T2,\n    label::T3,\n    nodeVel::T2,\n    nodeForce::T2,\n    numNode::T4 = zeros(Int, 1),\n    numSeg::T4 = zeros(Int, 1),\n    maxConnect::T5 = 4,\n    connectivity::T1 = zeros(Int, 1 + 2 * maxConnect, length(label)),\n    linksConnect::T1 = zeros(Int, 2, size(links, 2)),\n    segIdx::T1 = zeros(Int, size(links, 2), 3),\n    segForce::T6 = zeros(3, size(links)...),\n) where {\n    T1 <: AbstractArray{T,N} where {T,N},\n    T2 <: AbstractArray{T,N} where {T,N},\n    T3 <: AbstractVector{nodeType},\n    T4 <: Union{Int,AbstractVector{Int}},\n    T5 <: Integer,T6 <: AbstractArray{T,N} where {T,N},\n}\n\nDislocationNetwork constructor provides default values, validates inputs and calculates derived quantities.\n\n\n\n\n\n","category":"method"},{"location":"DislocationConstructor/#","page":"Dislocation Constructors","title":"Dislocation Constructors","text":"DislocationNetwork(;\n    links::T1,\n    slipPlane::T2,\n    bVec::T2,\n    coord::T2,\n    label::T3,\n    nodeVel::T2,\n    nodeForce::T2,\n    numNode::T4 = zeros(Int, 1),\n    numSeg::T4 = zeros(Int, 1),\n    maxConnect::T5 = 0,\n    connectivity::T1 = zeros(Int, 1 + 2 * maxConnect, length(label)),\n    linksConnect::T1 = zeros(Int, 2, size(links, 2)),\n    segIdx::T1 = zeros(Int, size(links, 2), 3),\n    segForce::T6 = zeros(3, size(links, 2), 0),\n) where {\n    T1 <: AbstractArray{T,N} where {T,N},\n    T2 <: AbstractArray{T,N} where {T,N},\n    T3 <: AbstractVector{nodeType},T4 <: AbstractVector{Int},\n    T5 <: Int,\n    T6 <: AbstractArray{T,N} where {T,N},\n}","category":"page"},{"location":"DislocationConstructor/#DDD.DislocationNetwork-Union{Tuple{}, Tuple{T6}, Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}} where T6<:(AbstractArray{T,N} where N where T) where T5<:Int64 where T4<:AbstractArray{Int64,1} where T3<:AbstractArray{nodeType,1} where T2<:(AbstractArray{T,N} where N where T) where T1<:(AbstractArray{T,N} where N where T)","page":"Dislocation Constructors","title":"DDD.DislocationNetwork","text":"DislocationNetwork(;\n    links::T1,\n    slipPlane::T2,\n    bVec::T2,\n    coord::T2,\n    label::T3,\n    nodeVel::T2,\n    nodeForce::T2,\n    numNode::T4 = zeros(Int, 1),\n    numSeg::T4 = zeros(Int, 1),\n    maxConnect::T5 = 0,\n    connectivity::T1 = zeros(Int, 1 + 2 * maxConnect, length(label)),\n    linksConnect::T1 = zeros(Int, 2, size(links, 2)),\n    segIdx::T1 = zeros(Int, size(links, 2), 3),\n    segForce::T6 = zeros(3, size(links, 2), 0),\n) where {\n    T1 <: AbstractArray{T,N} where {T,N},\n    T2 <: AbstractArray{T,N} where {T,N},\n    T3 <: AbstractVector{nodeType},T4 <: AbstractVector{Int},\n    T5 <: Integer,\n    T6 <: AbstractArray{T,N} where {T,N},\n}\n\nKeyword constructor for DislocationNetwork, calls the positional one.\n\n\n\n\n\n","category":"method"},{"location":"DislocationConstructor/#","page":"Dislocation Constructors","title":"Dislocation Constructors","text":"DislocationNetwork(\n    sources::T1,\n    maxConnect::T2 = 4,\n    args...;\n    memBuffer = nothing,\n    checkConsistency::T3 = true,\n    kw...,\n) where {\n    T1 <: Union{T,\n                AbstractVector{T},\n                NTuple{N,T} where N\n                } where {T <: DislocationLoop},\n    T2 <: Int,\n    T3 <: Bool,\n}","category":"page"},{"location":"DislocationConstructor/#DDD.DislocationNetwork-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T2,Vararg{Any,N} where N}} where T3<:Bool where T2<:Int64 where T1<:(Union{AbstractArray{T,1}, Tuple{Vararg{T,N}} where N, T} where T<:DislocationLoop)","page":"Dislocation Constructors","title":"DDD.DislocationNetwork","text":"DislocationNetwork(\n    sources::T1,\n    maxConnect::T2 = 4,\n    args...;\n    memBuffer = nothing,\n    checkConsistency::T3 = true,\n    kw...,\n) where {\n    T1 <: Union{T,\n                AbstractVector{T},\n                NTuple{N,T} where N\n                } where {T <: DislocationLoop},\n    T2 <: Integer,\n    T3 <: Bool,\n}\n\nThe recommended way of creating a network is to use a source of type DislocationLoop. It also accepts arrays and tuples of DislocationLoop variables. This automatically generates the network according to the parameters stored in source or each of its entries.\n\nMeaning\n\nargs... are optional arguments that will be passed on to the loopDistribution function which distributes the loops in sources according to the type of their dist variable.\nkw... are optional keyword arguments that will also be passed to loopDistribution.\nmemBuffer is the numerical value for allocating memory in advance. The quantity, memBuffer × N, where N is the total number of nodes in sources, will be the initial number of entries allocated in the matrices that keep the network's data. If no memBuffer is provided, the number of entries allocated will be `round(N*log2(N)).\n\n\n\n\n\n","category":"method"},{"location":"DislocationConstructor/#","page":"Dislocation Constructors","title":"Dislocation Constructors","text":"DislocationNetwork!(\n    network::T1,\n    sources::T2,\n    maxConnect::T3 = 4,\n    args...;\n    checkConsistency::T4 = true,\n    kw...,\n) where {\n    T1 <: DislocationNetwork,\n    T2 <: Union{T,\n                AbstractVector{T},\n                NTuple{N,T} where N\n                } where {T <: DislocationLoop},\n    T3 <: Int,\n    T4 <: Bool,\n}","category":"page"},{"location":"DislocationConstructor/#DDD.DislocationNetwork!-Union{Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T2}, Tuple{T1,T2,T3,Vararg{Any,N} where N}} where T4<:Bool where T3<:Int64 where T2<:(Union{AbstractArray{T,1}, Tuple{Vararg{T,N}} where N, T} where T<:DislocationLoop) where T1<:DislocationNetwork","page":"Dislocation Constructors","title":"DDD.DislocationNetwork!","text":"DislocationNetwork!(\n    network::T1,\n    sources::T2,\n    maxConnect::T3 = 4,\n    args...;\n    checkConsistency::T4 = true,\n    kw...,\n) where {\n    T1 <: DislocationNetwork,\n    T2 <: Union{T,\n                AbstractVector{T},\n                NTuple{N,T} where N\n                } where {T <: DislocationLoop},\n    T3 <: Integer,\n    T4 <: Bool,\n}\n\nAdds more sources to an existing network.\n\n\n\n\n\n","category":"method"},{"location":"DislocationConstructor/#","page":"Dislocation Constructors","title":"Dislocation Constructors","text":"makeNetwork!","category":"page"},{"location":"DislocationConstructor/#DDD.makeNetwork!","page":"Dislocation Constructors","title":"DDD.makeNetwork!","text":"makeNetwork!(\n    links,\n    slipPlane,\n    bVec,\n    coord,\n    label,\n    sources,\n    lims,\n    initIdx,\n    args...;\n    kw...,\n)\n\nInternal function called by the recommended DislocationNetwork method and its mutating counterpart DislocationNetwork!, to automatically fill the matrices with the information from sources.\n\n\n\n\n\n","category":"function"},{"location":"DislocationConstructor/#Utility-1","page":"Dislocation Constructors","title":"Utility","text":"","category":"section"},{"location":"DislocationConstructor/#","page":"Dislocation Constructors","title":"Dislocation Constructors","text":"loopDistribution","category":"page"},{"location":"DislocationConstructor/#DDD.loopDistribution","page":"Dislocation Constructors","title":"DDD.loopDistribution","text":"loopDistribution(::Rand, n, args...; kw...)\n\nReturns a 3 × n matrix whose points follow a random uniform distribution. Used by DislocationNetwork when the dist parameter of DislocationLoop is Rand().\n\n\n\n\n\nloopDistribution(::Zeros, n, args...; kw...)\n\nReturns a 3 × n zeros matrix. Used by DislocationNetwork when the dist parameter of DislocationLoop is Zeros().\n\n\n\n\n\nloopDistribution(::Rand, n, args...; kw...)\n\nReturns a 3 × n matrix whose points follow a random normal distribution. Used by DislocationNetwork when the dist parameter of DislocationLoop is Randn().\n\n\n\n\n\nloopDistribution(::Rand, n, args...; kw...)\n\nReturns a 3 × n matrix whose points follow are regularly placed. Used by DislocationNetwork when the dist parameter of DislocationLoop is Regular().\n\nnote: Note\nNot yet implemented.\n\n\n\n\n\n","category":"function"},{"location":"DislocationConstructor/#","page":"Dislocation Constructors","title":"Dislocation Constructors","text":"limits!","category":"page"},{"location":"DislocationConstructor/#DDD.limits!","page":"Dislocation Constructors","title":"DDD.limits!","text":"limits!(lims, segLen, range, buffer)\n\nCalculate the bounding limits within which a DislocationLoop can be distributed in a DislocationNetwork.\n\n\n\n\n\n","category":"function"},{"location":"DislocationConstructor/#","page":"Dislocation Constructors","title":"Dislocation Constructors","text":"translatePoints!","category":"page"},{"location":"DislocationConstructor/#DDD.translatePoints!","page":"Dislocation Constructors","title":"DDD.translatePoints!","text":"translatePoints!(coord, lims, disp)\n\nTranslates coordinates using the limits and displacements calculated by limits! and loopDistribution.\n\n\n\n\n\n","category":"function"},{"location":"DislocationConstructor/#","page":"Dislocation Constructors","title":"Dislocation Constructors","text":"makeSegment","category":"page"},{"location":"DislocationConstructor/#DDD.makeSegment","page":"Dislocation Constructors","title":"DDD.makeSegment","text":"makeSegment(::segEdge, slipPlane, bVec)\n\nReturn the edge segment (slipPlane × bVec) / || slipPlane × bVec ||. Used to create segments for DislocationNetwork.\n\n\n\n\n\nmakeSegment(::segEdge, slipPlane, bVec)\n\nReturn the edge segment slipPlane / || slipPlane ||. Used to create segments for DislocationNetwork.\n\n\n\n\n\nmakeSegment(::segScrew, slipPlane, bVec)\n\nReturn the screw segment bVec / || bVec ||. Used to create segments for DislocationNetwork.\n\n\n\n\n\n","category":"function"},{"location":"DislocationConstructor/#","page":"Dislocation Constructors","title":"Dislocation Constructors","text":"makeConnect","category":"page"},{"location":"DislocationConstructor/#DDD.makeConnect","page":"Dislocation Constructors","title":"DDD.makeConnect","text":"makeConnect(links, maxConnect)\n\nCreates connectivity and linksConnect matrices for DislocationNetwork. \n\nconnectivity contains the number of other other nodes each node is connected to, up to maxConnect other nodes. Every (2i, j) entry contains a node connected to node j. Every (2i+1, j) coordinate contains whether that node is the first or second node in the link.\nlinksConnect relates connections enabled by a link. Analogous to the connectivity of a link.\n\n\n\n\n\n","category":"function"},{"location":"DislocationConstructor/#","page":"Dislocation Constructors","title":"Dislocation Constructors","text":"makeConnect!","category":"page"},{"location":"DislocationConstructor/#DDD.makeConnect!","page":"Dislocation Constructors","title":"DDD.makeConnect!","text":"makeConnect!(network::DislocationNetwork)\n\nMutates the connectivity and linksConnect matrices of network. Works the same as makeConnect.\n\n\n\n\n\n","category":"function"},{"location":"DislocationConstructor/#","page":"Dislocation Constructors","title":"Dislocation Constructors","text":"getSegmentIdx","category":"page"},{"location":"DislocationConstructor/#DDD.getSegmentIdx","page":"Dislocation Constructors","title":"DDD.getSegmentIdx","text":"getSegmentIdx(links, label)\n\nReturns an n × 3 matrix is of the form [i, node1, node2]. \n\ni can be used to find the Burgers vector, slip plane and segment forces of segment i, eg bVec[:, i]. \nnode1 and node2 can be used to find the coordinate and velocity of the nodes, eg l = coord[:, node2] - coord[:, node1].\n\n\n\n\n\n","category":"function"},{"location":"DislocationConstructor/#","page":"Dislocation Constructors","title":"Dislocation Constructors","text":"getSegmentIdx!","category":"page"},{"location":"DislocationConstructor/#DDD.getSegmentIdx!","page":"Dislocation Constructors","title":"DDD.getSegmentIdx!","text":"getSegmentIdx!(network::DislocationNetwork)\n\nMutates the segIdx matrix in network. Works the same way as getSegmentIdx.\n\n\n\n\n\n","category":"function"},{"location":"DislocationConstructor/#","page":"Dislocation Constructors","title":"Dislocation Constructors","text":"checkNetwork","category":"page"},{"location":"DislocationConstructor/#DDD.checkNetwork","page":"Dislocation Constructors","title":"DDD.checkNetwork","text":"checkNetwork(network::DislocationNetwork)\n\nChecks the validity of the dislocation network. It ensures the following conditions are met by the member variables of network:\n\nconnectivity and links have the same number of non-zero entries;\nall entries in bVec are non-zero;\nonly the trailing columns of connectivity are zeros;\nconsistency between connectivity and links;\nbVec is conserved among connected nodes;\nentries in links are unique;\nconsistency betwen connectivity and linksConnect\n\n\n\n\n\n","category":"function"},{"location":"IntegrationConstructor/#Constructors-1","page":"Integration Constructors","title":"Constructors","text":"","category":"section"},{"location":"IntegrationConstructor/#","page":"Integration Constructors","title":"Integration Constructors","text":"IntegrationParameters(\n    method::T1,\n    tmin::T2,\n    tmax::T2,\n    dtmin::T2 = 1e-3,\n    dtmax::T2 = Inf,\n    abstol::T2 = 1e-6,\n    reltol::T2 = 1e-6,\n    maxchange::T2 = 1.2,\n    exponent::T2 = 20.0,\n    maxiter::T3 = 10,\n) where {\n    T1 <: AbstractIntegrator,\n    T2 <: AbstractFloat,\n    T3 <: Integer\n}","category":"page"},{"location":"IntegrationConstructor/#DDD.IntegrationParameters-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T2,T2}, Tuple{T1,T2,T2,T2}, Tuple{T1,T2,T2,T2,T2}, Tuple{T1,T2,T2,T2,T2,T2}, Tuple{T1,T2,T2,T2,T2,T2,T2}, Tuple{T1,T2,T2,T2,T2,T2,T2,T2}, Tuple{T1,T2,T2,T2,T2,T2,T2,T2,T2}, Tuple{T1,T2,T2,T2,T2,T2,T2,T2,T2,T3}} where T3<:Integer where T2<:AbstractFloat where T1<:AbstractIntegrator","page":"Integration Constructors","title":"DDD.IntegrationParameters","text":"IntegrationParameters(\n    method::T1,\n    tmin::T2,\n    tmax::T2,\n    dtmin::T2 = 1e-3,\n    dtmax::T2 = Inf,\n    abstol::T2 = 1e-6,\n    reltol::T2 = 1e-6,\n    maxchange::T2 = 1.2,\n    exponent::T2 = 20.0,\n    maxiter::T3 = 10,\n) where {\n    T1 <: AbstractIntegrator,\n    T2 <: AbstractFloat,\n    T3 <: Integer\n}\n\nConstructor for IntegrationParameters.\n\n\n\n\n\n","category":"method"},{"location":"IntegrationConstructor/#","page":"Integration Constructors","title":"Integration Constructors","text":"IntegrationParameters(;\n    method::T1,\n    tmin::T2,\n    tmax::T2,\n    dtmin::T2 = 1e-3,\n    dtmax::T2 = Inf,\n    abstol::T2 = 1e-6,\n    reltol::T2 = 1e-6,\n    maxchange::T2 = 1.2,\n    exponent::T2 = 20.0,\n    maxiter::T3 = 10,\n) where {\n    T1 <: AbstractIntegrator,\n    T2 <: AbstractFloat,\n    T3 <: Integer\n}","category":"page"},{"location":"IntegrationConstructor/#DDD.IntegrationParameters-Union{Tuple{}, Tuple{T3}, Tuple{T2}, Tuple{T1}} where T3<:Integer where T2<:AbstractFloat where T1<:AbstractIntegrator","page":"Integration Constructors","title":"DDD.IntegrationParameters","text":"IntegrationParameters(;\n    method::T1,\n    tmin::T2,\n    tmax::T2,\n    dtmin::T2 = 1e-3,\n    dtmax::T2 = Inf,\n    abstol::T2 = 1e-6,\n    reltol::T2 = 1e-6,\n    maxchange::T2 = 1.2,\n    exponent::T2 = 20.0,\n    maxiter::T3 = 10,\n) where {\n    T1 <: AbstractIntegrator,\n    T2 <: AbstractFloat,\n    T3 <: Integer\n}\n\nKeyword constructor for IntegrationParameters.\n\n\n\n\n\n","category":"method"},{"location":"IntegrationConstructor/#","page":"Integration Constructors","title":"Integration Constructors","text":"IntegrationTime(dt::T1, time::T1, step::T2) where {T1 <: AbstractFloat,T2 <: Integer}","category":"page"},{"location":"IntegrationConstructor/#DDD.IntegrationTime-Union{Tuple{T2}, Tuple{T1}, Tuple{T1,T1,T2}} where T2<:Integer where T1<:AbstractFloat","page":"Integration Constructors","title":"DDD.IntegrationTime","text":"IntegrationTime(dt::T1, time::T1, step::T2) \n    where {T1 <: AbstractFloat,T2 <: Integer}\n\nConstructor for IntegrationTime.\n\n\n\n\n\n","category":"method"},{"location":"IntegrationConstructor/#","page":"Integration Constructors","title":"Integration Constructors","text":"IntegrationTime(; dt::T1, time::T1, step::T2) where {T1 <: AbstractFloat,T2 <: Integer}","category":"page"},{"location":"IntegrationConstructor/#DDD.IntegrationTime-Union{Tuple{}, Tuple{T2}, Tuple{T1}} where T2<:Integer where T1<:AbstractFloat","page":"Integration Constructors","title":"DDD.IntegrationTime","text":"IntegrationTime(; dt::T1, time::T1, step::T2) \n    where {T1 <: AbstractFloat,T2 <: Integer}\n\nKeyword constructor for IntegrationTime.\n\n\n\n\n\n","category":"method"},{"location":"DislocationExtendedMethods/#Extended-Methods-1","page":"Dislocation Extended Methods","title":"Extended Methods","text":"","category":"section"},{"location":"DislocationExtendedMethods/#","page":"Dislocation Extended Methods","title":"Dislocation Extended Methods","text":"zero(::Type{DislocationLoop})","category":"page"},{"location":"DislocationExtendedMethods/#Base.zero-Tuple{Type{DislocationLoop}}","page":"Dislocation Extended Methods","title":"Base.zero","text":"zero(::Type{DislocationLoop})\n\nReturns a zero instance of a DislocationLoop.\n\n\n\n\n\n","category":"method"},{"location":"DislocationExtendedMethods/#","page":"Dislocation Extended Methods","title":"Dislocation Extended Methods","text":"zero(::Type{DislocationNetwork})","category":"page"},{"location":"DislocationExtendedMethods/#Base.zero-Tuple{Type{DislocationNetwork}}","page":"Dislocation Extended Methods","title":"Base.zero","text":"zero(::Type{DislocationNetwork})\n\nReturns a zero instance of DislocationNetwork.\n\n\n\n\n\n","category":"method"},{"location":"DislocationExtendedMethods/#","page":"Dislocation Extended Methods","title":"Dislocation Extended Methods","text":"push!(network::DislocationNetwork, n::Int)","category":"page"},{"location":"DislocationExtendedMethods/#Base.push!-Tuple{DislocationNetwork,Int64}","page":"Dislocation Extended Methods","title":"Base.push!","text":"push!(network::DislocationNetwork, n::Int)\n\nPushes n new datapoints into network.\n\n\n\n\n\n","category":"method"},{"location":"DislocationExtendedMethods/#","page":"Dislocation Extended Methods","title":"Dislocation Extended Methods","text":"getindex(network::DislocationNetwork, i)","category":"page"},{"location":"DislocationExtendedMethods/#Base.getindex-Tuple{DislocationNetwork,Any}","page":"Dislocation Extended Methods","title":"Base.getindex","text":"getindex(network::DislocationNetwork, i)\n\nReturns a view of network at index i.\n\n\n\n\n\n","category":"method"},{"location":"Forces/#Forces-1","page":"Calculate Forces","title":"Forces","text":"","category":"section"},{"location":"Forces/#","page":"Calculate Forces","title":"Calculate Forces","text":"calcSegForce","category":"page"},{"location":"Forces/#DDD.calcSegForce","page":"Calculate Forces","title":"DDD.calcSegForce","text":"calcSegForce(\n    dlnParams::DislocationParameters,\n    matParams::MaterialParameters,\n    network::DislocationNetwork;\n    # mesh::RegularCuboidMesh,\n    # dlnFEM::DislocationFEMCorrective;\n    parallel::Bool = true,\n)\n\n\n\n\n\n","category":"function"},{"location":"Forces/#","page":"Calculate Forces","title":"Calculate Forces","text":"calcSegForce!","category":"page"},{"location":"Forces/#","page":"Calculate Forces","title":"Calculate Forces","text":"calcPKForce","category":"page"},{"location":"Forces/#DDD.calcPKForce","page":"Calculate Forces","title":"DDD.calcPKForce","text":"calcPKForce(\n    mesh::RegularCuboidMesh,\n    dlnFEM::DislocationFEMCorrective,\n    network::DislocationNetwork,\n)\n\nCalculate the Peach-Koehler force on segments.\n\nf = (hatmathbbsigma cdot overrightarrowb) times overrightarrowt\n\n\n\n\n\n","category":"function"},{"location":"Forces/#","page":"Calculate Forces","title":"Calculate Forces","text":"calcPKForce!","category":"page"},{"location":"Forces/#","page":"Calculate Forces","title":"Calculate Forces","text":"calc_σHat","category":"page"},{"location":"Forces/#DDD.calc_σHat","page":"Calculate Forces","title":"DDD.calc_σHat","text":"calc_σHat(\n    mesh::RegularCuboidMesh,\n    forceDisplacement::ForceDisplacement,\n    x0::AbstractVector{T} where {T},\n)\n\nCalculate the reaction stress, σ, from a dislocation.\n\n\n\n\n\n","category":"function"},{"location":"Forces/#","page":"Calculate Forces","title":"Calculate Forces","text":"calcSelfForce","category":"page"},{"location":"Forces/#DDD.calcSelfForce","page":"Calculate Forces","title":"DDD.calcSelfForce","text":"calcSelfForce(\n    dlnParams::DislocationParameters,\n    matParams::MaterialParameters,\n    network::DislocationNetwork,\n)\n\nCalculates the self-interaction force felt by two nodes in a segment. Naturally the forces are equal and opposite to each other.\n\n\n\n\n\n","category":"function"},{"location":"Forces/#","page":"Calculate Forces","title":"Calculate Forces","text":"calcSelfForce!","category":"page"},{"location":"Forces/#","page":"Calculate Forces","title":"Calculate Forces","text":"calcSegSegForce","category":"page"},{"location":"Forces/#DDD.calcSegSegForce","page":"Calculate Forces","title":"DDD.calcSegSegForce","text":"!!! Note     This function is based on the SegSegForces function by A. Arsenlis et al. It is optimised for speed and reusability. It has also been locally parallelised.\n\n\n\nIt implements the analytical solution of the force between two dislocation segments. Details are found in Appendix A.1. in \"Enabling Strain Hardening Simulations with Dislocation Dynamics\" by A. Arsenlis et al.\n\nAt a high level this works by creating a local coordinate frame using the line directions of the dislocation segments and a vector orthogonal to them. The line integrals are then evaluated parametrically utilising this local coordinate. BibTex citation here:\n\n@article{Arsenlis_2007, \tdoi = {10.1088/0965-0393/15/6/001}, \turl = {https://doi.org/10.1088%2F0965-0393%2F15%2F6%2F001}, \tyear = 2007, \tmonth = {jul}, \tpublisher = {{IOP} Publishing}, \tvolume = {15}, \tnumber = {6}, \tpages = {553–595}, \tauthor = {A Arsenlis and W Cai and M Tang and M Rhee and T Oppelstrup and G Hommes and T G Pierce and V V Bulatov}, \ttitle = {Enabling strain hardening simulations with dislocation dynamics}, \tjournal = {Modelling and Simulation in Materials Science and Engineering}, \tabstract = {Numerical algorithms for discrete dislocation dynamics simulations are investigated for the purpose of enabling strain hardening simulations of single crystals on massively parallel computers. The algorithms investigated include the calculation of forces, the equations of motion, time integration, adaptive mesh refinement, the treatment of dislocation core reactions and the dynamic distribution of data and work on parallel computers. A simulation integrating all these algorithmic elements using the Parallel Dislocation Simulator (ParaDiS) code is performed to understand their behaviour in concert and to evaluate the overall numerical performance of dislocation dynamics simulations and their ability to accumulate percent of plastic strain.} }\n\n\n\n\n\n","category":"function"},{"location":"Forces/#","page":"Calculate Forces","title":"Calculate Forces","text":"calcSegSegForce!","category":"page"},{"location":"FEMConstructor/#Constructors-1","page":"FEM Constructors","title":"Constructors","text":"","category":"section"},{"location":"FEMConstructor/#","page":"FEM Constructors","title":"FEM Constructors","text":"FEMParameters(type::T1, order::T2, dx::T3, dy::T3, dz::T3, mx::T4, my::T4, mz::T4) where {T1 <: AbstractMesh,T2 <: AbstractElementOrder,T3 <: AbstractFloat,T4 <: Integer}","category":"page"},{"location":"FEMConstructor/#","page":"FEM Constructors","title":"FEM Constructors","text":"FEMParameters(; type::T1, order::T2, dx::T3, dy::T3, dz::T3, mx::T4, my::T4, mz::T4) where {T1 <: AbstractMesh,T2 <: AbstractElementOrder,T3 <: AbstractFloat,T4 <: Integer}","category":"page"},{"location":"FEMConstructor/#DDD.FEMParameters-Union{Tuple{}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}} where T4<:Integer where T3<:AbstractFloat where T2<:AbstractElementOrder where T1<:AbstractMesh","page":"FEM Constructors","title":"DDD.FEMParameters","text":"FEMParameters(;\n    type::T1,\n    order::T2,\n    model::T3,\n    dx::T4,\n    dy::T4,\n    dz::T4,\n    mx::T5,\n    my::T5,\n    mz::T5\n) where {\n    T1 <: AbstractMesh,\n    T2 <: AbstractModel,\n    T3 <: AbstractElementOrder,\n    T4 <: AbstractFloat,\n    T5 <: Integer\n}\n\nKeyword constructor for FEMParameters. Calls the positional constructor.\n\n\n\n\n\n","category":"method"},{"location":"FEMConstructor/#","page":"FEM Constructors","title":"FEM Constructors","text":"buildMesh","category":"page"},{"location":"FEMConstructor/#DDD.buildMesh","page":"FEM Constructors","title":"DDD.buildMesh","text":"buildMesh(matParams::T1, femParams::T2) \n    where {T1 <: MaterialParameters,T2 <: FEMParameters}\n\nInternally calls another buildMesh that dispatches based on FEMParameters.type.\n\n\n\n\n\nbuildMesh(::T1, matParams::T2, femParams::T3) \n    where {T1 <: DispatchRegularCuboidMesh,T2 <: MaterialParameters,T3 <: FEMParameters}\n\nBuilds a RegularCuboidMesh by dispatching on femParams.type == DispatchRegularCuboidMesh().\n\n\n\n\n\n","category":"function"},{"location":"FEMConstructor/#","page":"FEM Constructors","title":"FEM Constructors","text":"RegularCuboidMesh(\n    order::T1, \n    matParams::T2, \n    femParams::T3\n) where {\n    T1 <: LinearElement,\n    T2 <: MaterialParameters,\n    T3 <: FEMParameters\n}","category":"page"},{"location":"FEMConstructor/#DDD.RegularCuboidMesh-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T2,T3}} where T3<:FEMParameters where T2<:MaterialParameters where T1<:LinearElement","page":"FEM Constructors","title":"DDD.RegularCuboidMesh","text":"RegularCuboidMesh(\n    order::T1, \n    matParams::T2, \n    femParams::T3\n) where {\n    T1 <: LinearElement,\n    T2 <: MaterialParameters,\n    T3 <: FEMParameters\n}\n\nCreated by: E. Tarleton edmund.tarleton@materials.ox.ac.uk\n\n3D FEM code using linear 8 node element with 8 integration pts (2x2x2) per element.\n\n   4.-------.3\n   | \\       |\\\n   |  \\      | \\    my\n   1.--\\---- .2 \\\n    \\   \\     \\  \\\n     \\  8.--------.7\n      \\  |      \\ |  mz\n       \\ |       \\|\n         5.--------.6\n             mx\ny   ^z\n ↖  |\n  \\ |\n   \\|---->x\n\nnote: Note\nThis is rotated about the x axis w.r.t. to the local (s1, s2, s3) system. calc_σHat uses custom linear shape functions that eliminate the need for a Jacobian, speeding up the calculation. We keep the Jacobian in this function because it's only run at simulation initialisation so it's not performance critical, which lets us use standard shape functions.\n\n\n\n\n\n","category":"method"},{"location":"FEMConstructor/#","page":"FEM Constructors","title":"FEM Constructors","text":"RegularCuboidMesh(;\n    order::T1, \n    matParams::T2, \n    femParams::T3\n) where {\n    T1 <: AbstractElementOrder,\n    T2 <: MaterialParameters,\n    T3 <: FEMParameters\n}","category":"page"},{"location":"FEMConstructor/#DDD.RegularCuboidMesh-Union{Tuple{}, Tuple{T3}, Tuple{T2}, Tuple{T1}} where T3<:FEMParameters where T2<:MaterialParameters where T1<:AbstractElementOrder","page":"FEM Constructors","title":"DDD.RegularCuboidMesh","text":"RegularCuboidMesh(;\n    order::T1, \n    matParams::T2, \n    femParams::T3\n) where {\n    T1 <: AbstractElementOrder,\n    T2 <: MaterialParameters,\n    T3 <: FEMParameters\n}\n\nKeyword constructor for RegularCuboidMesh.\n\n\n\n\n\n","category":"method"},{"location":"IntegrationType/#Types-1","page":"Integration Types","title":"Types","text":"","category":"section"},{"location":"IntegrationType/#Primitive-1","page":"Integration Types","title":"Primitive","text":"","category":"section"},{"location":"IntegrationType/#","page":"Integration Types","title":"Integration Types","text":"AbstractIntegrator","category":"page"},{"location":"IntegrationType/#DDD.AbstractIntegrator","page":"Integration Types","title":"DDD.AbstractIntegrator","text":"abstract type AbstractIntegrator end\nstruct AdaptiveEulerTrapezoid <: AbstractIntegrator end\n\nIntegrator types.\n\n\n\n\n\n","category":"type"},{"location":"IntegrationType/#Data-Storage-1","page":"Integration Types","title":"Data Storage","text":"","category":"section"},{"location":"IntegrationType/#","page":"Integration Types","title":"Integration Types","text":"IntegrationParameters","category":"page"},{"location":"IntegrationType/#DDD.IntegrationParameters","page":"Integration Types","title":"DDD.IntegrationParameters","text":"struct IntegrationParameters{T1, T2, T3}\n    dt::T1      # Initial timestep.\n    tmin::T1    # Minimum timestep.\n    tmax::T1    # Maximum timestep.\n    method::T2  # Integration method.\n    abstol::T1  # Absolute tolerance.\n    reltol::T1  # Relative tolerance.\n    time::T1    # Starting simulation time.\n    step::T3    # Starting simulation step.\nend\n\nStorage of integration parameters.\n\n\n\n\n\n","category":"type"},{"location":"IntegrationType/#","page":"Integration Types","title":"Integration Types","text":"IntegrationTime","category":"page"},{"location":"IntegrationType/#DDD.IntegrationTime","page":"Integration Types","title":"DDD.IntegrationTime","text":"struct IntegrationTime{T1, T2}\n    dt::T1      # Current time step.\n    time::T1    # Current simulation time.\n    step::T2    # Current simulation step.\nend\n\nStore integration time and steps.\n\n\n\n\n\n","category":"type"},{"location":"MaterialType/#Types-1","page":"Material Types","title":"Types","text":"","category":"section"},{"location":"MaterialType/#Primitive-Types-1","page":"Material Types","title":"Primitive Types","text":"","category":"section"},{"location":"MaterialType/#","page":"Material Types","title":"Material Types","text":"AbstractCrystalStruct","category":"page"},{"location":"MaterialType/#DDD.AbstractCrystalStruct","page":"Material Types","title":"DDD.AbstractCrystalStruct","text":"abstract type AbstractCrystalStruct end\nstruct BCC <: AbstractCrystalStruct end\nstruct FCC <: AbstractCrystalStruct end\nstruct HCP <: AbstractCrystalStruct end\n\nCrystal structure types.\n\n\n\n\n\n","category":"type"},{"location":"MaterialType/#Storage-Types-1","page":"Material Types","title":"Storage Types","text":"","category":"section"},{"location":"MaterialType/#","page":"Material Types","title":"Material Types","text":"MaterialParameters","category":"page"},{"location":"MaterialType/#DDD.MaterialParameters","page":"Material Types","title":"DDD.MaterialParameters","text":"struct MaterialParameters{T1,T2}\n    μ::T1               # Shear modulus.\n    μMag::T1            # Magnitude of shear modulus.\n    ν::T1               # Poisson ratio.\n    E::T1               # Young's modulus.\n    omνInv::T1          # 1 / (1 - ν)\n    opνInv::T1          # 1 / (1 + ν)\n    νomνInv::T1         # ν / (1 - ν)\n    νopνInv::T1         # v / (1 + ν)\n    μ4π::T1             # μ / (4π)\n    μ8π::T1             # μ / (8π)\n    μ4πν::T1            # μ / (4π (1 - ν))\n    crystalStruct::T2   # Crystal structure.\n    σPN::T1             # Peierls-Nabarro stress.\nend\n\nStore material parameters.\n\n\n\n\n\n","category":"type"},{"location":"#DDD-1","page":"Home","title":"DDD","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"(Image: Dev) (Image: Build Status) (Image: Build Status) (Image: Codecov) (Image: Coveralls)","category":"page"}]
}
