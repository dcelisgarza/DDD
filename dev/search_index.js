var documenterSearchIndex = {"docs":
[{"location":"functions/#Functions-1","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"functions/#Dislocation-1","page":"Functions","title":"Dislocation","text":"","category":"section"},{"location":"functions/#Segment-Forces-1","page":"Functions","title":"Segment Forces","text":"","category":"section"},{"location":"functions/#","page":"Functions","title":"Functions","text":"calcSelfForce\n\ncalcSegSegForce\n\ncalcSegForce","category":"page"},{"location":"functions/#DDD.calcSelfForce","page":"Functions","title":"DDD.calcSelfForce","text":"calcSelfForce(\n    dlnParams::DislocationParameters,\n    matParams::MaterialParameters,\n    network::DislocationNetwork,\n)\n\nCalculates the self-interaction force felt by two nodes in a segment. Naturally the forces are equal and opposite to each other.\n\n\n\n\n\n","category":"function"},{"location":"functions/#DDD.calcSegSegForce","page":"Functions","title":"DDD.calcSegSegForce","text":"!!! Note     This function is based on the SegSegForces function by A. Arsenlis et al. It is optimised for speed and reusability. It has also been locally parallelised.\n\n\n\nIt implements the analytical solution of the force between two dislocation segments. Details are found in Appendix A.1. in \"Enabling Strain Hardening Simulations with Dislocation Dynamics\" by A. Arsenlis et al.\n\nAt a high level this works by creating a local coordinate frame using the line directions of the dislocation segments and a vector orthogonal to them. The line integrals are then evaluated parametrically utilising this local coordinate. BibTex citation here:\n\n@article{Arsenlis_2007, \tdoi = {10.1088/0965-0393/15/6/001}, \turl = {https://doi.org/10.1088%2F0965-0393%2F15%2F6%2F001}, \tyear = 2007, \tmonth = {jul}, \tpublisher = {{IOP} Publishing}, \tvolume = {15}, \tnumber = {6}, \tpages = {553–595}, \tauthor = {A Arsenlis and W Cai and M Tang and M Rhee and T Oppelstrup and G Hommes and T G Pierce and V V Bulatov}, \ttitle = {Enabling strain hardening simulations with dislocation dynamics}, \tjournal = {Modelling and Simulation in Materials Science and Engineering}, \tabstract = {Numerical algorithms for discrete dislocation dynamics simulations are investigated for the purpose of enabling strain hardening simulations of single crystals on massively parallel computers. The algorithms investigated include the calculation of forces, the equations of motion, time integration, adaptive mesh refinement, the treatment of dislocation core reactions and the dynamic distribution of data and work on parallel computers. A simulation integrating all these algorithmic elements using the Parallel Dislocation Simulator (ParaDiS) code is performed to understand their behaviour in concert and to evaluate the overall numerical performance of dislocation dynamics simulations and their ability to accumulate percent of plastic strain.} }\n\n\n\n\n\n","category":"function"},{"location":"functions/#DDD.calcSegForce","page":"Functions","title":"DDD.calcSegForce","text":"calcSegForce(\n    dlnParams::DislocationParameters,\n    matParams::MaterialParameters,\n    network::DislocationNetwork;\n    # mesh::RegularCuboidMesh,\n    # dlnFEM::DislocationFEMCorrective;\n    parallel::Bool = true,\n)\n\n\n\n\n\n","category":"function"},{"location":"functions/#Dislocation-Topology-1","page":"Functions","title":"Dislocation Topology","text":"","category":"section"},{"location":"functions/#","page":"Functions","title":"Functions","text":"removeNode!\n\nremoveConnection!\n\nremoveLink!\n\nremoveUpdate\n\nmergeNode","category":"page"},{"location":"functions/#FEM-1","page":"Functions","title":"FEM","text":"","category":"section"},{"location":"functions/#","page":"Functions","title":"Functions","text":"shapeFunction\n\nshapeFunctionDeriv","category":"page"},{"location":"functions/#DDD.shapeFunction","page":"Functions","title":"DDD.shapeFunction","text":"shapeFunction(shape<:AbstractShapeFunction, x, y, z)\n\nReturns the shape functions of type typeof(shape) <: AbstractShapeFunction. If x,y,z are floats returns a vector of length N, different shape functons have different numbers of nodes. If given vectors, returns an array of size (N, length(x)).\n\nnote: Note\nAll coordinate vectors must be of equal length.\n\nshapeFunctionDeriv are the 1st order derivatives of the shape functions.\n\n\n\n\n\n","category":"function"},{"location":"functions/#DDD.shapeFunctionDeriv","page":"Functions","title":"DDD.shapeFunctionDeriv","text":"shapeFunctionDeriv(shape<:AbstractShapeFunction, x, y, z)\n\nReturns the first order derivative of the shape functions, shapeFunction, of type typeof(shape) <: AbstractShapeFunction. If x,y,z are floats returns a 2D array of size (N, 3). If given vectors, returns a 3D array of size (N, 3, length(x)).\n\nnote: Note\nAll coordinate vectors must be of equal length.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Dislocation-FEM-Coupling-1","page":"Functions","title":"Dislocation FEM Coupling","text":"","category":"section"},{"location":"functions/#","page":"Functions","title":"Functions","text":"calcPKForce\n\ncalc_σ_hat","category":"page"},{"location":"functions/#Miscelaneous-1","page":"Functions","title":"Miscelaneous","text":"","category":"section"},{"location":"functions/#","page":"Functions","title":"Functions","text":"makeInstanceDict\n\ntranslateEnum\n\nsubTypeTree\n\nmakeTypeDict\n\ninclusiveComparison\n\ncompStruct\n\nintAngle\n\nexternalAngle\n\nrot3D","category":"page"},{"location":"functions/#DDD.makeInstanceDict","page":"Functions","title":"DDD.makeInstanceDict","text":"makeInstanceDict(valType::DataType)\n\nMake a dictionary of enumerated variable instances. Helps in translating JSON files.\n\n\n\n\n\n","category":"function"},{"location":"functions/#DDD.makeTypeDict","page":"Functions","title":"DDD.makeTypeDict","text":"makeTypeDict(valType::DataType)\n\nInputs contain strings that correspond to DDD data types. This function atuomatically creates a dictionary for all concrete subtypes of a given valType.\n\nExamples\n\njulia> abstract type MyAbstractType end\njulia> struct MyStruct1 <: MyAbstractType end\njulia> struct MyStruct2 <: MyAbstractType end\njulia> makeTypeDict(MyAbstractType)\nDict{String,Any} with 4 entries:\n  \"DDD.MyStruct1()\" => MyStruct1()\n  \"DDD.MyStruct2()\" => MyStruct2()\n  \"MyStruct1()\"     => MyStruct1()\n  \"MyStruct2()\"     => MyStruct2()\n\n\n\n\n\n","category":"function"},{"location":"functions/#DDD.inclusiveComparison","page":"Functions","title":"DDD.inclusiveComparison","text":"inclusiveComparison(data, args...)::Bool\n\nCompare data to a tuple, return true if it is equal to any arg, false if it is not equal to any.\n\nExamples\n\njulia> inclusiveComparison(\"f\", 1,4,5,\"f\")\ntrue\njulia> inclusiveComparison(23.246, 1.5, 4, 5, \"f\")\nfalse\n\n\n\n\n\n","category":"function"},{"location":"functions/#DDD.compStruct","page":"Functions","title":"DDD.compStruct","text":"compStruct(arg1, arg2; verbose::Bool = false)\n\nFunction that compares values of the fields of two variables arg1 and arg2 with the same structure. If verbose = true, it will print which fields are different from each other.\n\nExamples\n\njulia> struct MyStruct1; x; end\njulia> test1 = MyStruct1(1)\nMyStruct1(1)\njulia> test2 = MyStruct1(5)\nMyStruct1(5)\njulia> compStruct(test1, test2; verbose = true)\nStructures differ in field: x.\nfalse\njulia> compStruct(1, 1; verbose = true)\ntrue\njulia> compStruct(1, [1]; verbose = true)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"functions/#DDD.intAngle","page":"Functions","title":"DDD.intAngle","text":"intAngle(n::Int)\n\nCalculates the interior angle of a regular polygon with n sides.\n\n\n\n\n\n","category":"function"},{"location":"functions/#DDD.externalAngle","page":"Functions","title":"DDD.externalAngle","text":"externalAngle(n::Int)\n\nCalculates the exterior angle of a regular polygon with n sides.\n\n\n\n\n\n","category":"function"},{"location":"functions/#DDD.rot3D","page":"Functions","title":"DDD.rot3D","text":"rot3D(\n    xyz::AbstractVector{T1},\n    uvw::AbstractVector{T2},\n    abc::AbstractVector{T3},\n    θ::T4,\n) where {T1, T2, T3, T4}\n\nRotate point xyz about the line with direction vector uvw that crosses the point abc by the angle θ. Further details found here.\n\nExamples\n\njulia> rot3D([1;1;1],[1;0;0],[0;0;0],π/2)\n3-element Array{Float64,1}:\n  1.0\n -0.9999999999999999\n  1.0\njulia> rot3D([1;1;1],[1;0;0],[0;0;0],-π/2)\n3-element Array{Float64,1}:\n1.0\n1.0\n-0.9999999999999999\njulia> rot3D([1;1;1],[1;0;0],[0;0;0],π)\n3-element Array{Float64,1}:\n  1.0\n -1.0000000000000002\n -0.9999999999999999\n\n\n\n\n\n","category":"function"},{"location":"theory/#Discrete-Dislocation-Dynamics-1","page":"Discrete Dislocation Dynamics","title":"Discrete Dislocation Dynamics","text":"","category":"section"},{"location":"postProcessing/#Post-Processing-1","page":"Post Processing","title":"Post Processing","text":"","category":"section"},{"location":"postProcessing/#","page":"Post Processing","title":"Post Processing","text":"plotNodes\n\nplotNodes!","category":"page"},{"location":"postProcessing/#DDD.plotNodes","page":"Post Processing","title":"DDD.plotNodes","text":"plotNodes(obj::Union{DislocationLoop, DislocationNetwork}, args...; kw...)\n\nPlots dislocation network as nodes connected by segments. Returns a new figure. See plotNodes! for mutating version.\n\n\n\n\n\n","category":"function"},{"location":"postProcessing/#DDD.plotNodes!","page":"Post Processing","title":"DDD.plotNodes!","text":"plotNodes!(fig, obj::Union{DislocationLoop, DislocationNetwork}, args...; kw...)\n\nUpdates figure to plot dislocation network as nodes connected by segments. See plotNodes for non-mutating version.\n\n\n\n\n\n","category":"function"},{"location":"Dislocations/#Dislocation-Generation-1","page":"Dislocations","title":"Dislocation Generation","text":"","category":"section"},{"location":"Dislocations/#Types,-Structs-and-Constructors-1","page":"Dislocations","title":"Types, Structs and Constructors","text":"","category":"section"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"Dislocations are described, generated and validated by custom types, structures and functions. By subtyping the provided types with new concrete types, users can define functions which dispatch specifically on their new types while minimising the need for code rewrites, as multiple dispatch takes care of everything during JIT compilation. Structures have not had their default constructors overwritten, we provide custom constructors whose use is recommended instead.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"In discrete dislocation dynamics, dislocations are described by nodes connected by segments. The nodes are labelled according to their type, which is used by the software to decide how they are treated. However, labels are discrete variables, so they cannot take on any value. Additionally, accidentally using non-existent node types may produce silent and difficult to track errors. It is also impractical to validate node types at runtime. We solve these issues by defining a custom enumerated type, which not only limits possible values but informs users and developers of what the values represent.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"nodeType","category":"page"},{"location":"Dislocations/#DDD.nodeType","page":"Dislocations","title":"DDD.nodeType","text":"Since there is only a finite number of node types making the node type an enumerated type provides safety.\n\n@enum nodeType begin\n    none = 0    # Undefined node, value at initialisation.\n    intMob = 1  # Internal mobile node.\n    intFix = 2  # Internal fixed node.\n    srfMob = 3  # Mobile surface node.\n    srfFix = 4  # Fixed surface node.\n    ext = 5     # External node.\nend\n\n\n\n\n\n","category":"type"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"Of course, mislabelling a node with an erroneous but defined value may still occur. Preventing such bugs is the task of users and developers, however the problem may is eased by the self-descriptive nature of enumerated types.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"Dislocations also have different idealised segment types which are characterised by the relationship between the line direction and Burgers vector. These idealised types are used in the code for in loop generation. We've defined a few common types, most of which are not currently used but may prove useful in the future, for example in the statistical analysis of the dislocation network.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"AbstractDlnSeg","category":"page"},{"location":"Dislocations/#DDD.AbstractDlnSeg","page":"Dislocations","title":"DDD.AbstractDlnSeg","text":"Dislocation segment types.\n\nabstract type AbstractDlnSeg end\nstruct segNone <: AbstractDlnSeg end    # Undefined segment\nstruct segEdge <: AbstractDlnSeg end    # Edge segment\nstruct segEdgeN <: AbstractDlnSeg end   # Edge segment\nstruct segScrew <: AbstractDlnSeg end   # Screw segment\nstruct segMixed <: AbstractDlnSeg end   # Mixed segment\n\nwhere segEdge have (bmb perp bmt) perp bmn, segEdgeN have (bmb perp bmt) parallel bmn, segScrew have bmb parallel bmt, segMixed have bmb notperp bmt  bmb notperp bmn and bmb is the Burgers vector and bmn the slip plane.\n\n\n\n\n\n","category":"type"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"Dislocation loops are idealised as having different classifications. Prismatic loops are made up only of edge segments generally with the same slip system; shear loops are made up of a mixture of segment types with the same slip system; jogs and kinks are steps not contained in the slip plane. These idealisations can be used to automate loop generation with minimal rewriting via multiple dispatch. We provide the following types for such a purpose.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"AbstractDlnStr","category":"page"},{"location":"Dislocations/#DDD.AbstractDlnStr","page":"Dislocations","title":"DDD.AbstractDlnStr","text":"Dislocation loop types.\n\nabstract type AbstractDlnStr end\nstruct loopDln <: AbstractDlnStr end    # Unclassified loop\nstruct loopPrism <: AbstractDlnStr end  # Prismatic loop\nstruct loopShear <: AbstractDlnStr end  # Shear loop\nstruct loopJog <: AbstractDlnStr end    # Jog\nstruct loopKink <: AbstractDlnStr end   # Kink\n\n\n\n\n\n","category":"type"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"Generating dislocation networks often involves distributing the initial loops within the simulation domain in a particular way. We again define custom structures that enable us to make use of multiple dispatch.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"AbstractDistribution","category":"page"},{"location":"Dislocations/#DDD.AbstractDistribution","page":"Dislocations","title":"DDD.AbstractDistribution","text":"Initial statistical distributions of dislocations in the domain.\n\nabstract type AbstractDistribution end\nstruct Zeros <: AbstractDistribution end\nstruct Rand <: AbstractDistribution end\nstruct Randn <: AbstractDistribution end\nstruct Regular <: AbstractDistribution end\n\nDistributions for dislocation sources.\n\n\n\n\n\n","category":"type"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"Mobility functions describe how dislocations move within a material. There are many variations of such functions and users may want/need to use different functions for different purposes. Creating concrete mobility types lets users define a function for their new concrete mobility type and carry on with their lives.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"AbstractMobility","category":"page"},{"location":"Dislocations/#DDD.AbstractMobility","page":"Dislocations","title":"DDD.AbstractMobility","text":"Dislocation mobility types.\n\nabstract type AbstractMobility end\nstruct mobBCC <: AbstractMobility end\nstruct mobFCC <: AbstractMobility end\nstruct mobHCP <: AbstractMobility end\n\nMobility functions.\n\n\n\n\n\n","category":"type"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"As previously mentioned, idealised dislocation segments live on slip systems, which are pairings of slip plane and Burgers vector. These can be stored in the following structure.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"SlipSystem","category":"page"},{"location":"Dislocations/#DDD.SlipSystem","page":"Dislocations","title":"DDD.SlipSystem","text":"Slip systems.\n\nstruct SlipSystem{T1, T2}\n    crystalStruct::T1   # Crystal structure\n    slipPlane::T2       # Slip plane\n    bVec::T2            # Burgers vector\nend\n\nStructure to store slip systems.\n\n\n\n\n\n","category":"type"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"As slip systems are defined with respect to pure edge dislocations, we recommended users use the keyword constructor as it validates the orthogonality of paired Burgers vector and slip plane.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"SlipSystem(;\n    crystalStruct::T1,\n    slipPlane::T2,\n    bVec::T2,\n) where {T1 <: AbstractCrystalStruct, T2 <: AbstractArray{T, N} where {T, N}}","category":"page"},{"location":"Dislocations/#DDD.SlipSystem-Union{Tuple{}, Tuple{T2}, Tuple{T1}} where T2<:(AbstractArray{T,N} where N where T) where T1<:AbstractCrystalStruct","page":"Dislocations","title":"DDD.SlipSystem","text":"SlipSystem(crystalStruct::T1, slipPlane::T2, bVec::T2) where {T1 <: AbstractCrystalStruct, T2 <: AbstractArray{T, N} where {T, N}}\n\nKeyword constructor for SlipSystem. Throws error if bmb notperp bmn where bmb is the Burgers vector and bmn the slip plane.\n\n\n\n\n\n","category":"method"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"The simulation requires certain parameters pertaining to the dislocation network being modelled. These values control certain aspects of the simulation and are stored in the following structure.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"DislocationParameters","category":"page"},{"location":"Dislocations/#DDD.DislocationParameters","page":"Dislocations","title":"DDD.DislocationParameters","text":"Dislocation loop parameters.\n\nstruct DislocationParameters{T1, T2, T3, T4}\n    coreRad::T1         # Core radius\n    coreRadSq::T1       # Square of core radius\n    coreRadMag::T1      # Magnitude of core radius\n    minSegLen::T1       # Minimum segment length\n    maxSegLen::T1       # Maximum segment length\n    twoMinSegLen::T1    # Twice minimum segment length\n    minArea::T1         # Minimum area enclosed by 3 segments\n    maxArea::T1         # Maximum area enclosed by 3 segments\n    minAreaSq::T1       # Squared min area\n    maxAreaSq::T1       # Squared max area\n    edgeDrag::T1        # Drag coefficient edge dislocation\n    screwDrag::T1       # Drag coefficient screw dislocation\n    climbDrag::T1       # Drag coefficient climb direction\n    lineDrag::T1        # Drag coefficient line direction\n    maxConnect::T2      # Maximum connectivity\n    remesh::T3          # Remesh flag\n    collision::T3       # Collision flag\n    separation::T3      # Separation flag\n    virtualRemesh::T3   # Virtual remeshing flag\n    parCPU::T3          # Parallelise on CPU\n    parGPU::T3          # Parallelise on GPU\n    mobility::T4        # Mobility law\nend\n\n\n\n\n\n","category":"type"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"We recommend the use of the keyword constructor as it performs sanity checks on various parameters, ensuring a hierarchy of values is maintained.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"DislocationParameters(;\n    coreRad::T1,\n    coreRadMag::T1,\n    minSegLen::T1,\n    maxSegLen::T1,\n    minArea::T1,\n    maxArea::T1,\n    maxConnect::T2,\n    remesh::T3,\n    collision::T3,\n    separation::T3,\n    virtualRemesh::T3,\n    edgeDrag::T1,\n    screwDrag::T1,\n    climbDrag::T1,\n    lineDrag::T1,\n    mobility::T4,\n) where {T1, T2 <: Int, T3 <: Bool, T4 <: AbstractMobility}","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"Dislocation loops form the basis of a network, we provide a structure to store these loops, whether idealised or otherwise.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"DislocationLoop","category":"page"},{"location":"Dislocations/#DDD.DislocationLoop","page":"Dislocations","title":"DDD.DislocationLoop","text":"Dislocation loop.\n\nstruct DislocationLoop{T1, T2, T3, T4, T5, T6, T7, T8, T9}\n    loopType::T1    # Loop type\n    numSides::T2    # Number of sides per loop\n    nodeSide::T2    # Number of nodes per side\n    numLoops::T2    # Number of loops to generate\n    segLen::T3      # Segment lengths\n    slipSystem::T4  # Slip system\n    links::T5       # Links matrix\n    slipPlane::T6   # Slip plane for each link\n    bVec::T6        # Burgers vector for each link\n    coord::T6       # Coordinates of each node\n    label::T7       # Label of each node\n    buffer::T8      # Mean distance buffer separating each loop centre\n    range::T6       # Distribution range of generated loops\n    dist::T9        # Distribution of generated loops\nend\n\n\n\n\n\n","category":"type"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"Again we recommend the use of the key-word only constructor as it provides an interface to call specific constructors which dispatch on loopType and generate the loop automatically. The default constructor should only be used for truly custom loops, however creating a concrete subtype of AbstractDlnStr and a constructor which dispatches on this new type is highly recommended since it facilitates testing, reproducibility and seamlessly integrates with existing infrastructure.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"DislocationLoop(;\n    loopType::T1,\n    numSides::T2,\n    nodeSide::T2,\n    numLoops::T2,\n    segLen::T3,\n    slipSystem::T2,\n    _slipPlane::T4,\n    _bVec::T4,\n    label::T5,\n    buffer::T6,\n    range::T7,\n    dist::T8,\n) where {\n    T1 <: AbstractDlnStr,\n    T2 <: Int,\n    T3 <: Union{T where {T}, AbstractArray{T, N} where {T, N}},\n    T4 <: AbstractArray{T, N} where {T, N},\n    T5 <: AbstractVector{nodeType},\n    T6,\n    T7 <: AbstractArray{T, N} where {T, N},\n    T8 <: AbstractDistribution,\n}","category":"page"},{"location":"Dislocations/#DDD.DislocationLoop-Union{Tuple{}, Tuple{T8}, Tuple{T7}, Tuple{T6}, Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}} where T8<:AbstractDistribution where T7<:(AbstractArray{T,N} where N where T) where T6 where T5<:AbstractArray{nodeType,1} where T4<:(AbstractArray{T,N} where N where T) where T3 where T2<:Int64 where T1<:AbstractDlnStr","page":"Dislocations","title":"DDD.DislocationLoop","text":"DislocationLoop(;\n    loopType::T1,\n    numSides::T2,\n    nodeSide::T2,\n    numLoops::T2,\n    segLen::T3,\n    slipSystem::T2,\n    _slipPlane::T4,\n    _bVec::T4,\n    label::T5,\n    buffer::T6,\n    range::T7,\n    dist::T8,\n) where {\n    T1 <: AbstractDlnStr,\n    T2 <: Int,\n    T3 <: Union{T where {T}, AbstractArray{T, N} where {T, N}},\n    T4 <: AbstractArray{T, N} where {T, N},\n    T5 <: AbstractVector{nodeType},\n    T6,\n    T7 <: AbstractArray{T, N} where {T, N},\n    T8 <: AbstractDistribution,\n}\n\nGeneric keyword constructor for DislocationLoop. Calls other constructors that dispatch on loopType.\n\n\n\n\n\n","category":"method"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"The first concrete DislocationLoop constructor is the \"zero\" constructor. The way Julia's multiple dispatch works is by dispatching on the most specific method for the inputs provided. Therefore this constructor will be called whenever the loop type is loopDln().","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"DislocationLoop(\n    loopType::T1;\n    numSides::T2,\n    nodeSide::T2,\n    numLoops::T2,\n    segLen::T3,\n    slipSystem::T2,\n    _slipPlane::T4,\n    _bVec::T4,\n    label::T5,\n    buffer::T6,\n    range::T7,\n    dist::T8,\n) where {\n    T1 <: loopDln,\n    T2 <: Int,\n    T3 <: Union{T where {T}, AbstractArray{T, N} where {T, N}},\n    T4 <: AbstractArray{T, N} where {T, N},\n    T5 <: AbstractVector{nodeType},\n    T6,\n    T7 <: AbstractArray{T, N} where {T, N},\n    T8 <: AbstractDistribution,\n}","category":"page"},{"location":"Dislocations/#DDD.DislocationLoop-Union{Tuple{T1}, Tuple{T8}, Tuple{T7}, Tuple{T6}, Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}} where T8<:AbstractDistribution where T7<:(AbstractArray{T,N} where N where T) where T6 where T5<:AbstractArray{nodeType,1} where T4<:(AbstractArray{T,N} where N where T) where T3 where T2<:Int64 where T1<:loopDln","page":"Dislocations","title":"DDD.DislocationLoop","text":"DislocationLoop(;\n    loopType::T1,\n    numSides::T2,\n    nodeSide::T2,\n    numLoops::T2,\n    segLen::T3,\n    slipSystem::T2,\n    _slipPlane::T4,\n    _bVec::T4,\n    label::T5,\n    buffer::T6,\n    range::T7,\n    dist::T8,\n) where {\n    T1 <: AbstractDlnStr,\n    T2 <: Int,\n    T3 <: Union{T where {T}, AbstractArray{T, N} where {T, N}},\n    T4 <: AbstractArray{T, N} where {T, N},\n    T5 <: AbstractVector{nodeType},\n    T6,\n    T7 <: AbstractArray{T, N} where {T, N},\n    T8 <: AbstractDistribution,\n}\n\nGeneric keyword constructor for DislocationLoop. Calls other constructors that dispatch on loopType.\n\n\n\n\n\n","category":"method"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"We also provide a catch-all constructor that generates shear or prismatic loops depending on whether loopType is loopShear() or loopPrism(). It acts as a fallback for other loop types but generates prismatic loops. Such behaviour can be overridden by defining new methods which dispatch on more a specific loopType.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"DislocationLoop(\n    loopType::T1;\n    numSides::T2,\n    nodeSide::T2,\n    numLoops::T2,\n    segLen::T3,\n    slipSystem::T2,\n    _slipPlane::T4,\n    _bVec::T4,\n    label::T5,\n    buffer::T6,\n    range::T7,\n    dist::T8,\n) where {\n    T1 <: AbstractDlnStr,\n    T2 <: Int,\n    T3 <: Union{T where {T}, AbstractArray{T, N} where {T, N}},\n    T4 <: AbstractArray{T, N} where {T, N},\n    T5 <: AbstractVector{nodeType},\n    T6,\n    T7 <: AbstractArray{T, N} where {T, N},\n    T8 <: AbstractDistribution,\n}","category":"page"},{"location":"Dislocations/#DDD.DislocationLoop-Union{Tuple{T1}, Tuple{T8}, Tuple{T7}, Tuple{T6}, Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}} where T8<:AbstractDistribution where T7<:(AbstractArray{T,N} where N where T) where T6 where T5<:AbstractArray{nodeType,1} where T4<:(AbstractArray{T,N} where N where T) where T3 where T2<:Int64 where T1<:AbstractDlnStr","page":"Dislocations","title":"DDD.DislocationLoop","text":"DislocationLoop(;\n    loopType::T1,\n    numSides::T2,\n    nodeSide::T2,\n    numLoops::T2,\n    segLen::T3,\n    slipSystem::T2,\n    _slipPlane::T4,\n    _bVec::T4,\n    label::T5,\n    buffer::T6,\n    range::T7,\n    dist::T8,\n) where {\n    T1 <: AbstractDlnStr,\n    T2 <: Int,\n    T3 <: Union{T where {T}, AbstractArray{T, N} where {T, N}},\n    T4 <: AbstractArray{T, N} where {T, N},\n    T5 <: AbstractVector{nodeType},\n    T6,\n    T7 <: AbstractArray{T, N} where {T, N},\n    T8 <: AbstractDistribution,\n}\n\nGeneric keyword constructor for DislocationLoop. Calls other constructors that dispatch on loopType.\n\n\n\n\n\n","category":"method"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"The dist parameter refers to a concrete subtype of AbstractDistribution. When defining a new distribution it is important to define a new version of the loopDistribution function.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"loopDistribution","category":"page"},{"location":"Dislocations/#DDD.loopDistribution","page":"Dislocations","title":"DDD.loopDistribution","text":"loopDistribution(dist<:AbstractDistribution, n::Int, args...; kw...)\nloopDistribution(dist::Zeros, n::Int, args...; kw...) = zeros(3, n)\nloopDistribution(dist::Rand, n::Int, args...; kw...) = rand(3, n)\nloopDistribution(dist::Randn, n::Int, args...; kw...) = randn(3, n)\nloopDistribution(dist::Regular, n::Int, args...; kw...) = error(\"loopDistribution: regular distribution yet not implemented\")\n\nReturns a 3 × n matrix whose points follow the distribution defined by the method dispatching on the concrete subtype of dist. When creating custom AbstractDistribution subtypes, a corresponding loopDistribution method must be created for the custom distribution to be used in the DislocationLoop constructors.\n\n\n\n\n\n","category":"function"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"The dislocation loops contain all the data relevant to a single loop. This data is then used to populate a dislocation network, which is a mutable structure because it evolves over time.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"DislocationNetwork","category":"page"},{"location":"Dislocations/#DDD.DislocationNetwork","page":"Dislocations","title":"DDD.DislocationNetwork","text":"Dislocation network.\n\nstruct DislocationNetwork{T1, T2, T3, T4, T5, T6}\n    links::T1\n    slipPlane::T2\n    bVec::T2\n    coord::T2\n    label::T3\n    nodeVel::T2\n    nodeForce::T2\n    numNodeSegConnect::T4   # Number of nodes, segments and max connectivity in network\n    connectivity::T5        # Connectivity matrix\n    linksConnect::T5        # Links involved in connection\n    segIdx::T5              # Contains segment index and the nodes of the nodes in said link\n    segForce::T6            # Force on each node of each segment\nend\n\n\n\n\n\n","category":"type"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"Again we provide a keyword constructor which performs some sanity checks and loads the data into the structure. This is the constructor to use when loading data from a previously generated network.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"DislocationNetwork(;\n    links::T1,\n    slipPlane::T2,\n    bVec::T2,\n    coord::T2,\n    label::T3,\n    nodeVel::T2,\n    numNode::T4 = 0,\n    numSeg::T4 = 0,\n    maxConnect::T4 = 0,\n    connectivity::T5 = zeros(Int, 0, 0),\n    linksConnect::T5 = zeros(Int, 2, 0),\n    segIdx::T5 = zeros(Int, 2, 3),\n    segForce::T6 = zeros(3, 2, 0),\n) where {\n    T1 <: AbstractArray{T, N} where {T, N},\n    T2 <: AbstractArray{T, N} where {T, N},\n    T3 <: AbstractVector{nodeType},\n    T4 <: Int,\n    T5 <: AbstractArray{Int, N} where {N},\n    T6 <: AbstractArray{T, N} where {T, N},\n}","category":"page"},{"location":"Dislocations/#DDD.DislocationNetwork-Union{Tuple{}, Tuple{T6}, Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}} where T6<:(AbstractArray{T,N} where N where T) where T5<:(AbstractArray{Int64,N} where N) where T4<:Int64 where T3<:AbstractArray{nodeType,1} where T2<:(AbstractArray{T,N} where N where T) where T1<:(AbstractArray{T,N} where N where T)","page":"Dislocations","title":"DDD.DislocationNetwork","text":"DislocationNetwork(;\n    links::T1,\n    slipPlane::T2,\n    bVec::T2,\n    coord::T2,\n    label::T3,\n    nodeVel::T2,\n    nodeForce::T2,\n    numNodeSegConnect::T4 = [0, 0, 0],\n    connectivity::T5 = zeros(Int, 0, 0),\n    linksConnect::T5 = zeros(Int, 2, 0),\n    segIdx::T5 = zeros(Int, 2, 3),\n    segForce::T6 = zeros(3, 2, 0),\n) where {\n    T1 <: AbstractArray{T, N} where {T, N},\n    T2 <: AbstractArray{T, N} where {T, N},\n    T3 <: AbstractVector{nodeType},\n    T4 <: Int,\n    T5 <: AbstractArray{Int, N} where {N},\n    T6 <: AbstractArray{T, N} where {T, N},\n}\n\nKeyword constructor for DislocationNetwork, performs validations but creates dislocation network as provided.\n\n\n\n\n\n","category":"method"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"However, if the aim is to generate a new network then use the following constructor.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"DislocationNetwork(\n    sources::T1,\n    maxConnect::T2 = 4,\n    args...;\n    memBuffer = nothing,\n    checkConsistency::T3 = true,\n    kw...,\n) where {\n    T1 <: Union{T, AbstractVector{T}} where {T <: DislocationLoop},\n    T2 <: Int,\n    T3 <: Bool,\n}","category":"page"},{"location":"Dislocations/#DDD.DislocationNetwork-Union{Tuple{T1}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T2,Vararg{Any,N} where N}} where T3<:Bool where T2<:Int64 where T1<:(Union{AbstractArray{T,1}, T} where T<:DislocationLoop)","page":"Dislocations","title":"DDD.DislocationNetwork","text":"DislocationNetwork(\n    sources::T1,\n    maxConnect::T2 = 4,\n    args...;                        # Optional arguments\n    memBuffer = nothing,            # Buffer for memory allocation\n    checkConsistency::T3 = true,    # Check consistency of generated network\n    kw...,                          # Other keyword arguments\n) where {\n    T1 <: Union{T, AbstractVector{T}} where {T <: DislocationLoop},\n    T2 <: Int,\n    T3 <: Bool,\n}\n\nOut of place constructor for DislocationNetwork. Generates a new dislocation network from previously generated sources.\n\nArgument Explanation\n\nargs... are optional arguments that will be passed on to the loopDistribution function which distributes the loops in sources according to the type of their dist variable.\nkw... are optional keyword arguments that will also be passed to loopDistribution.\nmemBuffer is the numerical value for allocating memory in advance, the quantity textrmmemBuffer times N where N is the total number of nodes in sources, will be the initial number of entries allocated in the matrices that keep the network's data, if it is nothing then the number of entries is textrmround(N log_2(N)).\n\n\n\n\n\n","category":"method"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"If adding to an existing network, use the mutating (also called in-place) constructor.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"DislocationNetwork!(\n    network::T1,\n    sources::T2,\n    maxConnect::T3 = 4,\n    args...;\n    checkConsistency::T4 = true,\n    kw...,\n) where {\n    T1 <: DislocationNetwork,\n    T2 <: Union{T, AbstractVector{T}} where {T <: DislocationLoop},\n    T3 <: Int,\n    T4 <: Bool,\n}","category":"page"},{"location":"Dislocations/#DDD.DislocationNetwork!-Union{Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T2}, Tuple{T1,T2,T3,Vararg{Any,N} where N}} where T4<:Bool where T3<:Int64 where T2<:(Union{AbstractArray{T,1}, T} where T<:DislocationLoop) where T1<:DislocationNetwork","page":"Dislocations","title":"DDD.DislocationNetwork!","text":"function DislocationNetwork!(\n    network::T1,\n    sources::T2,\n    maxConnect::T3 = 4,\n    args...;\n    checkConsistency::T3 = true,\n    kw...,\n) where {\n    T1 <: DislocationNetwork,\n    T2 <: Union{T, AbstractVector{T}} where {T <: DislocationLoop},\n    T3 <: Int,\n    T4 <: Bool,\n}\n\nIn-place constructor for DislocationNetwork. Generates a new dislocation network from already generated sources. If the matrices already in network are not large enough to accommodate the additions from sources, it will automatically allocate textrmround(N log_2(N)) new entries where N is the total number of nodes in sources.\n\n\n\n\n\n","category":"method"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"Dislocation network constructors use a few internal functions to distribute loops about the domain as well as create auxiliary matrices and verify the integrity of the generated network. As previously mentioned, loopDistribution is used to generate points from a particular distribution. These points must be scaled and adjusted by limits generated the limits function.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"limits!(\n    lims::T1,\n    segLen::T2,\n    range::T1,\n    buffer::T2,\n) where {T1 <: AbstractArray{T, N} where {T, N}, T2}","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"The limits, together with the aforementioned distributions are used to translate coordinates with the translatePoints! function.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"translatePoints!(\n    coord::T1,\n    lims::T1,\n    disp::T2,\n) where {T1 <: AbstractArray{T, N} where {T, N}, T2 <: AbstractVector{T} where {T}}","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"In order to traverse the network, it is useful to define a few auxiliary matrices containing relational information about nodes and links. These are created by the makeConnect functions.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"makeConnect(\n    links::T1,\n    maxConnect::T2,\n) where {T1 <: AbstractArray{T, N} where {T, N}, T2 <: Int}\n\nmakeConnect!(network::DislocationNetwork)","category":"page"},{"location":"Dislocations/#DDD.makeConnect!-Tuple{DislocationNetwork}","page":"Dislocations","title":"DDD.makeConnect!","text":"makeConnect!(network::DislocationNetwork)\n\nIn-place version of makeConnect.\n\n\n\n\n\n","category":"method"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"It's also useful to define another matrix for indexing segments quickly, this matrix is defined by the getSegmentIdx functions.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"getSegmentIdx(\n    links::T1,\n    label::T2,\n) where {T1 <: AbstractArray{T, N} where {T, N}, T2 <: AbstractVector{nodeType}}\n\ngetSegmentIdx!(network::DislocationNetwork)","category":"page"},{"location":"Dislocations/#DDD.getSegmentIdx!-Tuple{DislocationNetwork}","page":"Dislocations","title":"DDD.getSegmentIdx!","text":"getSegmentIdx!(network::DislocationNetwork)\n\nIn-place version of getSegmentIdx.\n\n\n\n\n\n","category":"method"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"The validity of the network can be checked by checkNetwork.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"checkNetwork(network::DislocationNetwork)","category":"page"},{"location":"Dislocations/#DDD.checkNetwork-Tuple{DislocationNetwork}","page":"Dislocations","title":"DDD.checkNetwork","text":"checkNetwork(network::DislocationNetwork)\n\nChecks the validity of the dislocation network. It ensures the following conditions are met by the member variables of network:\n\nconnectivity and links have the same number of non-zero entries;\nall entries in bVec are non-zero;\nonly the trailing columns of connectivity are zeros;\nconsistency between connectivity and links;\nbVec is conserved among connected nodes;\nentries in links are unique;\nconsistency betwen connectivity and linksConnect\n\n\n\n\n\n","category":"method"},{"location":"idx/#Index-1","page":"Index","title":"Index","text":"","category":"section"},{"location":"idx/#","page":"Index","title":"Index","text":"","category":"page"},{"location":"#DDD-1","page":"Home","title":"DDD","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"<!– (Image: Stable) –> (Image: Dev) (Image: Build Status) (Image: Build Status) (Image: Codecov) (Image: Coveralls)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"New generation of 3D Discrete Dislocation Dynamics codes.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Dislocation dynamics is a complex field with an enormous barrier to entry. The aim of this project is to create a codebase that is:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Easy to use.\nEasy to maintain.\nEasy to develop for.\nModular.\nIdiot proof.\nWell documented and tested.\nPerformant.\nEasily parallelisable.","category":"page"},{"location":"#Example-1","page":"Home","title":"Example","text":"","category":"section"},{"location":"#Initialisation-1","page":"Home","title":"Initialisation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Before running a simulation we need to initialise the simulation. For this example, we will use the keyword initialisers because they automatically calculate derived quantities, perform input validations, provide default values, and are make for self-documenting code.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Dislocations live in a material, as such we need a few constants that describe it. These are encapsulated in the immutable <sup>1</sup> structure MaterialParameters. Note that we use unicode to denote variables as per convention, \\mu -> μ and \\nu -> ν. Here we create a basic material.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> MaterialParameters = MaterialParameters(;\n          μ = 1.0,                  # Shear modulus.\n          μMag = 145e3,             # Shear modulus magnitude.\n          ν = 0.28,                 # Poisson ratio.\n          E = 1.0,                  # Young's modulus, MPa.\n          crystalStruct = BCC(),    # Crystal structure.\n          σPN = 0.0                 # Peierls-Nabarro stress for the material.\n        )\nMaterialParameters{Float64,BCC}(1.0, 145000.0, 0.28, 1.0, 1.3888888888888888, 0.3888888888888889, 0.07957747154594767, 0.039788735772973836, 0.11052426603603843, BCC(), 0.0)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Note that a few extra constants have been automatically calculated by the constructor. We find these using fieldnames().","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> fieldnames(typeof(MaterialParameters))\n(:μ, :μMag, :ν, :E, :σPN, :omνInv, :νomνInv, :μ4π, :μ8π, :μ4πν, :crystalStruct)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Where omνInv = 1/(1-ν), νomνInv = v/(1-ν), μ4π = μ/(4π), μ8π = μ/(8π), μ4πν = μ/[4π(1-ν)]. This avoids recomputing them later.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Our dislocations also have certain constant parameters and flags that are encapsulated in their own immutable structure, DislocationParameters. The numeric parameters are somewhat arbitrary as long as they hold certain proportions.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> DislocationParameters = DislocationParameters(;\n          coreRad = 90.0,       # Dislocation core radius, referred to as a.\n          coreRadMag = 3.2e-4,  # Magnitude of the core radius.\n          minSegLen = 320.0,    # Minimum segment length.\n          maxSegLen = 1600.0,   # Maximum segment length.\n          minArea = 45000.0,    # Minimum allowable area enclosed by two segments.\n          maxArea = 20*45000.0, # Maximum allowable area enclosed by two segments.\n          maxConnect = 4,       # Maximum number of connections a node can have.\n          remesh = true,        # Flag for remeshing.\n          collision = true,     # Flag for collision checking.\n          separation = true,    # Flag for node separation.\n          virtualRemesh = true, # Flag for remeshing virtual nodes.\n          parCPU = false,       # Parallelise on CPU\n          parGPU = false,       # Parallelise on GPU\n          edgeDrag = 1.0,       # Drag coefficient for edge segments.\n          screwDrag = 2.0,      # Drag coefficient for screw segments.\n          climbDrag = 1e10,     # Drag coefficient along the climb direction.\n          lineDrag = 0.0,       # Drag coefficient along the line direction.\n          mobility = mobBCC(),  # Mobility type for mobility function specialisation.\n        )\nDislocationParameters{Float64,Int64,Bool,mobBCC}(90.0, 8100.0, 0.00032, 320.0, 1600.0, 45000.0, 900000.0, 4, true, true, true, true, true, true, 1.0, 2.0, 1.0e10, 0.0, mobBCC())","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The integration parameters are placed into the following immutable structure.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> IntegrationParameters(;\n      method = CustomTrapezoid(),\n      tmin = 0.0,\n      tmax = 1e10,\n      dtmin = 1e-6,\n      dtmax = 1e15,\n      abstol = 1e-6,\n      reltol = 1e-6,\n      maxchange = 1.2,\n      exponent = 20.0,\n      maxiter = 10,\n  )\n\nIntegrationParameters{CustomTrapezoid,Float64,Int64}(CustomTrapezoid(), 0.0, 1.0e10, 1.0e-6, 1.0e15, 1.0e-6, 1.0e-6, 1.2, 20.0, 10)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"And we keep track of the time, step, and time step in this mutable one.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> IntegrationTime(;\n      dt = 100,\n      time = 0.0,\n      step = 0,\n)\nIntegrationTime{Float64,Int64}(100.0, 0.0, 0)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Within a given material, we have multiple slip systems, which can be loaded into their own immutable structure. Here we only define a single slip system, but we have the capability of adding n slip systems by making the slipPlane and bVec arguments m × n matrices rather than m vectors.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> slipSystems = SlipSystem(;\n          crystalStruct = BCC(),\n          slipPlane = [1.0; 1.0; 1.0],  # Slip plane.\n          bVec = [1.0; -1.0; 0.0]       # Burgers vector.\n       )\nSlipSystem{BCC,Array{Float64,1}}(BCC(), [1.0, 1.0, 1.0], [1.0, -1.0, 0.0])","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We also need dislocation sources. We make use of Julia's type system to create standard functions for loop generation. We provide a way to easily and quickly generate loops whose segments inhabit the same slip system. However, new DislocationLoop() methods can be made by subtyping AbstractDlnStr, and dispatching on the new type. One may of also course also use the default constructor and build the initial structures manually.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Here we make a regular pentagonal prismatic dislocation loop, and a regular hexagonal prismatic dislocation loop. The segments may be of arbitrary length, but having asymmetric sides may result in very ugly, irregular dislocations that may be unphysical or may end up remeshing as soon as the simulation gets under way. As such, we recommend making the segment lengths symmetric.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> prisPentagon = DislocationLoop(\n          loopPrism();    # Prismatic loop, all segments are edge segments.\n          numSides = 5,   # 5-sided loop.\n          nodeSide = 1,   # One node per side, if 1 nodes will be in the corners.\n          numLoops = 20,  # Number of loops of this type to generate when making a network.\n          segLen = 10 * ones(5),  # Length of each segment between nodes, equal to the number of nodes.\n          slipSystem = 1, # Slip System (assuming slip systems are stored in a file, this is the index).\n          _slipPlane = slipSystems.slipPlane,  # Slip plane of the segments.\n          _bVec = slipSystems.bVec,            # Burgers vector of the segments.\n          label = nodeType[1; 2; 1; 2; 1],    # Node labels, has to be equal to the number of nodes.\n          buffer = 0.0,   # Buffer to increase the dislocation spread.\n          range = Float64[          # Distribution range\n                        -100 100; # xmin, xmax          \n                        -100 100; # ymin, ymax\n                        -100 100  # zmin, zmax\n                      ],\n          dist = Rand(),  # Loop distribution.\n      )\nDislocationLoop{loopPrism,Int64,Array{Float64,1},Int64,Array{Int64,2},Array{Float64,2},Array{nodeType,1},Float64,Rand}(loopPrism(), 5, 1, 20, [10.0, 10.0, 10.0, 10.0, 10.0], 1, [1 2 … 4 5; 2 3 … 5 1], [0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258; 0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258; 0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258], [0.7071067811865475 0.7071067811865475 … 0.7071067811865475 0.7071067811865475; -0.7071067811865475 -0.7071067811865475 … -0.7071067811865475 -0.7071067811865475; 0.0 0.0 … 0.0 0.0], [-1.932030909139515 4.820453044614565 … -1.785143053581134 -6.014513813778146; -1.932030909139515 4.820453044614565 … -1.785143053581134 -6.014513813778146; -8.055755266097462 -5.087941102678986 … 8.123251093712414 0.10921054317980072], nodeType[DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob], 0.0, [-100.0 100.0; -100.0 100.0; -100.0 100.0], Rand())\n\njulia> shearHexagon = DislocationLoop(\n          loopShear();    # Shear loop\n          numSides = 6,\n          nodeSide = 3,   # 3 nodes per side, it devides the side into equal segments.\n          numLoops = 20,\n          segLen = 10 * ones(3 * 6) / 3,  # The hexagon's side length is 10, each segment is 10/3.\n          slipSystem = 1,\n          _slipPlane = slipSystems.slipPlane,\n          _bVec = slipSystems.bVec,\n          label = nodeType[1; 2; 1; 2; 1; 2; 1; 2; 1; 2; 1; 2; 1; 2; 1; 2; 1; 2],\n          buffer = 0.0,\n          range = Float64[\n                        -100 100;\n                        -100 100;\n                        -100 100\n                      ],\n          dist = Rand(),\n      )\nDislocationLoop{loopShear,Int64,Array{Float64,1},Int64,Array{Int64,2},Array{Float64,2},Array{nodeType,1},Float64,Rand}(loopShear(), 6, 3, 20, [3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335], 1, [1 2 … 17 18; 2 3 … 18 1], [0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258; 0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258; 0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258], [0.7071067811865475 0.7071067811865475 … 0.7071067811865475 0.7071067811865475; -0.7071067811865475 -0.7071067811865475 … -0.7071067811865475 -0.7071067811865475; 0.0 0.0 … 0.0 0.0], [5.443310539518175 6.8041381743977185 … 1.3608276348795458 4.082482904638633; -6.804138174397717 -5.443310539518174 … -6.804138174397715 -8.164965809277255; 1.3608276348795436 -1.3608276348795432\n… 5.443310539518167 4.082482904638622], nodeType[DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix], 0.0, [-100.0 100.0; -100.0 100.0; -100.0 100.0], Rand())","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The dislocation loops will be centred about the origin, but the range, buffer and dist parameters will distribute them about the simulation domain when the network is generated. The type of dist must be a concrete subtype of AbstractDistribution and a corresponding loopDistribution() method should be defined. If a non-suported distribution is required, you only need to create a concrete subtype of AbstractDistribution and a new method of loopDistribution() to dispatch on the new type. This is all the reworking needed, since multiple dispatch will take care of any new distributions when generating the dislocation network.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Note the use of a nodeType array. This is an enumerated type which ensures node types are limited to only those supported by the model while lowering the memory footprint and increasing performance.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We can plot our loops with plotNodes. We use plotlyjs() because it provides a nice interactive experience but any Plots.jl compatible backend will work. Since both loops have the same slip system but one is a shear and the other a prismatic loop, they are orthogonal to each other.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> using Plots\njulia> plotlyjs()\njulia> fig1 = plotNodes(\n          shearHexagon,\n          m = 1,\n          l = 3,\n          linecolor = :blue,\n          markercolor = :blue,\n          legend = false,\n        )\njulia> plotNodes!(fig1, prisPentagon, m = 1, l = 3,\n                  linecolor = :red, markercolor = :red, legend = false)\njulia> plot!(fig1, camera=(100,35), size=(400,400))","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: loops)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"After generating our primitive loops, we can create a network using either a vector of dislocation loops or a single dislocation loop. The network may also be created manually, and new constructor methods may be defined for bespoke cases. For our purposes, we use the constructor that dispatches on Union{DislocationLoop, AbstractVector{<:DislocationLoop}}, meaning a single variable whose type is DislocationLoop or a vector of them. Here we use a vector with both our loop structures.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Since the networks are constantly evolving entities, this necessarily means we need a mutable structure.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> network = DislocationNetwork(\n          [shearHexagon, prisPentagon]; # Dispatch type, bespoke functions dispatch on this.\n          memBuffer = 1 # Buffer for memory allocation.\n       )\n DislocationNetwork{Array{Int64,2},Array{Float64,2},Array{nodeType,1},Int64,Array{Int64,2},Array{Float64,3}}([1 2 … 459 460; 2 3 … 460 456], [0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258; 0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258; 0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258], [0.7071067811865475 0.7071067811865475 … 0.7071067811865475 0.7071067811865475; -0.7071067811865475 -0.7071067811865475 … -0.7071067811865475 -0.7071067811865475; 0.0 0.0 … 0.0 0.0], [46.39761283211718 47.75844046699673 … -57.496002894414175 -61.72537365461118; -49.937613036904054 -48.57678540202451 … -59.28380906452193 -63.51317982471895; 41.67317243370178 38.9515171639427 … -2.1285556467706765 -10.14259619730329], nodeType[DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix  …  DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob], [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0], 460, 460, 4, [2 2 … 2 2; 1 1 … 458 459; … ; 0 0 … 0 0; 0 0 … 0 0], [1 2 … 2 2; 1 1 … 1 2], [1 1 2; 2 2 3; … ; 459 459 460; 460 460 456],\n [0.0 0.0; 0.0 0.0; 0.0 0.0]\n [0.0 0.0; 0.0 0.0; 0.0 0.0]\n [0.0 0.0; 0.0 0.0; 0.0 0.0]\n ...\n [0.0 0.0; 0.0 0.0; 0.0 0.0]\n [0.0 0.0; 0.0 0.0; 0.0 0.0]\n [0.0 0.0; 0.0 0.0; 0.0 0.0])","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This method automatically takes the previously defined loops, and scatters them according to the parameters provided in the DislocationLoop structure. Furthermore, memBuffer defaults to N log2(N) loops where N is the total number of nodes and links. If memBuffer is provided, the number of nodes allocated is memBuffer * N. Here we allocate just enough memory for all the nodes but no more. The software is capable of expanding the arrays as needed using the same N log2(N) heuristic as it approximates graph growth. Minimising memory management is advisable to increase performance.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This function will also automatically calculate other quantities to keep track of the network's links, nodes and segments.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> fieldnames(typeof(network))\n(:links, :slipPlane, :bVec, :coord, :label, :nodeVel, :numNode, :numSeg, :maxConnect, :connectivity, :linksConnect, :segIdx, :segForce)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We can also view our network with plotNodes.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> fig2 = plotNodes(\n          network,\n          m = 1,\n          l = 3,\n          linecolor = :blue,\n          markercolor = :blue,\n          legend = false,\n        )\njulia> plot!(fig2, camera=(110,40), size=(400,400))","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: network)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"<a name=\"1\">1</a>: Immutability is translated into code performance.","category":"page"},{"location":"#IO-1","page":"Home","title":"IO","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The package provides a way to load and save its parameters using JSON files. While this is not the most performant format for IO, it is a popular and portable, web-friendly file format that is very human readable (and therefore easy to manually create). It also produces smaller file sizes both compressed and uncompressed. Which is why it is so popular for online data sharing.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"JSON files are representations of dictionaries with (key, value) pairs, which are analogous to the (key, value) pair of structures. This makes it so any changes to any structure will automatically be taken care of by the JSON library. Arrays are recursively linearised into vectors of vectors using the calling language's preferred storage order. This means arrays preserve their shape and dimensionality regardless of whether the inputting or outputting language stores arrays in column- or row-major order.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"JSON.jl is surprisingly performant, on par with the in-built serialiser and faster than other specialised IO libraries, only JLD2 is faster. However JLD2 is no longer actively maintained. However, the memory allocated during writing is quite a lot larger with JSON.jl than all other methods, but it also generates the smallest compressed and uncompressed files.","category":"page"},{"location":"#Sample-JSON-File-1","page":"Home","title":"Sample JSON File","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This is a sample JSON file for a dislocation loop. They can be compactified by editors to decrease storage space by removing unnecessary line breaks and spaces. Here we show a somewhat longified view which is very human readable and trivially easy to create manually. Note that arrays are recursively linearised as vectors of vectors, where the linearisation follows the calling language's memory order. This means arrays will keep their shape and dimensionality regardless of the language that opens the JSON file.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"{\n  \"loopType\": \"DDD.loopPrism()\",\n  \"numSides\": 4,\n  \"nodeSide\": 2,\n  \"numLoops\": 1,\n  \"segLen\": [1, 1, 1, 1, 1, 1, 1, 1],\n  \"slipSystem\": 1,\n  \"label\": [2, 1, 2, 1, 2, 1, 2, 1],\n  \"buffer\": 0,\n  \"range\": [[0, 0, 0], [0, 0, 0]],\n  \"dist\": \"DDD.Zeros()\"\n}","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The keys are on the left side of the colon and the values on the right. This would get loaded to a dictionary with the same (key, value) pair shown here. Since the keys are the structure's field names and the values their value, everything can be easily matched to the constructor function.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Since JSON files represent dictionaries, they automatically accommodate changes to structures. Irrelevant data can also be added as long as all keys remain unique. JSON also allows for arrays of dictionaries, so multiple structures can be loaded/read at the same time, this is achieved simply by wrapping the entries in square brackets and separating by commas just like other arrays.","category":"page"},{"location":"#Initialisation,-Data-Dump,-and-Reloading-1","page":"Home","title":"Initialisation, Data Dump, and Reloading","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"One can load all their parameters at once like so.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"fileDislocationParameters = \"../inputs/simParams/sampleDislocationParameters.json\"\nfileMaterialParameters = \"../inputs/simParams/sampleMaterialParameters.json\"\nfileIntegrationParameters = \"../inputs/simParams/sampleIntegrationParameters.json\"\nfileSlipSystem = \"../data/slipSystems/SlipSystems.json\"\nfileDislocationLoop = \"../inputs/dln/samplePrismShear.json\"\nfileIntVar = \"../inputs/simParams/sampleIntegrationTime.json\"\ndlnParams, matParams, intParams, slipSystems, dislocationLoop = loadParametersJSON(\n    fileDislocationParameters,\n    fileMaterialParameters,\n    fileIntegrationParameters,\n    fileSlipSystem,\n    fileDislocationLoop,\n)\nintVars = loadIntegrationTimeJSON(fileIntVar)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"which not only loads the data but returns the aforementioned structures. If there is a single file holding all the parameters, then all the filenames would be the same, but nothing else would change as the file would be loaded into a large dictionary and only the relevant (key, value) pairs are used in each case.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Users may also load individual structures as follows.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"dictDislocationParameters = loadJSON(fileDislocationParameters)\nDislocationParameters = loadDislocationParametersJSON(dictDislocationParameters)\n\ndictMaterialParameters = loadJSON(fileMaterialParameters)\nMaterialParameters = loadMaterialParametersJSON(dictMaterialParameters)\n\ndictIntegrationParameters = loadJSON(fileIntegrationParameters)\nIntegrationParameters = loadIntegrationParametersJSON(dictIntegrationParameters)\n\ndictSlipSystem = loadJSON(fileSlipSystem)\nslipSystems = loadSlipSystemJSON(dictSlipSystem)\n\n# There can be multiple dislocation types per simulation.\ndictDislocationLoop = loadJSON(fileDislocationLoop)\ndislocationLoop = zeros(DislocationLoop, length(dictDislocationLoop))\nfor i in eachindex(dislocationLoop)\n    dislocationLoop[i] = loadDislocationLoopJSON(dictDislocationLoop[i], slipSystems)\nend","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Individually loading files like this is useful when recovering previous save states where the data was dumped into a single file, as shown here.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"# Dump simulation parameters into a single file. Creates an array where each entry is one of the structs.\nparamDump = \"../outputs/simParams/sampleDump.json\"\nsaveJSON(paramDump, dlnParams, matParams, intParams, slipSystems, dislocationLoop)\n\n# Dump network data into a separate file.\nnetworkDump = \"../outputs/dln/sampleNetwork.json\"\nsaveJSON(networkDump, network, intVars)\n\n# Reload parameters.\nsimulation = loadJSON(paramDump)\ndlnParams2 = loadDislocationParametersJSON(simulation[1])\nmatParams2 = loadMaterialParametersJSON(simulation[2])\nintParams2 = loadIntegrationParametersJSON(simulation[3])\nslipSystems2 = loadSlipSystemJSON(simulation[4])\ndislocationLoop2 = zeros(DislocationLoop, length(simulation[5]))\nfor i in eachindex(dislocationLoop2)\n    dislocationLoop2[i] = loadDislocationLoopJSON(simulation[5][i], slipSystems2)\nend\n\n# Reload network.\nnetwork2 = loadNetworkJSON(networkDump[1])\nintVars2 = loadIntegrationTimeJSON(networkDump[2])","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The reason why network and intVars are saved separately is because they change as the simulation advances, while the parameters stay the same. Saving the parameters multiple times per simulation is redundant.","category":"page"},{"location":"#Against-the-Unbridled-Pursuit-of-Performance-1","page":"Home","title":"Against the Unbridled Pursuit of Performance","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"For the sake of open, reproducible and portable science it is recommended users utilise JSON or a standard delimited file format for their IO. If IO is a performance bottleneck these are some incremental steps one should take to improve it before creating a custom IO format. Beware that your mileage may vary when using other IO formats, some may not be fully mature yet others may be abandoned in favour of better implementations.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Use buffered IO.\nUse Julia's in-built task and asyncronous functionality via tasks and async for either multiple IO streams or an asyncronous IO process while the other threads/cores carry on with the simulation.\nUse internal serialiser, as of June 30, 2020 it offers no performance improvement other than in memory allocation during io stream buffering.\nUse JLD2. Though the package is no longer under active development.\nUse DelimitedFiles.\nUse binary streams.\nUse Parquet\nCreate your own format and IO stream.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"TO BE WRITTEN: HOW TO EXTEND METHODS TO EXPAND FUNCTIONALITY","category":"page"},{"location":"#TODO/WIP-1","page":"Home","title":"TODO/WIP","text":"","category":"section"},{"location":"#Shaky,-move-y-bois-1","page":"Home","title":"Shaky, move-y bois","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The integration may be buggy, I haven't tested it yet. Coarsen and refine have been tested have passed all of them.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This is a WIP but it shows network remeshing (coarsen and refining) and time integration with no applied stress.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: shaky)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This shows the same but without network coarsening.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: nocoarsen)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This shows the same but without network refining and lower error bounds.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: norefine)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This is just the integration.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: integ)","category":"page"},{"location":"#Working-Objectives-1","page":"Home","title":"Working Objectives","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"[x] IO\n[x] Input validation\n[ ] Sensible input generators\n[ ] Performance\n[ ] Compression\n[ ] Asyncronicity\n[ ] Topology functions\n[ ] Internal Remeshing\n[x] Coarsen mesh\n[x] Refine mesh\n[ ] Surface remeshing\n[ ] Virtual node remeshing\n[x] Self-segment force\n[x] Seg-seg force\n[ ] Test tiny segment edge case\n[ ] Distributed and gpu parallelisation\n[ ] PK force\n[x] Implementation\n[ ] Tests\n[ ] Post processing\n[x] Plot nodes\n[ ] Asyncronicity\n[ ] Plot recipe\n[ ] Statistical analysis\n[ ] Mobility function\n[x] Generic mobility function\n[x] BCC\n[ ] FCC\n[ ] Integration\n[x] Refactor integrator structures\n[ ] CustomTrapezoid\n[x] Implementation\n[ ] Testing\n[ ] Look into using DifferentialEquations.jl for structure and perhaps use/extension of methods\n[ ] Make integrator\n[ ] Couple to FEM, perhaps use a package from JuliaFEM.\n[ ] Mesh and FE matrices generation\n[ ] Boundary conditions\n[ ] Neuman\n[ ] Dirichlet\n[ ] Displacements\n[ ] Parallelisation\n[ ] Tractions\n[ ] Parallelisation\n[ ] Polyhedral operations for FEM coupling. Create convex hull and check if a point is inside the convex hull.","category":"page"},{"location":"#Tentative-Objectives-1","page":"Home","title":"Tentative Objectives","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"[ ] Keep an eye on JuliaIO, JuliaFEM, SciML because their methods might be useful.","category":"page"},{"location":"io/#IO-1","page":"IO","title":"IO","text":"","category":"section"},{"location":"io/#Input-1","page":"IO","title":"Input","text":"","category":"section"},{"location":"io/#","page":"IO","title":"IO","text":"loadJSON(filename::AbstractString)\n\nloadDislocationLoopJSON(\n    dict::Dict{T1, T2} where {T1, T2},\n    slipSystem::SlipSystem,\n)\n\nloadMaterialParametersJSON(dict::Dict{T1, T2}) where {T1, T2}\n\nloadIntegrationParametersJSON(dict::Dict{T1, T2}) where {T1, T2}\n\nloadSlipSystemJSON(dict::Dict{T1, T2}) where {T1, T2}\n\nloadDislocationParametersJSON(dict::Dict{T1, T2}) where {T1, T2}\n\nloadParametersJSON(\n    fileDislocationParameters::AbstractString,\n    fileMaterialParameters::AbstractString,\n    fileIntegrationParameters::AbstractString,\n    fileSlipSystem::AbstractString,\n    fileDislocationLoop::AbstractString,\n)\n\nloadNetworkJSON(fileDislocationNetwork::AbstractString)","category":"page"},{"location":"io/#DDD.loadJSON-Tuple{AbstractString}","page":"IO","title":"DDD.loadJSON","text":"loadJSON(filename::AbstractString)\n\nWrapper for JSON.parsefile(filename).\n\n\n\n\n\n","category":"method"},{"location":"io/#DDD.loadDislocationLoopJSON-Tuple{Dict{T1,T2} where T2 where T1,SlipSystem}","page":"IO","title":"DDD.loadDislocationLoopJSON","text":"function loadDislocationLoopJSON(\n    dict::Dict{T1, T2} where {T1, T2},\n    slipSystem::SlipSystem,\n)\n\nLoads initial dislocation structure out of a dictionary loaded from a JSON file. Returns a variable of type DislocationLoop.\n\n\n\n\n\n","category":"method"},{"location":"io/#DDD.loadMaterialParametersJSON-Union{Tuple{Dict{T1,T2}}, Tuple{T2}, Tuple{T1}} where T2 where T1","page":"IO","title":"DDD.loadMaterialParametersJSON","text":"loadMaterialParametersJSON(dict::Dict{T1, T2}) where {T1, T2}\n\nLoads material parameters out of a dictionary loaded from a JSON file. Returns a variable of type MaterialParameters.\n\n\n\n\n\n","category":"method"},{"location":"io/#DDD.loadIntegrationParametersJSON-Union{Tuple{Dict{T1,T2}}, Tuple{T2}, Tuple{T1}} where T2 where T1","page":"IO","title":"DDD.loadIntegrationParametersJSON","text":"loadIntegrationParametersJSON(dict::Dict{T1, T2}) where {T1, T2}\n\nLoads integration parameters out of a dictionary loaded from a JSON file. Returns a variable of type IntegrationParameters.\n\n\n\n\n\n","category":"method"},{"location":"io/#DDD.loadSlipSystemJSON-Union{Tuple{Dict{T1,T2}}, Tuple{T2}, Tuple{T1}} where T2 where T1","page":"IO","title":"DDD.loadSlipSystemJSON","text":"loadSlipSystemJSON(dict::Dict{T1, T2}) where {T1, T2}\n\nLoads slip systems out of a dictionary loaded from a JSON file. Returns a variable of type SlipSystem.\n\n\n\n\n\n","category":"method"},{"location":"io/#DDD.loadDislocationParametersJSON-Union{Tuple{Dict{T1,T2}}, Tuple{T2}, Tuple{T1}} where T2 where T1","page":"IO","title":"DDD.loadDislocationParametersJSON","text":"loadDislocationParametersJSON(dict::Dict{T1, T2}) where {T1, T2}\n\nLoads dislocation parameters out of a dictionary loaded from a JSON file. Returns a variable of type DislocationParameters.\n\n\n\n\n\n","category":"method"},{"location":"io/#DDD.loadParametersJSON-NTuple{5,AbstractString}","page":"IO","title":"DDD.loadParametersJSON","text":"loadParametersJSON(\n    fileDislocationParameters::AbstractString,\n    fileMaterialParameters::AbstractString,\n    fileIntegrationParameters::AbstractString,\n    fileSlipSystem::AbstractString,\n    fileDislocationLoop::AbstractString,\n)\n\nLoads simulation parameters out of a dictionary loaded from a JSON file. Returns a tuple of variable types (DislocationParameters, MaterialParameters, IntegrationParameters, SlipSystem, DislocationLoop) or vectors of those types.\n\n\n\n\n\n","category":"method"},{"location":"io/#DDD.loadNetworkJSON-Tuple{AbstractString}","page":"IO","title":"DDD.loadNetworkJSON","text":"loadNetworkJSON(fileDislocationNetwork::AbstractString)\n\nLoads a dislocation network from a JSON file. Returns a DislocationNetwork.\n\n\n\n\n\n","category":"method"},{"location":"io/#Output-1","page":"IO","title":"Output","text":"","category":"section"},{"location":"io/#","page":"IO","title":"IO","text":"saveJSON(filename::AbstractString, args...; mode::AbstractString = \"w\")","category":"page"},{"location":"io/#DDD.saveJSON-Tuple{AbstractString,Vararg{Any,N} where N}","page":"IO","title":"DDD.saveJSON","text":"saveJSON(filename::AbstractString, args...; mode::AbstractString = \"w\")\n\nWrapper for JSON.print to a file, args are the variables or structures you want to save.\n\n\n\n\n\n","category":"method"},{"location":"motivation/#Motivation-1","page":"Motivation","title":"Motivation","text":"","category":"section"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"DDD.jl was created with the aim to make 3D discrete dislocation dynamics research more tractable, transparent and productive.","category":"page"},{"location":"motivation/#Objectives-1","page":"Motivation","title":"Objectives","text":"","category":"section"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"Dislocation dynamics is notoriously impenetrable due to the wide range of techniques and historically disparate sciences involved in their study. Lowering the barrier to entry and simplifying the workflows of experimental, theoretical and computational researchers will simplify the development of the field. Specifically, our objectives are to develop a codebase that meets the following requirements:","category":"page"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"ease of use\nsimulations are easy to set up\ninteractivity\nplotting and post-processing\ndata analysis\nautomatic error checking\nstop and restart capabilities\nease of development and maintenance\nreadable code\nmetaprogramming\nmacros (compile time execution)\ngenerated functions (custom functions generated by the code itself)\nproblem logging\nclear warnings, errors and debug information\neasy to add new validations\nhigh level abstractions\narray and matrix operations\nunicode support\ncode introspection\ninteractive debugger\nprofiling and benchmarking\nidentify bottlenecks, type instabilities before runtime\nminimal rewriting\nmodular\ngeneric functions\nself-containment\neasily parallelisable\nlocal parallelisation\ndistributed parallelisation\nGPU parallelisation\nwell documented\neasily add documentation\nnative LaTeX support\nautomatically generated\nwell developed testing capabilities\neasily add tests\neasily interpreted tests\ntest everything even logging events such as warnings and errors\nperformant\nuse as few languages as possible\nCUDA may be needed for specialised parallelisation but should not be a requirement\nself-contained\nno external dependencies\nopen-source, shareable, portable\npublically hosted\nstandardised IO (input-output)\nplug and play","category":"page"},{"location":"motivation/#Possible-Languages-for-Implementation-1","page":"Motivation","title":"Possible Languages for Implementation","text":"","category":"section"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"Historically, two languages that have reigned supreme in the field of scientific computing Fortran and C, however with the advent of object-oriented programming, and interpreted languages that list has expanded. Here we offer some likely candidates to build our code. Some of which have been used in the past to create dislocation dynamics codes of different ilks.","category":"page"},{"location":"motivation/#Fortran-(f90)-1","page":"Motivation","title":"Fortran (f90+)","text":"","category":"section"},{"location":"motivation/#Advantages-1","page":"Motivation","title":"Advantages","text":"","category":"section"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"It is performant, readable, modular, open-source, highly abstracted, natively parallelisable (compiler dependent), and safe through the use of intent() inside functions. Documentation for the language itself is available on the f90 standard practices site and there is a sizeable knowledge base found in StackExchange and the Intel Fortran forums.","category":"page"},{"location":"motivation/#Disadvantages-1","page":"Motivation","title":"Disadvantages","text":"","category":"section"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"It lacks interactivity, metaprogramming (aside from preprocessor macros), and a proper internal standard library. BLAS and LAPACK are as close to a standard library as Fortran gets, but they have to be installed and linked to at compilation time. Furthermore, different compilers break portability, in some cases what is performant code in one compiler is bad code in another. It also has nothing in the way of native testing and documenting, but there are Python tools to do so.","category":"page"},{"location":"motivation/#C-1","page":"Motivation","title":"C","text":"","category":"section"},{"location":"motivation/#Advantages-2","page":"Motivation","title":"Advantages","text":"","category":"section"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"It is performant, small, modular, open-source and compilers are highly standardised. There is no shortage of documentation for C all accross the internet.","category":"page"},{"location":"motivation/#Disadvantages-2","page":"Motivation","title":"Disadvantages","text":"","category":"section"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"On top of lacking what Fortran also lacks, it has the added wrinkle of pointer arithmetic. Which is famously the cause of most C bugs. The best case scenario for such bugs lead to obvious problems like segmentation faults and NaN values. However, more insidious and opaque bugs are not uncommon in complex code, examples include pointer dereferencing, function side effects and memory leaks. Such bugs are hard to track, reproduce and at times catastrophic. Some very well-known bugs and exploits in commercial software such as Windows have been thanks to memory leaks and pointer dereferencing, often going undiscovered for years and through multiple versions. C also doesn't offer anything in the way of abstraction other than structures.","category":"page"},{"location":"motivation/#C-2","page":"Motivation","title":"C++","text":"","category":"section"},{"location":"motivation/#Advantages-3","page":"Motivation","title":"Advantages","text":"","category":"section"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"It has an extensive standard library of optimised algorithms and data structures, all of which are excellently documented. It is open-source and its compilers are also highly standardised (though not as much as C). It also offers serious metaprogramming capabilities, and can be made to be very performant if used correctly, sometimes more so than a naïve C implementation. There are extensive knowledge bases of C++ but the problem is often in deciphering how one may adapt the posted solution to their specific situation.","category":"page"},{"location":"motivation/#Disadvantages-3","page":"Motivation","title":"Disadvantages","text":"","category":"section"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"It is extremely is verbose, very difficult to learn and use correctly, opaque and unintuitive (new v.s. malloc(), del vs free(), namespaces). It mitigates some of the problems of C at the cost of runtime performance and added program complexity. It also tends to make debugging user defined code more difficult because one has to trawl through verbose, complicated syntax. It also requires external libraries to be installed and linked to during compilation.","category":"page"},{"location":"motivation/#Python-1","page":"Motivation","title":"Python","text":"","category":"section"},{"location":"motivation/#Advantages-4","page":"Motivation","title":"Advantages","text":"","category":"section"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"The golden child of interpreted languages is readable, easy to use, open-source, standardised, portable and interactive. It also has an even more extensive standard library than C++. Its vibrant package ecosystem ensures there are packages for every need and frees the user from worrying about external dependencies because they are taken care of by the package installer either automatically or by printing the command required to install the dependency. It has native documentation, testing and benchmarking capabilities. The language has an extremely high level of abstraction and is rapidly evolving, improving and expanding. Package documentation tends to be the gold standard for documentation across all languages by virtue of the sheer number of users and contributors. There is also an extensive knowledge base throughout the internet where solutions to problems have most likely already been posted about and found, if not, one can make a post and have their question answered rather quickly.","category":"page"},{"location":"motivation/#Disadvantages-4","page":"Motivation","title":"Disadvantages","text":"","category":"section"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"It is not performant without serious modification like using Cython or by standard-breaking practices to use the JIT (just in time compiler) offered by numba. Packages such as numpy and scipy help in this regard, but more often than not, the number crunching is done via calls to C, CUDA and Fortran routines through wrappers or direct external calls. Python can also get somewhat verbose, particularly when using a few packages where namespaces must be distinguished by aliases. Standalone executables are much larger than they would be in other languages.","category":"page"},{"location":"motivation/#Matlab-1","page":"Motivation","title":"Matlab","text":"","category":"section"},{"location":"motivation/#Advantages-5","page":"Motivation","title":"Advantages","text":"","category":"section"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"Is readable, easy to use, standardised and interactive. It has native testing, documentation and benchmarking capabilities. The documentation for in-built functions is excellent. It offers limited object oriented capabilities, usually more than enough.","category":"page"},{"location":"motivation/#Disadvantages-5","page":"Motivation","title":"Disadvantages","text":"","category":"section"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"It is closed-source and proprietary. Worse, many of the toolboxes and specialised features are not standard and require additional purchase. Furthermore, the knowledge base for specific questions is limited to the Mathworks forums where only people with Mathworks accounts may post. Increasingly, Matlab offers less and less in comparison to Python. Pretty much all of the performance issues are shared by both languages, but Python is free, open-source and has a massive community developing packages and adding functionality.","category":"page"},{"location":"motivation/#Julia-1","page":"Motivation","title":"Julia","text":"","category":"section"},{"location":"motivation/#Advantages-6","page":"Motivation","title":"Advantages","text":"","category":"section"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"Every advantage that Python offers is also offered by Julia, from the standard library to benchmarking and testing. Its package ecosystem and user base is nowhere near as large as Python's, but it offers the same functionality.","category":"page"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"Unlike any of the other languages we mentioned, Julia is a JIT (just in time) compiled language, just like Python when using numba. So it offers C and Fortran-like performance after a function has been executed once. It offers the same level of abstraction as Python and Matlab while keeping similar or even equivalent[^1 In most cases, the abstractions have a cost-benefit associated with using them, using introspection tools is recommended if performance is critical. Sometimes they outperform less abstracted implementations, but others a non-abstracted implementation is better.] performance to Fortran and C.","category":"page"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"One of the advantages of object-oriented code is reusability and expandability. Function dispatch in object-oriented languages depends on the function's class. However, Julia's multiple dispatch, type system, and JIT compilation takes code reusability to another level by letting functions specialise depending on the types of their arguments. This means that one can expand functions defined anywhere in the code by declaring them for new types. This means developers can write generic functions that can be expanded by users as they see fit. A concrete example we use in DDD.jl is in constructing dislocation loops. Where new types of loops or even special dislocation structures don't need their own data structure, one can simply declare a new constructor for a new type of loop and it will be called using the same user-interface.","category":"page"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"Furthermore, Julia can be used as both, a statically typed or dynamically typed language. If one wants performance, one gets performance by annotating types[^2 Types do not have to be known by the user before runtime, they can be given parametrically and the compiler will use the argument's type during runtime to compile a specialised function. This lets programs be generically typed without sacrificing performance or adding verbosity.] and writing well-defined code. If one wants to use Julia interactively like Python or Matlab, that works too. And the compiler will do its best to ensure the code is performant.","category":"page"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"Another aspect that Julia offers that none of the others do is the ability to look at the different stages of compilation. This lets developers and users identify areas where the code might suffer a runtime bottleneck before even running it. There are also extensive profiling, debugging and benchmarking tools that provide timing and memory allocation information. Out of the languages mentioned, Julia is the easiest to write performant code in.","category":"page"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"If this weren't enough, there is also native support for CPU and GPU parallelisation both local and distributed, as well as the ability to call external languages with a single interface. Its metaprogramming capabilities are on par with C++ but much more concise and less impactful on compilation time.","category":"page"},{"location":"motivation/#Disadvantages-6","page":"Motivation","title":"Disadvantages","text":"","category":"section"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"Multiple dispatch can be abused by new users and may negatively impact performance. Precompilation time for packages and the \"time to first plot\" can be relatively long.","category":"page"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"It is a new language, things are changing rapidly and backwards compatibility may not always be guaranteed. There are also features that are experimental and subject to change, deprecation and removal. For example, 1.4 CPU parallelisation is experimental as well as the @simd macro for inner loop performance.","category":"page"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"A side effect of the incredibly powerful documenting system of Julia is that one can go to where intrinsic functions are implemented and one is free to change them. However this also means that if a user wants to extend an intrinsic method they can use the documentation to navigate to where it is defined and see how it is implemented so they may extend it for their use case.","category":"page"}]
}
