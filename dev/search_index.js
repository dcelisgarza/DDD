var documenterSearchIndex = {"docs":
[{"location":"api/#","page":"API","title":"API","text":"Modules = [DDD]","category":"page"},{"location":"api/#DDD.DislocationLoopCollection","page":"API","title":"DDD.DislocationLoopCollection","text":"DislocationLoopCollection = Union{T,AbstractVector{T},NTuple{N,T} where N} where {T <: DislocationLoop}\n\nDefines a single, vector, and tuple of DislocationLoop types.\n\n\n\n\n\n","category":"constant"},{"location":"api/#DDD.AbstractCrystalStruct","page":"API","title":"DDD.AbstractCrystalStruct","text":"abstract type AbstractCrystalStruct end\nstruct BCC <: AbstractCrystalStruct end\nstruct FCC <: AbstractCrystalStruct end\nstruct HCP <: AbstractCrystalStruct end\n\nCrystal structure types.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.AbstractDistribution","page":"API","title":"DDD.AbstractDistribution","text":"abstract type AbstractDistribution end\nstruct Zeros <: AbstractDistribution end\nstruct Rand <: AbstractDistribution end\nstruct Randn <: AbstractDistribution end\nstruct Regular <: AbstractDistribution end\n\nSpatial distributions for dislocation sources. These are used to automatically generate networks with a given distribution.\n\nZeros makes the network generation functions place the center of the generated dislocation loops at the origin. This can be used to generate a network and loops can be manually or pseudo-manually distributed in the domain.\nRand makes the network generation functions uniformly distribute the dislocations according to the range and buffer values in the dislocation loop structure.\nRand makes the network generation functions normally distribute the dislocations according to the range and buffer values in the dislocation loop structure.\nRand TBA, will regularly distribute dislocations according to the range, buffer and other args given to the dislocation network generator.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.AbstractDlnSeg","page":"API","title":"DDD.AbstractDlnSeg","text":"abstract type AbstractDlnSeg end\nstruct segNone <: AbstractDlnSeg end    # Undefined segment\nstruct segEdge <: AbstractDlnSeg end    # Edge segment\nstruct segEdgeN <: AbstractDlnSeg end   # Edge segment\nstruct segScrew <: AbstractDlnSeg end   # Screw segment\nstruct segMixed <: AbstractDlnSeg end   # Mixed segment\n\nThese types are used to automatically generate segments out of Burgers vectors b, slip planes n, and/or line direction l.\n\nsegEdge: b ⟂ t,\nsegEdgeN: b ⟂ t and b ∥ n ,\nsegScrew: b ∥ t ,\nsegMixed: none of the above.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.AbstractDlnStr","page":"API","title":"DDD.AbstractDlnStr","text":"abstract type AbstractDlnStr end\nstruct loopPrism <: AbstractDlnStr end\nstruct loopShear <: AbstractDlnStr end\nconst loopPure = Union{loopPrism,loopShear}\nstruct loopMixed <: AbstractDlnStr end\nstruct loopJog <: AbstractDlnStr end\nstruct loopKink <: AbstractDlnStr end\nconst loopImpure = Union{loopMixed,loopJog,loopKink}\nconst loopDefined = Union{loopPure,loopImpure}\nstruct loopDln <: AbstractDlnStr end\n\nThese types are used to automatically generate dislocation loops for simulation initialisation.\n\nloopPrism: prismatic loops, their Burgers vectors are perpendicular to the their line direction. They are idealised loops that can be automatically generated as n-gons\nloopShear: shear loops, their line direction goes through edge, screw and line segments as the loop goes round. They are idealised loops that can be automatically generated as n-gons\nloopPure: idealised loops\nloopMixed: loops with prismatic and shear character. They have to be hand-made or require a heuristic to automatically generate\nloopDln: generic loop used for adding methods to Base functions\nloopKink and loopJog are structures formed by colliding dislocations. They are not currently used\nloopImpure: non-idealised loops\nloopDefined: defined loop types\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.AbstractElementOrder","page":"API","title":"DDD.AbstractElementOrder","text":"abstract type AbstractElementOrder end\nstruct LinearElement <: AbstractElementOrder end\n\nFinite element orders for dispatch.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.AbstractIntegrator","page":"API","title":"DDD.AbstractIntegrator","text":"abstract type AbstractIntegrator end\nstruct AdaptiveEulerTrapezoid <: AbstractIntegrator end\n\nIntegrator types for dispatch.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.AbstractMesh","page":"API","title":"DDD.AbstractMesh","text":"abstract type AbstractMesh end\nabstract type AbstractRegularCuboidMesh <: AbstractMesh end\nstruct DispatchRegularCuboidMesh <: AbstractRegularCuboidMesh end\n\nFE mesh types for dispatch.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.AbstractMobility","page":"API","title":"DDD.AbstractMobility","text":"abstract type AbstractMobility end\nstruct mobBCC <: AbstractMobility end\nstruct mobFCC <: AbstractMobility end\nstruct mobHCP <: AbstractMobility end\n\nTypes to dispatch different mobility functions.\n\nmobBCC: used to dispatch the default BCC mobility function.\nmobFCC: used to dispatch the default FCC mobility function.\nmobHCP: used to dispatch the default HCP mobility function.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.AbstractModel","page":"API","title":"DDD.AbstractModel","text":"abstract type AbstractModel end\nabstract type AbstractCantilever <: AbstractModel end\nstruct CantileverLoad <: AbstractCantilever end\n\nAbstract types for dispatching different models.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.AbstractShapeFunction","page":"API","title":"DDD.AbstractShapeFunction","text":"abstract type AbstractShapeFunction end\nabstract type AbstractShapeFunction3D <: AbstractShapeFunction end\nabstract type AbstractShapeFunction2D <: AbstractShapeFunction end\nstruct LinearQuadrangle3D <:AbstractShapeFunction3D end\nstruct LinearQuadrangle2D <:AbstractShapeFunction2D end\n\nShape function types for dispatch.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.Boundaries","page":"API","title":"DDD.Boundaries","text":"struct Boundaries{T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12}\n    model::T1\n    noExit::T2\n    uGammaDln::T3\n    tGammaDln::T4\n    uDofsDln::T5\n    tDofsDln::T6\n    uGamma::T7\n    tGamma::T8\n    mGamma::T9\n    uDofs::T10\n    tDofs::T11\n    mDofs::T12\n    tK::T13\nend\n\nStores the nodes and degrees of freedom upon which the different boundary conditions are applied.\n\nFields\n\nnoExit: Faces that are impenetrable to dislocations\nuGammaDln: Nodes on which dislocation displacements are calculated\ntGammaDln: Nodes on which dislocation tractions are calculated\nuDofsDln: Degrees of freedom on which dislocation displacements are calculated\ntDofsDln: Degrees of freedom on which dislocation tractions are calculated\nuGamma: Nodes with displacement boundaries\ntGamma: Nodes with traction boundaries\nmGamma: Nodes with displacement and traction boundaries\nuDofs: Degrees of freedom with specified displacements\ntDofs: Degrees of feedom with specified tractions\nmDofs0: Degrees of feedom with specified displacements and tractions\ntK1: Stiffness matrix of traction degrees of freedom\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.Boundaries-Tuple{FEMParameters{T1,T2,T3,T4,T5,T6,T7,T8,T9} where T9 where T8 where T7 where T6 where T5 where T4 where T3<:CantileverLoad where T2 where T1,RegularCuboidMesh}","page":"API","title":"DDD.Boundaries","text":"Boundaries(\n    ::FEMParameters{T1,T2,T3,T4,T5} where {T1,T2,T3<:CantileverLoad,T4,T5},\n    femMesh::RegularCuboidMesh; \n    kw...\n)\n\nCreates Boundaries for loading a hexahedral cantilever.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.Boundaries-Tuple{}","page":"API","title":"DDD.Boundaries","text":"Boundaries(; model, noExit, uGamma, tGamma, mGamma, uDofs, tDofs, mDofs, tK)\n\nCreates Boundaries.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.BoundaryNode","page":"API","title":"DDD.BoundaryNode","text":"struct BoundaryNode{T1,T2}\n    index::T1\n    node::T2\nend\n\nStores corresponding type, indices and node number of boundary nodes.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.BoundaryNode-Tuple{}","page":"API","title":"DDD.BoundaryNode","text":"BoundaryNode(; index, node)\n\nCreate BoundaryNode.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.DislocationLoop","page":"API","title":"DDD.DislocationLoop","text":"struct DislocationLoop{T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14}\n    loopType::T1        # Loop type.\n    numSides::T2        # Number of sides in the loop.\n    nodeSide::T3        # Nodes per side of the loop.\n    numLoops::T4        # Number of loops to generate when making the network.\n    segLen::T5          # Segment lengths.\n    slipSystemIdx::T6   # Slip system.\n    label::T7           # Node labels.\n    links::T8           # Links.\n    slipPlane::T9       # Slip planes.\n    bVec::T10           # Burgers vectors.\n    coord::T11          # Coordinates.\n    buffer::T12         # Buffer for distributions.\n    range::T13          # Range for distributions.\n    dist::T14           # Distribution.\nend\n\nStores a dislocation loop.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.DislocationLoop-Tuple{AbstractDlnStr,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any}","page":"API","title":"DDD.DislocationLoop","text":"DislocationLoop(\n    loopType::AbstractDlnStr,\n    numSides,\n    nodeSide,\n    numLoops,\n    segLen,\n    slipSystem,\n    _slipPlane,\n    _bVec,\n    label,\n    buffer,\n    range,\n    dist,\n)\n\nFallback for creating a generic DislocationLoop.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.DislocationLoop-Tuple{Union{DDD.loopJog, DDD.loopKink, DDD.loopMixed},Any,Any,Any,Any,Any,SlipSystem,AbstractArray{nodeTypeDln,1},Any,Any,AbstractDistribution}","page":"API","title":"DDD.DislocationLoop","text":"DislocationLoop(\n    loopType::loopImpure,\n    numSides,\n    nodeSide,\n    numLoops,\n    segLen,\n    slipSystem,\n    _slipPlane::AbstractArray,\n    _bVec::AbstractArray,\n    label::AbstractVector{nodeTypeDln},\n    buffer,\n    range,\n    dist::AbstractDistribution,\n)\n\nFallback DislocationLoop constructor for other as of yet unimplemented loopImpure.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.DislocationLoop-Tuple{Union{loopPrism, loopShear},Any,Any,Any,Any,Any,SlipSystem,AbstractArray{nodeTypeDln,1},Any,Any,AbstractDistribution}","page":"API","title":"DDD.DislocationLoop","text":"DislocationLoop(\n    loopType::loopPure,\n    numSides,\n    nodeSide,\n    numLoops,\n    segLen,\n    slipSystem,\n    _slipPlane::AbstractArray,\n    _bVec::AbstractArray,\n    label::AbstractVector{nodeTypeDln},\n    buffer,\n    range,\n    dist::AbstractDistribution,\n)\n\nConstructor for loopPure DislocationLoops.\n\nInputs\n\nloopType::loopPure: can be either loopPrism() or loopShear() to make prismatic or shear loops.\nnumSides: number of sides in the loop\nnodeSide: nodes per side of the loop\nnumLoops: number of loops to generate when making the dislocation network\nsegLen: length of each initial dislocation segment\nslipSystem: slip system from SlipSystem the loop belongs to\n_slipPlane: slip plane vector\n_bVec: Burgers vector\nlabel: node labels of type nodeTypeDln\nbuffer: buffer for increasing the spread of the generated dislocation loops in the network\nrange: range on which the loops will be distributed in the network\ndist: distribution used to generate the network\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.DislocationLoop-Tuple{}","page":"API","title":"DDD.DislocationLoop","text":"DislocationLoop(;\n    loopType::AbstractDlnStr,\n    numSides,\n    nodeSide,\n    numLoops,\n    segLen,\n    slipSystem,\n    _slipPlane,\n    _bVec,\n    label,\n    buffer,\n    range,\n    dist,\n)\n\nCreate a DislocationLoop.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.DislocationNetwork","page":"API","title":"DDD.DislocationNetwork","text":"struct DislocationNetwork{T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14}\n    numNode::T1\n    numSeg::T2\n    maxConnect::T3\n    label::T4\n    links::T5\n    connectivity::T6\n    linksConnect::T7\n    slipPlane::T8\n    segIdx::T9\n    bVec::T10\n    coord::T11\n    nodeVel::T12\n    nodeForce::T13\n    segForce::T14\nend\n\nStores a dislocation network.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.DislocationNetwork","page":"API","title":"DDD.DislocationNetwork","text":"DislocationNetwork(\n    sources::DislocationLoopCollection,\n    maxConnect = 4,\n    args...;\n    memBuffer = nothing,\n    checkConsistency = true,\n    kw...,\n)\n\nCreates a DislocationNetwork out of a DislocationLoopCollection.\n\nInputs\n\nargs... are optional arguments that will be passed on to the loopDistribution function which distributes the loops in sources according to the type of their dist variable.\nkw... are optional keyword arguments that will also be passed to loopDistribution.\nmemBuffer is the numerical value for allocating memory in advance. The quantity, memBuffer × N, where N is the total number of nodes in sources, will be the initial number of entries allocated in the matrices that keep the network's data. If no memBuffer is provided, the number of entries allocated will be `round(N*log2(N)).\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.DislocationNetwork-Tuple{}","page":"API","title":"DDD.DislocationNetwork","text":"DislocationNetwork(;\n    links::AbstractArray,\n    slipPlane::AbstractArray,\n    bVec::AbstractArray,\n    coord::AbstractArray,\n    label::AbstractVector{nodeTypeDln},\n    nodeVel::AbstractArray,\n    nodeForce::AbstractArray,\n    numNode = length(label),\n    numSeg = size(links, 2),\n    maxConnect = 4,\n    connectivity::AbstractArray = zeros(Int, 1 + 2 * maxConnect, length(label)),\n    linksConnect::AbstractArray = zeros(Int, 2, size(links, 2)),\n    segIdx::AbstractArray = zeros(Int, size(links, 2), 3),\n    segForce::AbstractArray = zeros(3, 2, size(links, 2)),\n)\n\nCreate a DislocationNetwork. We recommend generating networks from DislocationLoop unless you want a special case.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.DislocationParameters","page":"API","title":"DDD.DislocationParameters","text":"struct DislocationParameters{T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24}\n    mobility::T1\n    dragCoeffs::T2\n    coreRad::T3\n    coreRadSq::T4\n    coreRadMag::T5\n    coreEnergy::T6\n    minSegLen::T7\n    minSegLenSq::T8\n    maxSegLen::T9\n    twoMinSegLen::T10\n    minArea::T11\n    maxArea::T12\n    minAreaSq::T13\n    maxAreaSq::T14\n    collisionDist::T15\n    collisionDistSq::T16\n    slipStepCritLen::T17\n    slipStepCritArea::T18\n    remesh::T19\n    collision::T20\n    separation::T21\n    virtualRemesh::T22\n    parCPU::T23\n    parGPU::T24\nend\n\nStores the dislocation parameters.\n\nFieldnames\n\nmobility: mobility law\ndragCoeffs: drag coefficients, use of a named tuple is recommended\ncoreRad: dislocation core radius\ncoreRadSq: square of the dislocation core radius\ncoreRadMag: magnitude of the dislocation core radius\ncoreEnergy: core energy\nminSegLen: minimum segment length\nmaxSegLen: maximum segment length\ntwoMinSegLen: two times minimum segment length\nminSegLenSq: square of the minimum segment length\nminArea: minimum area\nmaxArea: maximum area\nminAreaSq: square of the minimum area\nmaxAreaSq: sqare of the maximum area\ncollisionDist: collision distance\nslipStepCritLen: critical length for slip step tracking\nslipStepCritArea: critical area for slip step tracking\nremesh: remeshing flag\ncollision: collision flag\nseparation: separation flag\nvirtualRemesh: virtual remeshing flag\nparCPU: parallelise over CPU flag\nparGPU: parallelise over GPU flag\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.DislocationParameters-Tuple{}","page":"API","title":"DDD.DislocationParameters","text":"DislocationParameters(;\n    mobility::AbstractMobility,\n    dragCoeffs = (edge = 1.0, screw = 2.0, climb = 1e9),\n    coreRad = 1.0,\n    coreRadMag = 1.0,\n    coreEnergy = 1 / (4 * π) * log(coreRad / 0.1),\n    minSegLen = 2 * coreRad,\n    maxSegLen = 20 * coreRad,\n    minArea = minSegLen^2 / sqrt(2),\n    maxArea = 100 * minArea,\n    collisionDist = minSegLen / 2,\n    slipStepCritLen = maxSegLen / 2,\n    slipStepCritArea = 0.5 * (slipStepCritLen^2) * sind(1),\n    remesh = true,\n    collision = true,\n    separation = true,\n    virtualRemesh = true,\n    parCPU = false,\n    parGPU = false,\n)\n\nCreates DislocationParameters. Automatically calculates derived values, asserts values are reasonable and provides sensible default values.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.FEMParameters","page":"API","title":"DDD.FEMParameters","text":"struct FEMParameters{T1,T2,T3,T4,T5,T6,T7,T8,T9}\n    type::T1\n    order::T2\n    model::T3\n    dx::T4\n    dy::T5\n    dz::T6\n    mx::T7\n    my::T8\n    mz::T9\nend\n\nStores the finite element parameters.\n\nFields\n\ntype: Mesh type\norder: Element order\nmodel: Experimental model\ndx: Dimension in x\ndy: Dimension in y\ndz: Dimension in z\nmx: Elements in x\nmy: Elements in y\nmz: Elements in z\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.FEMParameters-Tuple{}","page":"API","title":"DDD.FEMParameters","text":"FEMParameters(; \n    type::AbstractMesh,\n    order::AbstractElementOrder,\n    model::AbstractModel,\n    dx, dy, dz, mx, my, mz\n)\n\nCreates FEMParameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.ForceDisplacement","page":"API","title":"DDD.ForceDisplacement","text":"struct ForceDisplacement{T1,T2,T3,T4,T5,T6}\n    uTilde::T1\n    uHat::T2\n    u::T3\n    fTilde::T4\n    fHat::T5\n    f::T6\nend\n\nStores displacements and forces applied on the FE nodes.\n\nFields\n\nuTilde: Dislocation displacements\nuHat: Corrective displacements\nu: Displacements\nfTilde Dislocation forces\nfHat: Corrective forces\nf: Forces\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.ForceDisplacement-Tuple{}","page":"API","title":"DDD.ForceDisplacement","text":"ForceDisplacement(; uTilde, uHat, u, fTilde, fHat, f)\n\nCreates ForceDisplacement.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.ForceDisplacementDot","page":"API","title":"DDD.ForceDisplacementDot","text":"struct ForceDisplacementDot{T1,T2,T3,T4}\n    uDotDofs::T1\n    uDot::T2\n    fDotDofs::T3\n    fDot::T4\nend\n\nLoading and displacement rate. Stores the degrees of freedom on which the loading is applied as well as the loading values.\n\nFields\n\nuDotDofs: degrees of freedom on which a displacement is applied\nuDot: displacement rate\nfDotDofs: degrees of freedom on which a load is applied\nfDot: loading rate\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.IntegrationParameters","page":"API","title":"DDD.IntegrationParameters","text":"struct IntegrationParameters{T1,T2,T3,T4,T5,T6,T7,T8,T9,T10}\n    method::T1\n    tmin::T2\n    tmax::T3\n    dtmin::T4\n    dtmax::T5\n    abstol::T6\n    reltol::T7\n    maxchange::T8\n    exponent::T9\n    maxiter::T10\nend\n\nStores integration parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.IntegrationParameters-Tuple{}","page":"API","title":"DDD.IntegrationParameters","text":"IntegrationParameters(;\n    method::AbstractIntegrator,\n    tmin = 0.0,\n    tmax = 1e13,\n    dtmin = 1e-3,\n    dtmax = Inf,\n    abstol = 1e-6,\n    reltol = 1e-6,\n    maxchange = 1.2,\n    exponent = 20.0,\n    maxiter = 10,\n)\n\nCreates IntegrationParameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.IntegrationTime","page":"API","title":"DDD.IntegrationTime","text":"struct IntegrationTime{T1,T2,T3}\n    dt::T1      # Current time step.\n    time::T2    # Current simulation time.\n    step::T3    # Current simulation step.\nend\n\nStore integration time and steps.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.IntegrationTime-Tuple{}","page":"API","title":"DDD.IntegrationTime","text":"IntegrationTime(; dt = 0.0, time = 0.0, step = 0)\n\nCreates IntegrationTime.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.MaterialParameters","page":"API","title":"DDD.MaterialParameters","text":"struct MaterialParameters{T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15}\n    crystalStruct::T1   # Crystal structure.\n    μ::T2               # Shear modulus.\n    μMag::3             # Magnitude of shear modulus.\n    ν::T4               # Poisson ratio.\n    E::T5               # Young's modulus.\n    omνInv::T6          # 1 / (1 - ν)\n    opνInv::T7          # 1 / (1 + ν)\n    νomνInv::T8         # ν / (1 - ν)\n    νopνInv::T9         # v / (1 + ν)\n    μ4π::T10            # μ / (4π)\n    μ8π::T11            # μ / (8π)\n    μ4πν::T12           # μ / (4π (1 - ν))\n    omνInv8π::T13       # 1 / (8π (1 - ν))\n    om2νomνInv8π::T14   # (1 - 2 * ν) / (8π (1 - ν))\n    σPN::T15            # Peierls-Nabarro stress.\nend\n\nStore material parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.MaterialParameters-Tuple{}","page":"API","title":"DDD.MaterialParameters","text":"MaterialParameters(;\n    crystalStruct::AbstractCrystalStruct,\n    μ = 1.0,\n    μMag = 1.0,\n    ν = 0.2,\n    σPN = 0.0,\n)\n\nCreates MaterialParameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.RegularCuboidMesh","page":"API","title":"DDD.RegularCuboidMesh","text":"struct RegularCuboidMesh{\n    T1,\n    T2,\n    T3,\n    T4,\n    T5,\n    T6,\n    T7,\n    T8,\n    T9,\n    T10,\n    T11,\n    T12,\n    T13,\n    T14,\n    T15,\n    T16,\n    T17,\n    T18,\n    T19,\n    T20,\n    T21,\n    T22,\n    T23,\n    T24,\n    T25,\n    T26,\n    T27,\n    T28,\n} <: AbstractRegularCuboidMesh\n    order::T1\n    dx::T2\n    dy::T3\n    dz::T4\n    mx::T5\n    my::T6\n    mz::T7\n    w::T8\n    h::T9\n    d::T10\n    scale::T11\n    numElem::T12\n    numNode::T13\n    C::T14\n    vertices::T15\n    faces::T16\n    faceNorm::T17\n    faceMidPt::T18\n    cornerNode::T19\n    edgeNode::T20\n    faceNode::T21\n    surfNode::T22\n    surfNodeArea::T23\n    surfNodeNorm::T24\n    surfElemNode::T25\n    coord::T26\n    connectivity::T27\n    K::T28\nend\n\nStores regular a cuboid mesh.\n\nFields\n\norder: Element order\ndx: Size in x\ndy: Size in y\ndz: Size in z\nmx: Elements in x\nmy: Elements in y\nmz: Elements in z\nw: Width\nh: Height\nd: Depth\nscale: Mesh scale\nnumElem: Number of elements\nnumNode: Number of nodes\nC: Stiffness tensor\nvertices: Vertices\nfaces: Faces\nfaceNorm: Face normals\nfaceMidPt: Face mid-points\ncornerNode: Corner nodes set\nedgeNode: Edge nodes set\nfaceNode: Face node set\ncoord: Node coordinates\nconnectivity: Node connectivity\nK: Stiffness matrix\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.RegularCuboidMesh-Tuple{MaterialParameters,FEMParameters{F1,F2,F3,F4,F5,T6,T7,T8,T9} where T9 where T8 where T7 where T6 where F5 where F4 where F3 where F2<:LinearElement where F1<:DispatchRegularCuboidMesh}","page":"API","title":"DDD.RegularCuboidMesh","text":"RegularCuboidMesh(\n    matParams::MaterialParameters,\n    femParams::FEMParameters{F1,F2,F3,F4,F5} where {F1<:DispatchRegularCuboidMesh,F2<:LinearElement,F3,F4,F5}\n)\n\nFE domain with linear hexahedral elements with 2 × 2 × 2 Gauss nodes. Uses the canonical node, face and edge ordering of https://www.mcs.anl.gov/uploads/cels/papers/P1573A.pdf.\n\nCorners:\n\n      7----------8\n     /|         /|\n    / |        / |\n   /  |       /  |\n  /   4------/---3\n /   /      /   /\n5----------6   /\n|  /       |  /\n| /        | /\n|/         |/\n1----------2\n\nEdges:\n\n      .----11-----.\n     /|          /|\n    / 8         / 7\n  12  |       10  |\n  /   .-----3-/---.\n /   /       /   /\n.-----9-----.   /\n|  4        |  2\n5 /         6 /\n|/          |/\n.-----1-----.\n\nFaces:\n\n      .----------.\n     /|         /|\n    / |    3   / |\n   /  | 6     /  |\n  /   .------/---.\n / 4 /      / 2 /\n.----------.   /\n|  /     5 |  /\n| /  1     | /\n|/         |/\n.----------.\n\n\nZ    \n^   y\n|  ^  \n| / \n.-----> x\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.SlipSystem","page":"API","title":"DDD.SlipSystem","text":"struct SlipSystem{T1,T2,T3}\n    crystalStruct::T1\n    slipPlane::T2\n    bVec::T3\nend\n\nStores slip systems. \n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.SlipSystem-Tuple{}","page":"API","title":"DDD.SlipSystem","text":"SlipSystem(;\n    crystalStruct::AbstractCrystalStruct,\n    slipPlane::AbstractArray,\n    bVec::AbstractArray\n)\n\nCreates a SlipSystem.\n\nEnsures slipPlane ⟂ bVec.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.nodeTypeDln","page":"API","title":"DDD.nodeTypeDln","text":"@enum nodeTypeDln begin\n    noneDln = 0    # Undefined node, value at initialisation\n    intMobDln = 1  # Internal mobile node\n    intFixDln = 2  # Internal fixed node\n    srfMobDln = 3  # Mobile surface node\n    srfFixDln = 4  # Fixed surface node\n    extDln = 5     # External node\n    tmpDln = 6     # Temporary flag, used during topological operations\nend\n\nDifferent types of nodes behave differently. There are only a finite number of them so an enumerated type provides safety and efficiency. Each value represents a different type of node and therefore its behaviour.\n\nInstances\n\nnoneDln: uninitialised nodes.\nintMobDln: mobile nodes internal to the convex hull of the domain. They take part in tractions, displacements and dislocation interactions.\nintFixDln: fixed nodes internal to the convex hull of the domain. They participate in the same way as intMobDln nodes except for the fact that their velocities is fixed are zero.\nsrfMobDln: mobile nodes that live on the surface of the convex hull of the domain, they are used to track slip steps and therefore participate in the same things as internal nodes but their velocities are restricted to the convex hull surface.\nsrfFixDln: fixed surface nodes and have the same characteristics as mobile surface nodes except for having zero velocity.\nextDln: external nodes that do not participate in dislocation interactions or forces but are used to calculate displacements and track slip steps.\ntmpDln: nodes that are temporarily flagged before they are assigned another type.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.nodeTypeFE","page":"API","title":"DDD.nodeTypeFE","text":"@enum nodeTypeFE begin\n    noneFE = 0\n    corner = 1  # Corner node\n    edge = 2    # Edge node\n    face = 3    # Face node\n    intFE = 4   # Internal node\nend\n\nFinite element node type.\n\nInstances\n\nnoneFE = 0: Uninitialised\ncorner = 1: Corner\nedge = 2: Edge\nface = 3: Face\nintFE = 4: Internal\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.:⊗-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractArray{T1,1},AbstractArray{T2,1}}} where T2 where T1","page":"API","title":"DDD.:⊗","text":"⊗(x::AbstractVector, y::AbstractVector)\n\nTensor product.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.DislocationNetwork!-Tuple{DislocationNetwork,Union{AbstractArray{T,1}, Tuple{Vararg{T,N}} where N, T} where T<:DislocationLoop,Vararg{Any,N} where N}","page":"API","title":"DDD.DislocationNetwork!","text":"DislocationNetwork!(\n    network::DislocationNetwork,\n    sources::DislocationLoopCollection,\n    args...;\n    memBuffer = nothing,\n    checkConsistency = true,\n    kw...,\n)\n\nAdds a DislocationLoopCollection to an existing DislocationNetwork.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.buildMesh-Tuple{MaterialParameters,FEMParameters{F1,F2,F3,F4,F5,T6,T7,T8,T9} where T9 where T8 where T7 where T6 where F5 where F4 where F3 where F2 where F1<:DispatchRegularCuboidMesh}","page":"API","title":"DDD.buildMesh","text":"buildMesh(\n    matParams::MaterialParameters, \n    femParams::FEMParameters{F1,F2,F3,F4,F5} where {F1<:DispatchRegularCuboidMesh,F2,F3,F4,F5}\n)\n\nCreates a RegularCuboidMesh.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.calcDisplacementDislocationTriangle!-NTuple{8,Any}","page":"API","title":"DDD.calcDisplacementDislocationTriangle!","text":"calcDisplacementDislocationTriangle!(uTilde, uDofs, matParams, A, B, C, b, P)\n\nWritten by F.Hofmann 9/7/09 Routine to compute the displacement field for a triangular dislocation loop ABC at point P.\n\nModified by F.Hofmann 5/11/18\n\nInputs\n\nA, B, C: three column vectors defining the nodes of the dislocation loop.\nP: column vector with coordinates of the point at which the displacement is evaluated in dimension 1. Then in dimension 2 this is a list of points at which to evaluate the field.\nb: column vector with 3 burgers vector components.\n\nTranslated by Daniel Celis Garza.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.calcPKForce","page":"API","title":"DDD.calcPKForce","text":"calcPKForce(\n    mesh::AbstractMesh,\n    forceDisplacement::ForceDisplacement,\n    network::DislocationNetwork,\n    idx = nothing,\n)\n\ncalcPKForce!(\n    mesh::AbstractMesh,\n    forceDisplacement::ForceDisplacement,\n    network::DislocationNetwork,\n    idx = nothing,\n)\n\nCompute the Peach-Koehler force on segments by using calc_σHat.\n\nf = (hatmathbbsigma cdot overrightarrowb) times overrightarrowt\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.calcSegForce","page":"API","title":"DDD.calcSegForce","text":"calcSegForce(\n    dlnParams::DislocationParameters,\n    matParams::MaterialParameters,\n    mesh::AbstractMesh,\n    forceDisplacement::ForceDisplacement,\n    network::DislocationNetwork,\n    idx = nothing,\n)\n\ncalcSegForce!(\n    dlnParams::DislocationParameters,\n    matParams::MaterialParameters,\n    mesh::AbstractMesh,\n    forceDisplacement::ForceDisplacement,\n    network::DislocationNetwork,\n    idx = nothing,\n)\n\nCompute total force on dislocation segments.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.calcSegSegForce","page":"API","title":"DDD.calcSegSegForce","text":"calcSegSegForce(\n    dlnParams::DislocationParameters,\n    matParams::MaterialParameters,\n    network::DislocationNetwork,\n    idx = nothing,\n)\n\nCompute the segment-segment forces for every dislocation segment.\n\nDetails found in Appendix A.1. in \"Enabling Strain Hardening Simulations with Dislocation Dynamics\" by A. Arsenlis et al.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.calcSegSegForce!","page":"API","title":"DDD.calcSegSegForce!","text":"calcSegSegForce!(\n    dlnParams::DislocationParameters,\n    matParams::MaterialParameters,\n    network::DislocationNetwork,\n    idx = nothing,\n)\n\nIn-place computation of the segment-segment forces for every dislocation segment.\n\nDetails found in Appendix A.1. in \"Enabling Strain Hardening Simulations with Dislocation Dynamics\" by A. Arsenlis et al.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.calcSelfForce","page":"API","title":"DDD.calcSelfForce","text":"calcSelfForce(\n    dlnParams::DislocationParameters,\n    matParams::MaterialParameters,\n    network::DislocationNetwork,\n    idx = nothing,\n)\n\ncalcSelfForce!(\n    dlnParams::DislocationParameters,\n    matParams::MaterialParameters,\n    network::DislocationNetwork,\n    idx = nothing,\n)\n\nCompute the self-interaction force on dislocation segments. calcSelfForce! for its mutating form.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.calc_uTilde!-Tuple{ForceDisplacement,AbstractMesh,Boundaries,MaterialParameters,DislocationNetwork}","page":"API","title":"DDD.calc_uTilde!","text":"Calculates displacements from dislocations. Bruce Bromage, bruce.bromage@materials.ox.ac.uk Github: @brucebromage\n\nCalculating dislocation displacements on the surface of a volume B Bromage and E Tarleton Published 29 October 2018 • © 2018 IOP Publishing Ltd Modelling and Simulation in Materials Science and Engineering, Volume 26, Number 8\n\n@article{bromage2018calculating,\n  title={Calculating dislocation displacements on the surface of a volume},\n  author={Bromage, B and Tarleton, E},\n  journal={Modelling and Simulation in Materials Science and Engineering},\n  volume={26},\n  number={8},\npages={085007},\n  year={2018},\n  publisher={IOP Publishing}\n}\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.calc_σHat-Tuple{RegularCuboidMesh{T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28} where T28 where T27 where T26 where T25 where T24 where T23 where T22 where T21 where T20 where T19 where T18 where T17 where T16 where T15 where T14 where T13 where T12 where T11 where T10 where T9 where T8 where T7 where T6 where T5 where T4 where T3 where T2 where T1<:LinearElement,ForceDisplacement,Any}","page":"API","title":"DDD.calc_σHat","text":"calc_σHat(\n    mesh::RegularCuboidMesh{T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14} where {T1 <: LinearElement,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14},\n    forceDisplacement::ForceDisplacement,\n    x0,\n)\n\nCompute the stress, ̂σ, on a dislocation segment x0 as a result of body forces on a RegularCuboidMesh composed of LinearElement()(@ref). Used by calcPKForce.\n\nReturns\n\nσ = [\n        σxx σxy σxz\n        σxy σyy σyz\n        σxz σyz σzz\n    ]\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.calc_σTilde","page":"API","title":"DDD.calc_σTilde","text":"calc_σTilde(\n    x0,\n    dlnParams::DislocationParameters,\n    matParams::MaterialParameters,\n    network::DislocationNetwork,\n    idx = nothing,\n)\n\nComputes the stress tensor, ̃σ, induced by dislocations on points x0.\n\nReturns\n\nσxx = σ[1, :]\nσyy = σ[2, :]\nσzz = σ[3, :]\nσxy = σ[4, :]\nσxz = σ[5, :]\nσyz = σ[6, :]\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.calc_σTilde!","page":"API","title":"DDD.calc_σTilde!","text":"calc_σTilde!(\n    σ,\n    x0,\n    dlnParams::DislocationParameters,\n    matParams::MaterialParameters,\n    network::DislocationNetwork,\nidx = nothing,\n)\n\nIn-place computation of the stress tensor,̃σ, induced by dislocations on points x0.\n\nReturns\n\nσxx = σ[1, :]\nσyy = σ[2, :]\nσzz = σ[3, :]\nσxy = σ[4, :]\nσxz = σ[5, :]\nσyz = σ[6, :]\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.checkNetwork-Tuple{DislocationNetwork}","page":"API","title":"DDD.checkNetwork","text":"checkNetwork(network::DislocationNetwork)\n\nChecks the validity of the dislocation network. It ensures the following conditions are met by the member variables of network:\n\nconnectivity and links have the same number of non-zero entries;\nall entries in bVec are non-zero;\nonly the trailing columns of connectivity are zeros;\nconsistency between connectivity and links;\nbVec is conserved among connected nodes;\nentries in links are unique;\nconsistency betwen connectivity and linksConnect\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.coarsenNetwork!-Tuple{DislocationParameters,MaterialParameters,AbstractMesh,ForceDisplacement,DislocationNetwork}","page":"API","title":"DDD.coarsenNetwork!","text":"coarsenNetwork!(\n    dlnParams::DislocationParameters,\n    matParams::MaterialParameters,\n    mesh::AbstractMesh,\n    forceDisplacement::ForceDisplacement,\n    network::DislocationNetwork,\n)\n\nCoarsens network such that no links are smaller than the minimum allowable length and so that no two links form triangles with area under the minimum allowed.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.coarsenVirtualNetwork!-Tuple{DislocationParameters,DislocationNetwork}","page":"API","title":"DDD.coarsenVirtualNetwork!","text":"coarsenVirtualNetwork!(dlnParams::DislocationParameters, network::DislocationNetwork)\n\nCheck whether virtual nodes can be eliminated based on:\n\nIf they are not connected to any surface nodes\nIf they are not due to an angle change in the simulated volume surface\n\nBruce Bromage, Github @brucebromage Michromechanical Testing Group Department of Materials, University of Oxford bruce.bromage@materials.ox.ac.uk May 2017\n\nAdapted Jan 2021 Daniel Celis Garza, Github @dcelisgarza\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.compStruct-Tuple{Any,Any}","page":"API","title":"DDD.compStruct","text":"compStruct(arg1, arg2; verbose::Bool = false)\n\nCompares values of the fields of two variables arg1 and arg2 with the same structure. If verbose = true, it will print which fields are different from each other.\n\nExamples\n\njulia> struct MyStruct1; x; end\njulia> test1 = MyStruct1(1)\nMyStruct1(1)\njulia> test2 = MyStruct1(5)\nMyStruct1(5)\njulia> compStruct(test1, test2; verbose = true)\nStructures differ in field: x.\nfalse\njulia> compStruct(1, 1; verbose = true)\ntrue\njulia> compStruct(1, [1]; verbose = true)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.deriv!-Tuple{DislocationParameters,MaterialParameters,AbstractMesh,ForceDisplacement,DislocationNetwork}","page":"API","title":"DDD.deriv!","text":"deriv!(\n    dlnParams::DislocationParameters,\n    matParams::MaterialParameters,\n    mesh::AbstractMesh,\n    forceDisplacement::ForceDisplacement,\n    network::DislocationNetwork,\n)\n\nComputes the nodal velocities of a network.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.dlnMobility","page":"API","title":"DDD.dlnMobility","text":"dlnMobility(\n    dlnParams::DislocationParameters{T1,T2,T3,T4} where {T1 <: mobBCC,T2,T3,T4},\n    matParams::MaterialParameters,\n    network::DislocationNetwork,\n    idx = nothing,\n)\n\nCompute the nodal force and velocities for a BCC material.\n\nOriginal by Bruce Bromage at the Department of Materials of the University of Oxford, @brucebromage on github.\n\nThis is outdated, new capabilities include rotating the frame of reference and better handling of cross-slip.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.dlnMobility!","page":"API","title":"DDD.dlnMobility!","text":"dlnMobility!(\n    dlnParams::DislocationParameters{T1,T2,T3,T4} where {T1 <: mobBCC,T2,T3,T4},\n    matParams::MaterialParameters,\n    network::DislocationNetwork,\n    idx = nothing,\n)\n\nIn-place computation of the nodal force and velocities for a BCC material.\n\nOriginal by Bruce Bromage at the Department of Materials of the University of Oxford, @brucebromage on github.\n\nThis is outdated, new capabilities include rotating the frame of reference and better handling of cross-slip.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.externalAngle-Tuple{Int64}","page":"API","title":"DDD.externalAngle","text":"externalAngle(n::Int)\n\nCompute the exterior angle of a regular polygon with n sides.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.findConnectedNode-Tuple{DislocationNetwork,Any,Any}","page":"API","title":"DDD.findConnectedNode","text":"findConnectedNode(network::DislocationNetwork, node, connection)\n\nUse a node's connection to find the other node in the link. Returns a tuple with the link corresponding to the connection of node, the row of links the connected node appears, and the connected node. \n\nExamples\n\nWe want to find the node connected to node 5 via connection 3.\n\njulia> link, rowColLink, connectedNode = findConnectedNode(network, 5, 10)\njulia> link\n10\njulia> oppRowLink\n1\njulia> connectedNode\n25\n\nMeans that the link corresponding to connection 3 of node 5 is network.links[:, 10]; the node connected to node 5 is found on network.links[oppRowLink, 10] and is node 25, so the node we're looking for is network.links[oppRowLink, 10] == 25 and the node whose connection we are looking for is network.links[3-oppRowLink, 10] == 5. In this case oppRowLink == 1, so through its 3rd connection, node 5 is the second node on link 10, where it is connected to node 25.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.findIntersectVolume-Tuple{AbstractMesh,Any,Any}","page":"API","title":"DDD.findIntersectVolume","text":"findIntersectVolume(mesh::AbstractMesh, l, l0, tmpArr)\n\nFind the shortest intersecting distance between a vector l passing through the point l0 and an AbstractMesh.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.getSegmentIdx!-Tuple{DislocationNetwork}","page":"API","title":"DDD.getSegmentIdx!","text":"getSegmentIdx!(network::DislocationNetwork)\n\nMutates the segIdx matrix in network. Works the same way as getSegmentIdx.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.getSegmentIdx-Tuple{Any,Any}","page":"API","title":"DDD.getSegmentIdx","text":"getSegmentIdx(links, label)\n\nFinds the indices of a link and corresponding nodes.\n\nReturns\n\nn × 3 matrix is of the form [i, node1, node2]. \n\ni can be used to find the Burgers vector, slip plane and segment forces of segment i, eg bVec[:, i]. \nnode1 and node2 can be used to find the coordinate and velocity of the nodes, eg l = coord[:, node2] - coord[:, node1].\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.integrate!-Tuple{IntegrationParameters{T1,T2,T3,T4,T5,T6,T7,T8,T9,T10} where T10 where T9 where T8 where T7 where T6 where T5 where T4 where T3 where T2 where T1<:AdaptiveEulerTrapezoid,IntegrationTime,DislocationParameters,MaterialParameters,AbstractMesh,ForceDisplacement,DislocationNetwork}","page":"API","title":"DDD.integrate!","text":"integrate!(\n    intParams::IntegrationParameters{T1,T2,T3} where {T1 <: AdaptiveEulerTrapezoid,T2,T3},\n    intVars::IntegrationTime,\n    dlnParams::DislocationParameters,\n    matParams::MaterialParameters,\n    mesh::AbstractMesh,\n    forceDisplacement::ForceDisplacement,\n    network::DislocationNetwork,\n)\n\nIntegrates nodal velocities using a time-adaptive Euler-Trapezoid method.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.internalAngle-Tuple{Int64}","page":"API","title":"DDD.internalAngle","text":"internalAngle(n::Int)\n\nCompute the interior angle of a regular polygon with n sides.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.limits!-NTuple{4,Any}","page":"API","title":"DDD.limits!","text":"limits!(lims, segLen, range, buffer)\n\nCompute the bounding limits within which a DislocationLoop will be distributed in a DislocationNetwork.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.linePlaneIntersect-NTuple{4,Any}","page":"API","title":"DDD.linePlaneIntersect","text":"linePlaneIntersect(n::T, p0::T, l::T, l0::T) where {T <: AbstractVector}\n\nFinds the intersect between a line and a plane. n is the plane normal, p0 is a point on the plane, l is the line vector, l0 is a point on a line.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.loadBoundaries-Union{Tuple{Dict{T1,T2}}, Tuple{T2}, Tuple{T1}} where T2 where T1","page":"API","title":"DDD.loadBoundaries","text":"loadBoundaries(dict::Dict{T1,T2}) where {T1,T2}\n\nConstructs Boundaries out of a dictionary.\n\nnote: Note\ntK may be null if it was factorised when the variable was saved.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.loadDislocationLoop-Tuple{Dict{T1,T2} where T2 where T1,SlipSystem}","page":"API","title":"DDD.loadDislocationLoop","text":"loadDislocationLoop(dict::Dict{T1,T2} where {T1,T2}, slipSystem::SlipSystem)\n\nConstructs DislocationLoop out of a dictionary and SlipSystem structure.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.loadDislocationParameters-Union{Tuple{Dict{T1,T2}}, Tuple{T2}, Tuple{T1}} where T2 where T1","page":"API","title":"DDD.loadDislocationParameters","text":"loadDislocationParameters(dict::Dict{T1,T2}) where {T1,T2}\n\nConstructs DislocationParameters out of a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.loadFEMParameters-Union{Tuple{Dict{T1,T2}}, Tuple{T2}, Tuple{T1}} where T2 where T1","page":"API","title":"DDD.loadFEMParameters","text":"loadFEMParameters(dict::Dict{T1,T2}) where {T1,T2}\n\nConstructs FEMParameters out of a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.loadForceDisplacement-Union{Tuple{Dict{T1,T2}}, Tuple{T2}, Tuple{T1}} where T2 where T1","page":"API","title":"DDD.loadForceDisplacement","text":"loadForceDisplacement(dict::Dict{T1,T2}) where {T1,T2}\n\nConstructs ForceDisplacement out of a dictionary. It makes the arrays sparse and drops zeros under eps(Float64).\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.loadIntegrationParameters-Union{Tuple{Dict{T1,T2}}, Tuple{T2}, Tuple{T1}} where T2 where T1","page":"API","title":"DDD.loadIntegrationParameters","text":"loadIntegrationParameters(dict::Dict{T1,T2}) where {T1,T2}\n\nConstructs IntegrationParameters out of a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.loadIntegrationTime-Tuple{AbstractString}","page":"API","title":"DDD.loadIntegrationTime","text":"loadIntegrationTime(fileIntegrationTime::AbstractString)\n\nConstructs IntegrationTime from a JSON file.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.loadIntegrationTime-Union{Tuple{Dict{T1,T2}}, Tuple{T2}, Tuple{T1}} where T2 where T1","page":"API","title":"DDD.loadIntegrationTime","text":"loadIntegrationTime(dict::Dict{T1,T2}) where {T1,T2}\n\nConstructs IntegrationTime from a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.loadJSON-Tuple{AbstractString}","page":"API","title":"DDD.loadJSON","text":"loadJSON(filename::AbstractString)\n\nWrapper for JSON.parsefile(filename). Loads a JSON file as a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.loadMaterialParameters-Union{Tuple{Dict{T1,T2}}, Tuple{T2}, Tuple{T1}} where T2 where T1","page":"API","title":"DDD.loadMaterialParameters","text":"loadMaterialParameters(dict::Dict{T1, T2}) where {T1, T2}\n\nConstructs MaterialParameters out of a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.loadNetwork-Tuple{AbstractString}","page":"API","title":"DDD.loadNetwork","text":"loadNetwork(fileDislocationNetwork::AbstractString)\n\nConstructs DislocationNetwork from a JSON file.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.loadNetwork-Union{Tuple{Dict{T1,T2}}, Tuple{T2}, Tuple{T1}} where T2 where T1","page":"API","title":"DDD.loadNetwork","text":"loadNetwork(dict::Dict{T1,T2}) where {T1,T2}\n\nConstructs DislocationNetwork from a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.loadParameters-Union{Tuple{T}, NTuple{6,T}} where T<:AbstractString","page":"API","title":"DDD.loadParameters","text":"loadParameters(\n    fileDislocationParameters::T,\n    fileMaterialParameters::T,\n    fileFEMParameters::T,\n    fileIntegrationParameters::T,\n    fileSlipSystem::T,\n    fileDislocationLoop::T,\n) where {T <: AbstractString}\n\nConstructs simulation parameters, (DislocationParameters, MaterialParameters, FEMParameters, IntegrationParameters, SlipSystem, DislocationLoop) from JSON files.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.loadSlipSystem-Union{Tuple{Dict{T1,T2}}, Tuple{T2}, Tuple{T1}} where T2 where T1","page":"API","title":"DDD.loadSlipSystem","text":"loadSlipSystem(dict::Dict{T1,T2}) where {T1,T2}\n\nConstructs SlipSystem out of a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.loopDistribution-Tuple{Rand,Any,Vararg{Any,N} where N}","page":"API","title":"DDD.loopDistribution","text":"loopDistribution(::Rand, n, args...; kw...)\n\nReturns a 3 × n matrix whose points follow a random uniform distribution. Used by DislocationNetwork when the dist parameter of DislocationLoop is Rand().\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.loopDistribution-Tuple{Randn,Any,Vararg{Any,N} where N}","page":"API","title":"DDD.loopDistribution","text":"loopDistribution(::Rand, n, args...; kw...)\n\nReturns a 3 × n matrix whose points follow a random normal distribution. Used by DislocationNetwork when the dist parameter of DislocationLoop is Randn().\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.loopDistribution-Tuple{Regular,Any,Vararg{Any,N} where N}","page":"API","title":"DDD.loopDistribution","text":"loopDistribution(::Rand, n, args...; kw...)\n\nReturns a 3 × n matrix whose points follow are regularly placed. Used by DislocationNetwork when the dist parameter of DislocationLoop is Regular().\n\nnote: Note\nNot yet implemented.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.loopDistribution-Tuple{Zeros,Any,Vararg{Any,N} where N}","page":"API","title":"DDD.loopDistribution","text":"loopDistribution(::Zeros, n, args...; kw...)\n\nReturns a 3 × n zeros matrix. Used by DislocationNetwork when the dist parameter of DislocationLoop is Zeros().\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.makeConnect-Tuple{Any,Any}","page":"API","title":"DDD.makeConnect","text":"makeConnect(links, maxConnect)\nmakeConnect!(network::DislocationNetwork)\n\nCreates connectivity and linksConnect matrices for DislocationNetwork. \n\nconnectivity contains the number of other other nodes each node is connected to, up to maxConnect other nodes. Every (2i, j) entry contains a node connected to node j. Every (2i+1, j) coordinate contains whether that node is the first or second node in the link.\nlinksConnect relates connections enabled by a link. Analogous to the connectivity of a link.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.makeNetwork!-Tuple{Any,Any,Any,Any,Any,Any,Any,Any,Vararg{Any,N} where N}","page":"API","title":"DDD.makeNetwork!","text":"makeNetwork!(\n    links,\n    slipPlane,\n    bVec,\n    coord,\n    label,\n    sources,\n    lims,\n    initIdx,\n    args...;\n    kw...,\n)\n\nInternal function called by DislocationNetwork to fill the arrays that define the network.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.makeSegment-Tuple{DDD.segEdge,Any,Any}","page":"API","title":"DDD.makeSegment","text":"makeSegment(::segEdge, slipPlane, bVec)\n\nReturn the edge segment (slipPlane × bVec) / || slipPlane × bVec ||. Used to create segments for DislocationNetwork.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.makeSegment-Tuple{DDD.segEdgeN,Any,Any}","page":"API","title":"DDD.makeSegment","text":"makeSegment(::segEdge, slipPlane, bVec)\n\nReturn the edge segment slipPlane / || slipPlane ||. Used to create segments for DislocationNetwork.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.makeSegment-Tuple{DDD.segScrew,Any,Any}","page":"API","title":"DDD.makeSegment","text":"makeSegment(::segScrew, slipPlane, bVec)\n\nReturn the screw segment bVec / || bVec ||. Used to create segments for DislocationNetwork.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.makeSurfaceNode!-Tuple{AbstractMesh,DislocationNetwork,Any,Any,Any}","page":"API","title":"DDD.makeSurfaceNode!","text":"makeSurfaceNode!(mesh::AbstractMesh,  network::DislocationNetwork, node1, node2, idx)\n\nCreates a surface node between node1 and node2, using connection idx of node1 of a DislocationNetwork on the surface of an AbstractMesh\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.mergeNode!-Tuple{DislocationNetwork,Any,Any}","page":"API","title":"DDD.mergeNode!","text":"mergeNode!(network::DislocationNetwork, nodeKept, nodeGone)\n\nMerges nodeGone into nodeKept.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.minimumDistance-NTuple{8,Any}","page":"API","title":"DDD.minimumDistance","text":"minimumDistance(x0, x1, y0, y1, vx0, vx1, vy0, vy1)\n\nCalculates the minimum distance between two segments seg1 = x0 → x1, seg2 = y0 → y1.\n\nReturns\n\ndistSq: minimum distance squared between L1 and L2.\ndDistSqDt: rate of change with respect to time of the minimum distance squared between L1 and L2.\nL1: normalised position on seg1 that is closest to seg2.\nL2: normalised position on seg2 that is closest to seg1.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.plotFEDomain-Tuple{AbstractMesh,Vararg{Any,N} where N}","page":"API","title":"DDD.plotFEDomain","text":"plotFEDomain(mesh::AbstractMesh)\n\nPlots corners, edges and surfaces of AbstractMesh.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.plotNodes!-Tuple{Any,DislocationLoop,Vararg{Any,N} where N}","page":"API","title":"DDD.plotNodes!","text":"plotNodes!(fig, loop::DislocationLoop, args...; kw...)\n\nIn-place plots DislocationLoop.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.plotNodes!-Tuple{Any,DislocationNetwork,Vararg{Any,N} where N}","page":"API","title":"DDD.plotNodes!","text":"plotNodes!(fig, network::DislocationNetwork, args...; kw...)\n\nIn-place plots DislocationNetwork.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.plotNodes!-Union{Tuple{T1}, Tuple{Any,T1,DislocationNetwork,Vararg{Any,N} where N}} where T1<:AbstractMesh","page":"API","title":"DDD.plotNodes!","text":"plotNodes!(fig, mesh::AbstractMesh, network::DislocationNetwork, args...; kw...)\n\nIn-place plots DislocationNetwork inside AbstractMesh.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.plotNodes-Tuple{AbstractMesh,DislocationNetwork,Vararg{Any,N} where N}","page":"API","title":"DDD.plotNodes","text":"plotNodes(mesh::AbstractMesh, network::DislocationNetwork, args...; kw...)\n\nPlots DislocationNetwork inside AbstractMesh.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.plotNodes-Tuple{DislocationLoop,Vararg{Any,N} where N}","page":"API","title":"DDD.plotNodes","text":"plotNodes(loop::DislocationLoop, args...; kw...)\n\nPlots DislocationLoop.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.plotNodes-Tuple{DislocationNetwork,Vararg{Any,N} where N}","page":"API","title":"DDD.plotNodes","text":"plotNodes(network::DislocationNetwork, args...; kw...)\n\nPlots DislocationNetwork.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.refineNetwork!-Tuple{DislocationParameters,MaterialParameters,AbstractMesh,ForceDisplacement,DislocationNetwork}","page":"API","title":"DDD.refineNetwork!","text":"refineNetwork!(\n    dlnParams::DislocationParameters,\n    matParams::MaterialParameters,\n    mesh::AbstractMesh,\n    forceDisplacement::ForceDisplacement,\n    network::DislocationNetwork,\n)\n\nRefines a dislocation network to ensure all the segments are shorter than the maximum allowable length and so no two links form a triangle with an area over the maximum allowed.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.remeshSurfaceNetwork!-Tuple{AbstractMesh,Boundaries,DislocationNetwork}","page":"API","title":"DDD.remeshSurfaceNetwork!","text":"remeshSurfaceNetwork!(mesh::AbstractMesh, boundaries::Boundaries, network::DislocationNetwork)\n\nRemeshes a DislocationNetwork's nodes on the surface of an AbstractMesh.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.rot3D-NTuple{4,Any}","page":"API","title":"DDD.rot3D","text":"rot3D(xyz, uvw, abc, θ)\n\nRotate point xyz about the vector uvw that crosses point abc by the angle θ. Further details found here.\n\nExamples\n\njulia> rot3D([1;1;1],[1;0;0],[0;0;0],π/2)\n3-element Array{Float64,1}:\n  1.0\n -0.9999999999999999\n  1.0\njulia> rot3D([1;1;1],[1;0;0],[0;0;0],-π/2)\n3-element Array{Float64,1}:\n1.0\n1.0\n-0.9999999999999999\njulia> rot3D([1;1;1],[1;0;0],[0;0;0],π)\n3-element Array{Float64,1}:\n  1.0\n -1.0000000000000002\n -0.9999999999999999\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.safeNorm-Tuple{Any}","page":"API","title":"DDD.safeNorm","text":"safeNorm(x)\n\nSafe normalisation.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.saveJSON-Tuple{AbstractString,Vararg{Any,N} where N}","page":"API","title":"DDD.saveJSON","text":"saveJSON(filename::AbstractString, args...; mode::AbstractString = \"w\")\n\nWrapper for JSON.print.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.shapeFunction-Tuple{LinearQuadrangle3D,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T}","page":"API","title":"DDD.shapeFunction","text":"shapeFunction(::LinearQuadrangle3D, x::AbstractVector, y::AbstractVector, z::AbstractVector)\n\nComputes the linear shape functions N[1:8][p] for (x, y, z) point p on a 3D linear quadrangle.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.shapeFunction-Tuple{LinearQuadrangle3D,Any,Any,Any}","page":"API","title":"DDD.shapeFunction","text":"shapeFunction(::LinearQuadrangle3D, x, y, z)\n\nComputes the linear shape functions N[1:8] for an (x, y, z) point on a 3D linear quadrangle.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.shapeFunctionDeriv-Tuple{LinearQuadrangle3D,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T}","page":"API","title":"DDD.shapeFunctionDeriv","text":"shapeFunctionDeriv(shape<:AbstractShapeFunction, x::AbstractVector, y::AbstractVector, z::AbstractVector)\n\nComputes the derivatives of the linear shape functions N[1:3, 1:8] for an (x, y, z) point on a 3D linear quadrangle.\n\nReturns\n\ndNdS[x, n, p](x,y,z) := x'th derivative of shape function n for point p.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.shapeFunctionDeriv-Tuple{LinearQuadrangle3D,Any,Any,Any}","page":"API","title":"DDD.shapeFunctionDeriv","text":"shapeFunctionDeriv(shape<:AbstractShapeFunction, x, y, z)\n\nComputes the derivatives of the linear shape functions N[1:3, 1:8] for an (x, y, z) point on a 3D linear quadrangle.\n\nReturns\n\ndNdS[x, n](x,y,z) := x'th derivative of shape function n.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.splitNode!-Tuple{DislocationNetwork,Any,Any,Any,Any}","page":"API","title":"DDD.splitNode!","text":"splitNode!(network::DislocationNetwork, splitNode, splitConnect, midCoord, midVel)\n\nSplits node splitNode along connection splitConnect, puts it at coordinate midCoord with velocity midVel. If it is called from within refineNetwork!, midCoord and midVel are the coordinate between splitNode and the node connected to it via splitConnect and gives it the mean velocity of the two nodes.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.translatePoints!-Tuple{Any,Any,Any}","page":"API","title":"DDD.translatePoints!","text":"translatePoints!(coord, lims, disp)\n\nTranslates coordinates using the limits and displacements calculated by limits! and loopDistribution.\n\n\n\n\n\n","category":"method"},{"location":"api/#FastGaussQuadrature.gausslegendre-Tuple{Integer,Any,Any}","page":"API","title":"FastGaussQuadrature.gausslegendre","text":"gausslegendre(n::Integer, a, b)\n\nCompute Gauss-Legendre quadrature points and weights for the interval [a, b].\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.inclusiveComparison-Tuple{Any,Vararg{Any,N} where N}","page":"API","title":"DDD.inclusiveComparison","text":"inclusiveComparison(data, args...)::Bool\n\nCompare data to a tuple, return true if it is equal to any arg, false if it is not equal to any.\n\nExamples\n\njulia> inclusiveComparison(\"f\", 1,4,5,\"f\")\ntrue\njulia> inclusiveComparison(23.246, 1.5, 4, 5, \"f\")\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.makeInstanceDict-Tuple{DataType}","page":"API","title":"DDD.makeInstanceDict","text":"makeInstanceDict(valType::DataType)\n\nMake a dictionary of enumerated variable instances. Helps in translating JSON files.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.makeTypeDict-Tuple{DataType}","page":"API","title":"DDD.makeTypeDict","text":"makeTypeDict(valType::DataType)\n\nInputs contain strings that correspond to DDD data types. This function atuomatically creates a dictionary for all concrete subtypes of a given valType.\n\nExamples\n\njulia> abstract type MyAbstractType end\njulia> struct MyStruct1 <: MyAbstractType end\njulia> struct MyStruct2 <: MyAbstractType end\njulia> makeTypeDict(MyAbstractType)\nDict{String,Any} with 4 entries:\n  \"DDD.MyStruct1()\" => MyStruct1()\n  \"DDD.MyStruct2()\" => MyStruct2()\n  \"MyStruct1()\"     => MyStruct1()\n  \"MyStruct2()\"     => MyStruct2()\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.removeConnection!-Tuple{DislocationNetwork,Any,Any}","page":"API","title":"DDD.removeConnection!","text":"removeConnection!(network::DislocationNetwork, nodeKept, connectGone)\n\nRemoves connection connectGone from nodeKept.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.removeLink!","page":"API","title":"DDD.removeLink!","text":"removeLink!(network::DislocationNetwork, linkGone, lastLink = nothing)\n\nRemoves link linkGone and uses lastLink to reoganise the network.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.removeNode!","page":"API","title":"DDD.removeNode!","text":"removeNode!(network::DislocationNetwork, nodeGone, lastNode = nothing)\n\nRemoves node nodeGone from network.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.subTypeTree-Tuple{Any}","page":"API","title":"DDD.subTypeTree","text":"subTypeTree(t; dict = Dict(), level = 1, cutoff = 0)\n\nCreate subtype dictionary. Adapted from https://github.com/JuliaLang/julia/issues/24741\n\n\n\n\n\n","category":"method"},{"location":"api/#JSON.Writer.lower-Union{Tuple{T}, Tuple{T}} where T<:Union{CantileverLoad, DispatchRegularCuboidMesh, LinearElement, AbstractCrystalStruct, AbstractDistribution, AbstractDlnSeg, AbstractDlnStr, AbstractIntegrator, AbstractMobility}","page":"API","title":"JSON.Writer.lower","text":"JSON.lower(\n    t::T,\n) where {\n    T <: Union{\n        AbstractCrystalStruct,\n        AbstractMobility,\n        AbstractIntegrator,\n        AbstractDlnSeg,\n        AbstractDlnStr,\n        AbstractDistribution,\n    },\n}\n\nJSON.lower(t::nodeTypeDln)\n\nExtensions to JSON.lower for custom types. Allows these variables to be serialised properly.\n\n\n\n\n\n","category":"method"},{"location":"#DDD-1","page":"Home","title":"DDD","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"(Image: Dev) (Image: Build Status) (Image: Build Status) (Image: Codecov) (Image: Coveralls) (Image: Binder)","category":"page"},{"location":"#Index-1","page":"Home","title":"Index","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"}]
}
