var documenterSearchIndex = {"docs":
[{"location":"Types/#Types-1","page":"Types","title":"Types","text":"","category":"section"},{"location":"Types/#","page":"Types","title":"Types","text":"DDD.jl makes extensive use of Julia's type system to provide a performant and user-error proof dislocation plasticity simulations.","category":"page"},{"location":"Types/#Primitive-Types-1","page":"Types","title":"Primitive Types","text":"","category":"section"},{"location":"Types/#","page":"Types","title":"Types","text":"nodeType","category":"page"},{"location":"Types/#DDD.nodeType","page":"Types","title":"DDD.nodeType","text":"@enum nodeType begin\n    none = 0    # Undefined node, value at initialisation.\n    intMob = 1  # Internal mobile node.\n    intFix = 2  # Internal fixed node.\n    srfMob = 3  # Mobile surface node.\n    srfFix = 4  # Fixed surface node.\n    ext = 5     # External node.\n    tmp = 6     # Temporary flag, used during topological operations.\nend\n\nDifferent types of nodes behave differently. There are only a finite number of them so an enumerated type provides safety and efficiency. Each value represents a different type of node and therefore its behaviour.\n\nMeaning\n\nnone are uninitialised nodes.\nintMob are mobile nodes internal to the convex hull of the domain. They take part in tractions, displacements and dislocation interactions.\nintFix are fixed nodes internal to the convex hull of the domain. They participate in the same way as intMob nodes except for the fact that their velocities is fixed are zero.\nsrfMob are mobile nodes that live on the surface of the convex hull of the domain, they are used to track slip steps and therefore participate in the same things as internal nodes but their velocities are restricted to the convex hull surface.\nsrfFix are fixed surface nodes and have the same characteristics as mobile surface nodes except for having zero velocity.\next are external nodes that do not participate in dislocation interactions or forces but are used to calculate displacements and track slip steps.\ntmp are nodes that are temporarily flagged before they are assigned another type.\n\n\n\n\n\n","category":"type"},{"location":"Types/#","page":"Types","title":"Types","text":"AbstractDlnSeg","category":"page"},{"location":"Types/#DDD.AbstractDlnSeg","page":"Types","title":"DDD.AbstractDlnSeg","text":"abstract type AbstractDlnSeg end\nstruct segNone <: AbstractDlnSeg end    # Undefined segment\nstruct segEdge <: AbstractDlnSeg end    # Edge segment\nstruct segEdgeN <: AbstractDlnSeg end   # Edge segment\nstruct segScrew <: AbstractDlnSeg end   # Screw segment\nstruct segMixed <: AbstractDlnSeg end   # Mixed segment\n\nThese types are used to automatically generate segments out of Burgers vectors bmb, slip planes bmn, and/or line direction bml.\n\nMeaning\n\nsegEdge have bmb  bmt ,\nsegEdgeN have bmb  bmt and bmb  bmn ,\nsegScrew have bmb  bmt ,\nsegMixed have none of the above.\n\n\n\n\n\n","category":"type"},{"location":"Types/#","page":"Types","title":"Types","text":"AbstractDlnStr","category":"page"},{"location":"Types/#DDD.AbstractDlnStr","page":"Types","title":"DDD.AbstractDlnStr","text":"abstract type AbstractDlnStr end\nstruct loopPrism <: AbstractDlnStr end\nstruct loopShear <: AbstractDlnStr end\nconst loopPure = Union{loopPrism,loopShear}\nstruct loopMixed <: AbstractDlnStr end\nstruct loopJog <: AbstractDlnStr end\nstruct loopKink <: AbstractDlnStr end\nconst loopImpure = Union{loopMixed,loopJog,loopKink}\nconst loopDefined = Union{loopPrism,loopShear,loopMixed,loopJog,loopKink}\nstruct loopDln <: AbstractDlnStr end\n\nThese types are used to automatically generate dislocation loops for simulation initialisation.\n\nMeaning\n\nloopPrism are prismatic loops, their Burgers vectors are perpendicular to the their line direction. They are idealised loops that can be automatically generated as n-gons.\nloopShear are shear loops, their line direction goes through edge, screw and line segments as the loop goes round. They are idealised loops that can be automatically generated as n-gons.\nloopPure are idealised loops.\nloopMixed are loops with prismatic and shear character. They have to be hand-made or require a heuristic to automatically generate.\nloopDln is a generic loop used for adding methods to Base functions.\nloopKink and loopJog are structures formed by colliding dislocations. They are not currently used.\nloopImpure are non-idealised loops.\nloopDefined are defined loop types.\n\n\n\n\n\n","category":"type"},{"location":"Types/#","page":"Types","title":"Types","text":"AbstractDistribution","category":"page"},{"location":"Types/#DDD.AbstractDistribution","page":"Types","title":"DDD.AbstractDistribution","text":"abstract type AbstractDistribution end\nstruct Zeros <: AbstractDistribution end\nstruct Rand <: AbstractDistribution end\nstruct Randn <: AbstractDistribution end\nstruct Regular <: AbstractDistribution end\n\nSpatial distributions for dislocation sources. These are used to automatically generate networks with a given distribution.\n\nMeaning\n\nZeros makes the network generation functions place the center of the generated dislocation loops at the origin. This can be used to generate a network and loops can be manually or pseudo-manually distributed in the domain.\nRand makes the network generation functions uniformly distribute the dislocations according to the range and buffer values in the dislocation loop structure.\nRand makes the network generation functions normally distribute the dislocations according to the range and buffer values in the dislocation loop structure.\nRand TBA, will regularly distribute dislocations according to the range, buffer and other args given to the dislocation network generator.\n\n\n\n\n\n","category":"type"},{"location":"Types/#","page":"Types","title":"Types","text":"AbstractMobility","category":"page"},{"location":"Types/#DDD.AbstractMobility","page":"Types","title":"DDD.AbstractMobility","text":"abstract type AbstractMobility end\nstruct mobBCC <: AbstractMobility end\nstruct mobFCC <: AbstractMobility end\nstruct mobHCP <: AbstractMobility end\n\nTypes to dispatch different mobility functions.\n\nMeaning\n\nmobBCC is used to dispatch the default BCC mobility function.\nmobFCC is used to dispatch the default FCC mobility function.\nmobHCP is used to dispatch the default HCP mobility function.\n\n\n\n\n\n","category":"type"},{"location":"Types/#Storage-Structures-1","page":"Types","title":"Storage Structures","text":"","category":"section"},{"location":"Types/#","page":"Types","title":"Types","text":"SlipSystem","category":"page"},{"location":"Types/#DDD.SlipSystem","page":"Types","title":"DDD.SlipSystem","text":"struct SlipSystem{T1, T2}\n    crystalStruct::T1   # Crystal structure\n    slipPlane::T2       # Slip plane\n    bVec::T2            # Burgers vector\nend\n\nStores slip systems. \n\n\n\n\n\n","category":"type"},{"location":"Types/#","page":"Types","title":"Types","text":"DislocationParameters","category":"page"},{"location":"Types/#DDD.DislocationParameters","page":"Types","title":"DDD.DislocationParameters","text":"struct DislocationParameters{T1,T2,T3,T4}\n    coreRad::T1         # Dislocation core radius.\n    coreRadSq::T1       # Square of the dislocation core radius.\n    coreRadMag::T1      # Magnitude of the core radius (real units for post-processing).\n    minSegLen::T1       # Minimum segment length.\n    maxSegLen::T1       # Maximum segment length.\n    twoMinSegLen::T1    # Twice the minimum segment length.\n    minArea::T1         # Minimum area for remeshing.\n    maxArea::T1         # Maximum area for remeshing.\n    minAreaSq::T1       # Square of the minimum area.\n    maxAreaSq::T1       # Square of the maximum area.\n    edgeDrag::T1        # Edge drag coefficient.\n    screwDrag::T1       # Screw drag coefficient.\n    climbDrag::T1       # Climb drag coefficient.\n    lineDrag::T1        # Line drag coefficient.\n    maxConnect::T2      # Maximum connectivity of nodes.\n    mobility::T3        # Dislocation mobility.\n    remesh::T4          # Remesh flag.\n    collision::T4       # Collision flag.\n    separation::T4      # Separation flag.\n    virtualRemesh::T4   # Virtual remeshing flag.\n    parCPU::T4          # Parallelise on CPU flag.\n    parGPU::T4          # Parallelise on GPU flag.\n    slipStepCritLen::T1 # Critical length for slip step tracking.\n    slipStepCritArea::T1    # Critical area for slip step tracking.\nend\n\nStores the dislocation parameters.\n\n\n\n\n\n","category":"type"},{"location":"Types/#","page":"Types","title":"Types","text":"DislocationLoop","category":"page"},{"location":"Types/#DDD.DislocationLoop","page":"Types","title":"DDD.DislocationLoop","text":"struct DislocationLoop{T1,T2,T3,T4,T5,T6,T7,T8,T9,T10}\n    loopType::T1    # Loop type.\n    numSides::T2    # Number of sides in the loop.\n    nodeSide::T2    # Nodes per side of the loop.\n    numLoops::T2    # Number of loops to generate when making the network.\n    segLen::T3      # Segment lengths.\n    slipSystem::T4  # Slip system.\n    links::T5       # Links.\n    slipPlane::T6   # Slip planes.\n    bVec::T6        # Burgers vectors.\n    coord::T6       # Coordinates.\n    label::T7       # Node labels.\n    buffer::T8      # Buffer for distributions.\n    range::T9       # Range for distributions.\n    dist::T10       # Distribution.\nend\n\nStores a dislocation loop and parameters used to generate a DislocationNetwork.\n\n\n\n\n\n","category":"type"},{"location":"Types/#","page":"Types","title":"Types","text":"DislocationNetwork","category":"page"},{"location":"Types/#DDD.DislocationNetwork","page":"Types","title":"DDD.DislocationNetwork","text":"struct DislocationNetwork{T1,T2,T3,T4,T5,T6}\n    links::T1\n    slipPlane::T2\n    bVec::T2\n    coord::T2\n    label::T3\n    nodeVel::T2\n    nodeForce::T2\n    numNode::T4\n    numSeg::T4\n    maxConnect::T5\n    connectivity::T1\n    linksConnect::T1\n    segIdx::T1\n    segForce::T6\nend\n\nStores the dislocation network generated from DislocationLoop.\n\n\n\n\n\n","category":"type"},{"location":"Constructors/#Constructors-1","page":"Constructors","title":"Constructors","text":"","category":"section"},{"location":"Constructors/#","page":"Constructors","title":"Constructors","text":"SlipSystem(crystalStruct::T1, slipPlane::T2, bVec::T2) where {T1 <: AbstractCrystalStruct,T2}","category":"page"},{"location":"Constructors/#DDD.SlipSystem-Union{Tuple{T2}, Tuple{T1}, Tuple{T1,T2,T2}} where T2 where T1<:AbstractCrystalStruct","page":"Constructors","title":"DDD.SlipSystem","text":"SlipSystem(crystalStruct::T1, slipPlane::T2, bVec::T2) \n    where {T1 <: AbstractCrystalStruct,T2}\n\nConstructor for SlipSystem. Checks for orthogonality of the burgers vector and slip plane. It assumes each column corresponds to a slip system.\n\n\n\n\n\n","category":"method"},{"location":"Constructors/#","page":"Constructors","title":"Constructors","text":"SlipSystem(;crystalStruct::T1, slipPlane::T2, bVec::T2) \n    where {T1 <: AbstractCrystalStruct,T2}","category":"page"},{"location":"Constructors/#DDD.SlipSystem-Tuple{}","page":"Constructors","title":"DDD.SlipSystem","text":"SlipSystem(; crystalStruct::T1, slipPlane::T2, bVec::T2) \n    where {T1 <: AbstractCrystalStruct,T2}\n\nKeyword constructor for SlipSystem.\n\n\n\n\n\n","category":"method"},{"location":"Constructors/#","page":"Constructors","title":"Constructors","text":"DislocationParameters(\n    coreRad::T1,\n    coreRadMag::T1,\n    minSegLen::T1,\n    maxSegLen::T1,\n    minArea::T1,\n    maxArea::T1,\n    edgeDrag::T1,\n    screwDrag::T1,\n    climbDrag::T1,\n    lineDrag::T1,\n    maxConnect::T2,\n    mobility::T3,\n    remesh::T4 = true,\n    collision::T4 = true,\n    separation::T4 = true,\n    virtualRemesh::T4 = true,\n    parCPU::T4 = false,\n    parGPU::T4 = false,\n    slipStepCritLen::T1 = maxSegLen / 2,\n    slipStepCritArea::T1 = 0.5 * (slipStepCritLen^2) * sin(2 * π / 360),\n) where {T1,T2 <: Int,T3 <: AbstractMobility,T4 <: Bool}","category":"page"},{"location":"Constructors/#DDD.DislocationParameters-Union{Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T2,T3}, Tuple{T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T2,T3,T4}, Tuple{T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T2,T3,T4,T4}, Tuple{T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T2,T3,T4,T4,T4}, Tuple{T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T2,T3,T4,T4,T4,T4}, Tuple{T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T2,T3,T4,T4,T4,T4,T4}, Tuple{T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T2,T3,T4,T4,T4,T4,T4,T4}, Tuple{T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T2,T3,T4,T4,T4,T4,T4,T4,T1}, Tuple{T1,T1,T1,T1,T1,T1,T1,T1,T1,T1,T2,T3,T4,T4,T4,T4,T4,T4,T1,T1}} where T4<:Bool where T3<:AbstractMobility where T2<:Int64 where T1","page":"Constructors","title":"DDD.DislocationParameters","text":"DislocationParameters(\n    coreRad::T1,\n    coreRadMag::T1,\n    minSegLen::T1,\n    maxSegLen::T1,\n    minArea::T1,\n    maxArea::T1,\n    edgeDrag::T1,\n    screwDrag::T1,\n    climbDrag::T1,\n    lineDrag::T1,\n    maxConnect::T2,\n    mobility::T3,\n    remesh::T4 = true,\n    collision::T4 = true,\n    separation::T4 = true,\n    virtualRemesh::T4 = true,\n    parCPU::T4 = false,\n    parGPU::T4 = false,\n    slipStepCritLen::T1 = maxSegLen / 2,\n    slipStepCritArea::T1 = 0.5 * (slipStepCritLen^2) * sin(2 * π / 360),\n) where {T1,T2 <: Int,T3 <: AbstractMobility,T4 <: Bool}\n\nThe constructor for DislocationParameters provides a few default values and calculates derived quantities.\n\n\n\n\n\n","category":"method"},{"location":"Constructors/#","page":"Constructors","title":"Constructors","text":"DislocationParameters(;\n    coreRad::T1,\n    coreRadMag::T1,\n    minSegLen::T1,\n    maxSegLen::T1,\n    minArea::T1,\n    maxArea::T1,\n    edgeDrag::T1,\n    screwDrag::T1,\n    climbDrag::T1,\n    lineDrag::T1,\n    maxConnect::T2,\n    mobility::T3,\n    remesh::T4 = true,\n    collision::T4 = true,\n    separation::T4 = true,\n    virtualRemesh::T4 = true,\n    parCPU::T4 = false,\n    parGPU::T4 = false,\n    slipStepCritLen::T1 = maxSegLen / 2,\n    slipStepCritArea::T1 = 0.5 * (slipStepCritLen^2) * sin(2 * π / 360),\n) where {T1,T2 <: Int,T3 <: AbstractMobility,T4 <: Bool}","category":"page"},{"location":"Constructors/#DDD.DislocationParameters-Union{Tuple{}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}} where T4<:Bool where T3<:AbstractMobility where T2<:Int64 where T1","page":"Constructors","title":"DDD.DislocationParameters","text":"DislocationParameters(;\n    coreRad::T1,\n    coreRadMag::T1,\n    minSegLen::T1,\n    maxSegLen::T1,\n    minArea::T1,\n    maxArea::T1,\n    edgeDrag::T1,\n    screwDrag::T1,\n    climbDrag::T1,\n    lineDrag::T1,\n    maxConnect::T2,\n    mobility::T3,\n    remesh::T4 = true,\n    collision::T4 = true,\n    separation::T4 = true,\n    virtualRemesh::T4 = true,\n    parCPU::T4 = false,\n    parGPU::T4 = false,\n    slipStepCritLen::T1 = maxSegLen / 2,\n    slipStepCritArea::T1 = 0.5 * (slipStepCritLen^2) * sin(2 * π / 360),\n) where {T1,T2 <: Int,T3 <: AbstractMobility,T4 <: Bool}\n\nKeyword constructor for DislocationParameters. Calls the positional constructor internally.\n\n\n\n\n\n","category":"method"},{"location":"Constructors/#","page":"Constructors","title":"Constructors","text":"DislocationLoop(\n    loopType::T1,\n    numSides::T2,\n    nodeSide::T2,\n    numLoops::T2,\n    segLen,\n    slipSystem::T2,\n    _slipPlane,\n    _bVec,\n    label::T3,\n    buffer,\n    range,\n    dist::T4,\n) where {\n    T1 <: AbstractDlnStr,\n    T2 <: Int,\n    T3 <: AbstractVector{nodeType},\n    T4 <: AbstractDistribution,\n}","category":"page"},{"location":"Constructors/#DDD.DislocationLoop-Union{Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T2,T2,T2,Any,T2,Any,Any,T3,Any,Any,T4}} where T4<:AbstractDistribution where T3<:AbstractArray{nodeType,1} where T2<:Int64 where T1<:AbstractDlnStr","page":"Constructors","title":"DDD.DislocationLoop","text":"DislocationLoop(\n    loopType::T1,\n    numSides::T2,\n    nodeSide::T2,\n    numLoops::T2,\n    segLen,\n    slipSystem::T2,\n    _slipPlane,\n    _bVec,\n    label::T3,\n    buffer,\n    range,\n    dist::T4,\n) where {\n    T1 <: AbstractDlnStr,\n    T2 <: Int,\n    T3 <: AbstractVector{nodeType},\n    T4 <: AbstractDistribution,\n}\n\nGeneral constructor for DislocationLoop.\n\n\n\n\n\n","category":"method"},{"location":"Constructors/#","page":"Constructors","title":"Constructors","text":"DislocationLoop(\n    loopType::T1,\n    numSides::T2,\n    nodeSide::T2,\n    numLoops::T2,\n    segLen,\n    slipSystem::T2,\n    _slipPlane::T3,\n    _bVec::T3,\n    label::T4,\n    buffer,\n    range,\n    dist::T5,\n) where {\n    T1 <: loopPure,\n    T2 <: Int,\n    T3 <: AbstractArray{T,N} where {T,N},\n    T4 <: AbstractVector{nodeType},\n    T5 <: AbstractDistribution,\n}","category":"page"},{"location":"Constructors/#DDD.DislocationLoop-Union{Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T2,T2,T2,Any,T2,T3,T3,T4,Any,Any,T5}} where T5<:AbstractDistribution where T4<:AbstractArray{nodeType,1} where T3<:(AbstractArray{T,N} where N where T) where T2<:Int64 where T1<:Union{loopPrism, loopShear}","page":"Constructors","title":"DDD.DislocationLoop","text":"DislocationLoop(\n    loopType::T1,\n    numSides::T2,\n    nodeSide::T2,\n    numLoops::T2,\n    segLen,\n    slipSystem::T2,\n    _slipPlane::T3,\n    _bVec::T3,\n    label::T4,\n    buffer,\n    range,\n    dist::T5,\n) where {\n    T1 <: loopPure,\n    T2 <: Int,\n    T3 <: AbstractArray{T,N} where {T,N},\n    T4 <: AbstractVector{nodeType},\n    T5 <: AbstractDistribution,\n}\n\nConstructor for loopPure loops DislocationLoop.\n\n\n\n\n\n","category":"method"},{"location":"Constructors/#","page":"Constructors","title":"Constructors","text":"DislocationLoop(\n    loopType::T1,\n    numSides::T2,\n    nodeSide::T2,\n    numLoops::T2,\n    segLen,\n    slipSystem::T2,\n    _slipPlane::T3,\n    _bVec::T3,\n    label::T4,\n    buffer,\n    range,\n    dist::T5,\n) where {\n    T1 <: loopImpure,\n    T2 <: Int,\n    T3 <: AbstractArray{T,N} where {T,N},\n    T4 <: AbstractVector{nodeType},\n    T5 <: AbstractDistribution,\n}","category":"page"},{"location":"Constructors/#DDD.DislocationLoop-Union{Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T2,T2,T2,Any,T2,T3,T3,T4,Any,Any,T5}} where T5<:AbstractDistribution where T4<:AbstractArray{nodeType,1} where T3<:(AbstractArray{T,N} where N where T) where T2<:Int64 where T1<:Union{DDD.loopJog, DDD.loopKink, DDD.loopMixed}","page":"Constructors","title":"DDD.DislocationLoop","text":"DislocationLoop(\n    loopType::T1,\n    numSides::T2,\n    nodeSide::T2,\n    numLoops::T2,\n    segLen,\n    slipSystem::T2,\n    _slipPlane::T3,\n    _bVec::T3,\n    label::T4,\n    buffer,\n    range,\n    dist::T5,\n) where {\n    T1 <: loopImpure,\n    T2 <: Int,\n    T3 <: AbstractArray{T,N} where {T,N},\n    T4 <: AbstractVector{nodeType},\n    T5 <: AbstractDistribution,\n}\n\nA fallback DislocationLoop constructor for other as of yet unimplemented loopType.\n\n\n\n\n\n","category":"method"},{"location":"Constructors/#","page":"Constructors","title":"Constructors","text":"DislocationLoop(;\n    loopType::T1,\n    numSides::T2,\n    nodeSide::T2,\n    numLoops::T2,\n    segLen::T3,\n    slipSystem::T2,\n    _slipPlane::T4,\n    _bVec::T4,\n    label::T5,\n    buffer::T6,\n    range::T7,\n    dist::T8,\n) where {\n    T1 <: AbstractDlnStr,\n    T2 <: Int,\n    T3 <: Union{T where {T},AbstractArray{T,N} where {T,N}},\n    T4 <: AbstractArray{T,N} where {T,N},\n    T5 <: AbstractVector{nodeType},\n    T6,\n    T7 <: AbstractArray{T,N} where {T,N},\n    T8 <: AbstractDistribution,\n}","category":"page"},{"location":"Constructors/#DDD.DislocationLoop-Union{Tuple{}, Tuple{T8}, Tuple{T7}, Tuple{T6}, Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}} where T8<:AbstractDistribution where T7<:(AbstractArray{T,N} where N where T) where T6 where T5<:AbstractArray{nodeType,1} where T4<:(AbstractArray{T,N} where N where T) where T3 where T2<:Int64 where T1<:AbstractDlnStr","page":"Constructors","title":"DDD.DislocationLoop","text":"DislocationLoop(;\n    loopType::T1,\n    numSides::T2,\n    nodeSide::T2,\n    numLoops::T2,\n    segLen::T3,\n    slipSystem::T2,\n    _slipPlane::T4,\n    _bVec::T4,\n    label::T5,\n    buffer::T6,\n    range::T7,\n    dist::T8,\n) where {\n    T1 <: AbstractDlnStr,\n    T2 <: Int,\n    T3 <: Union{T where {T},AbstractArray{T,N} where {T,N}},\n    T4 <: AbstractArray{T,N} where {T,N},\n    T5 <: AbstractVector{nodeType},\n    T6,\n    T7 <: AbstractArray{T,N} where {T,N},\n    T8 <: AbstractDistribution,\n}\n\nKeyword DislocationLoop constructor calls the positional constructor, which dispatches the appropriate method.\n\n\n\n\n\n","category":"method"},{"location":"Constructors/#","page":"Constructors","title":"Constructors","text":"DislocationNetwork(\n    links::T1,\n    slipPlane::T2,\n    bVec::T2,\n    coord::T2,\n    label::T3,\n    nodeVel::T2,\n    nodeForce::T2,\n    numNode::T4 = zeros(Int, 1),\n    numSeg::T4 = zeros(Int, 1),\n    maxConnect::T5 = 4,\n    connectivity::T1 = zeros(Int, 1 + 2 * maxConnect, length(label)),\n    linksConnect::T1 = zeros(Int, 2, size(links, 2)),\n    segIdx::T1 = zeros(Int, size(links, 2), 3),\n    segForce::T6 = zeros(3, size(links)...),\n) where {\n    T1 <: AbstractArray{T,N} where {T,N},\n    T2 <: AbstractArray{T,N} where {T,N},\n    T3 <: AbstractVector{nodeType},\n    T4 <: Union{Int,AbstractVector{Int}},\n    T5 <: Int,T6 <: AbstractArray{T,N} where {T,N},\n}","category":"page"},{"location":"Constructors/#DDD.DislocationNetwork-Union{Tuple{T6}, Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T2,T2,T2,T3,T2,T2}, Tuple{T1,T2,T2,T2,T3,T2,T2,T4}, Tuple{T1,T2,T2,T2,T3,T2,T2,T4,T4}, Tuple{T1,T2,T2,T2,T3,T2,T2,T4,T4,T5}, Tuple{T1,T2,T2,T2,T3,T2,T2,T4,T4,T5,T1}, Tuple{T1,T2,T2,T2,T3,T2,T2,T4,T4,T5,T1,T1}, Tuple{T1,T2,T2,T2,T3,T2,T2,T4,T4,T5,T1,T1,T1}, Tuple{T1,T2,T2,T2,T3,T2,T2,T4,T4,T5,T1,T1,T1,T6}} where T6<:(AbstractArray{T,N} where N where T) where T5<:Int64 where T4<:Union{Int64, AbstractArray{Int64,1}} where T3<:AbstractArray{nodeType,1} where T2<:(AbstractArray{T,N} where N where T) where T1<:(AbstractArray{T,N} where N where T)","page":"Constructors","title":"DDD.DislocationNetwork","text":"DislocationNetwork(\n    links::T1,\n    slipPlane::T2,\n    bVec::T2,\n    coord::T2,\n    label::T3,\n    nodeVel::T2,\n    nodeForce::T2,\n    numNode::T4 = zeros(Int, 1),\n    numSeg::T4 = zeros(Int, 1),\n    maxConnect::T5 = 4,\n    connectivity::T1 = zeros(Int, 1 + 2 * maxConnect, length(label)),\n    linksConnect::T1 = zeros(Int, 2, size(links, 2)),\n    segIdx::T1 = zeros(Int, size(links, 2), 3),\n    segForce::T6 = zeros(3, size(links)...),\n) where {\n    T1 <: AbstractArray{T,N} where {T,N},\n    T2 <: AbstractArray{T,N} where {T,N},\n    T3 <: AbstractVector{nodeType},\n    T4 <: Union{Int,AbstractVector{Int}},\n    T5 <: Int,T6 <: AbstractArray{T,N} where {T,N},\n}\n\nDislocationNetwork constructor provides default values, validates inputs and calculates derived quantities.\n\n\n\n\n\n","category":"method"},{"location":"Constructors/#","page":"Constructors","title":"Constructors","text":"DislocationNetwork(;\n    links::T1,\n    slipPlane::T2,\n    bVec::T2,\n    coord::T2,\n    label::T3,\n    nodeVel::T2,\n    nodeForce::T2,\n    numNode::T4 = zeros(Int, 1),\n    numSeg::T4 = zeros(Int, 1),\n    maxConnect::T5 = 0,\n    connectivity::T1 = zeros(Int, 1 + 2 * maxConnect, length(label)),\n    linksConnect::T1 = zeros(Int, 2, size(links, 2)),\n    segIdx::T1 = zeros(Int, size(links, 2), 3),\n    segForce::T6 = zeros(3, size(links, 2), 0),\n) where {\n    T1 <: AbstractArray{T,N} where {T,N},\n    T2 <: AbstractArray{T,N} where {T,N},\n    T3 <: AbstractVector{nodeType},T4 <: AbstractVector{Int},\n    T5 <: Int,\n    T6 <: AbstractArray{T,N} where {T,N},\n}","category":"page"},{"location":"Constructors/#DDD.DislocationNetwork-Union{Tuple{}, Tuple{T6}, Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}} where T6<:(AbstractArray{T,N} where N where T) where T5<:Int64 where T4<:AbstractArray{Int64,1} where T3<:AbstractArray{nodeType,1} where T2<:(AbstractArray{T,N} where N where T) where T1<:(AbstractArray{T,N} where N where T)","page":"Constructors","title":"DDD.DislocationNetwork","text":"DislocationNetwork(;\n    links::T1,\n    slipPlane::T2,\n    bVec::T2,\n    coord::T2,\n    label::T3,\n    nodeVel::T2,\n    nodeForce::T2,\n    numNode::T4 = zeros(Int, 1),\n    numSeg::T4 = zeros(Int, 1),\n    maxConnect::T5 = 0,\n    connectivity::T1 = zeros(Int, 1 + 2 * maxConnect, length(label)),\n    linksConnect::T1 = zeros(Int, 2, size(links, 2)),\n    segIdx::T1 = zeros(Int, size(links, 2), 3),\n    segForce::T6 = zeros(3, size(links, 2), 0),\n) where {\n    T1 <: AbstractArray{T,N} where {T,N},\n    T2 <: AbstractArray{T,N} where {T,N},\n    T3 <: AbstractVector{nodeType},T4 <: AbstractVector{Int},\n    T5 <: Int,\n    T6 <: AbstractArray{T,N} where {T,N},\n}\n\nKeyword constructor for DislocationNetwork, calls the positional one.\n\n\n\n\n\n","category":"method"},{"location":"Constructors/#","page":"Constructors","title":"Constructors","text":"DislocationNetwork(\n    sources::T1,\n    maxConnect::T2 = 4,\n    args...;\n    memBuffer = nothing,\n    checkConsistency::T3 = true,\n    kw...,\n) where {\n    T1 <: Union{T,\n                AbstractVector{T},\n                NTuple{N,T} where N\n                } where {T <: DislocationLoop},\n    T2 <: Int,\n    T3 <: Bool,\n}","category":"page"},{"location":"Constructors/#DDD.DislocationNetwork-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T2,Vararg{Any,N} where N}} where T3<:Bool where T2<:Int64 where T1<:(Union{AbstractArray{T,1}, Tuple{Vararg{T,N}} where N, T} where T<:DislocationLoop)","page":"Constructors","title":"DDD.DislocationNetwork","text":"DislocationNetwork(\n    sources::T1,\n    maxConnect::T2 = 4,\n    args...;\n    memBuffer = nothing,\n    checkConsistency::T3 = true,\n    kw...,\n) where {\n    T1 <: Union{T,\n                AbstractVector{T},\n                NTuple{N,T} where N\n                } where {T <: DislocationLoop},\n    T2 <: Int,\n    T3 <: Bool,\n}\n\nThe recommended way of creating a network is to use a source of type DislocationLoop. It also accepts arrays and tuples of DislocationLoop variables. This automatically generates the network according to the parameters stored in source or each of its entries.\n\nMeaning\n\nargs... are optional arguments that will be passed on to the loopDistribution function which distributes the loops in sources according to the type of their dist variable.\nkw... are optional keyword arguments that will also be passed to loopDistribution.\nmemBuffer is the numerical value for allocating memory in advance. The quantity, memBuffer × N, where N is the total number of nodes in sources, will be the initial number of entries allocated in the matrices that keep the network's data. If no memBuffer is provided, the number of entries allocated will be textrmround(N log_2(N)).\n\n\n\n\n\n","category":"method"},{"location":"Constructors/#","page":"Constructors","title":"Constructors","text":"DislocationNetwork!(\n    network::T1,\n    sources::T2,\n    maxConnect::T3 = 4,\n    args...;\n    checkConsistency::T4 = true,\n    kw...,\n) where {\n    T1 <: DislocationNetwork,\n    T2 <: Union{T,\n                AbstractVector{T},\n                NTuple{N,T} where N\n                } where {T <: DislocationLoop},\n    T3 <: Int,\n    T4 <: Bool,\n}","category":"page"},{"location":"Constructors/#DDD.DislocationNetwork!-Union{Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T2}, Tuple{T1,T2,T3,Vararg{Any,N} where N}} where T4<:Bool where T3<:Int64 where T2<:(Union{AbstractArray{T,1}, Tuple{Vararg{T,N}} where N, T} where T<:DislocationLoop) where T1<:DislocationNetwork","page":"Constructors","title":"DDD.DislocationNetwork!","text":"DislocationNetwork!(\n    network::T1,\n    sources::T2,\n    maxConnect::T3 = 4,\n    args...;\n    checkConsistency::T4 = true,\n    kw...,\n) where {\n    T1 <: DislocationNetwork,\n    T2 <: Union{T,\n                AbstractVector{T},\n                NTuple{N,T} where N\n                } where {T <: DislocationLoop},\n    T3 <: Int,\n    T4 <: Bool,\n}\n\nAdds more sources to an existing network.\n\n\n\n\n\n","category":"method"},{"location":"Constructors/#","page":"Constructors","title":"Constructors","text":"makeNetwork!(\n    links,\n    slipPlane,\n    bVec,\n    coord,\n    label,\n    sources,\n    lims,\n    initIdx,\n    args...;\n    kw...,\n)","category":"page"},{"location":"#DDD-1","page":"Home","title":"DDD","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"(Image: Dev) (Image: Build Status) (Image: Build Status) (Image: Codecov) (Image: Coveralls)","category":"page"}]
}
