var documenterSearchIndex = {"docs":
[{"location":"api/#IO-1","page":"API","title":"IO","text":"","category":"section"},{"location":"api/#Input-1","page":"API","title":"Input","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"loadJSON\nloadDislocationLoop\nloadMaterialParameters\nloadFEMParameters\nloadBoundaries\nloadForceDisplacement\nloadIntegrationParameters\nloadSlipSystem\nloadDislocationParameters\nloadNetwork\nloadIntegrationTime\nloadParameters","category":"page"},{"location":"api/#DDD.loadJSON","page":"API","title":"DDD.loadJSON","text":"loadJSON(filename::AbstractString)\n\nWrapper for JSON.parsefile(filename). Loads a JSON file as a dictionary.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.loadDislocationLoop","page":"API","title":"DDD.loadDislocationLoop","text":"loadDislocationLoop(dict::Dict{T1,T2} where {T1,T2}, slipSystem::SlipSystem)\n\nConstructs DislocationLoop out of a dictionary and SlipSystem structure.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.loadMaterialParameters","page":"API","title":"DDD.loadMaterialParameters","text":"loadMaterialParameters(dict::Dict{T1, T2}) where {T1, T2}\n\nConstructs MaterialParameters out of a dictionary.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.loadFEMParameters","page":"API","title":"DDD.loadFEMParameters","text":"loadFEMParameters(dict::Dict{T1,T2}) where {T1,T2}\n\nConstructs FEMParameters out of a dictionary.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.loadBoundaries","page":"API","title":"DDD.loadBoundaries","text":"loadBoundaries(dict::Dict{T1,T2}) where {T1,T2}\n\nConstructs Boundaries out of a dictionary.\n\nnote: Note\ntK may be null if it was factorised when the variable was saved.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.loadForceDisplacement","page":"API","title":"DDD.loadForceDisplacement","text":"loadForceDisplacement(dict::Dict{T1,T2}) where {T1,T2}\n\nConstructs ForceDisplacement out of a dictionary. It makes the arrays sparse and drops zeros under eps(Float64).\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.loadIntegrationParameters","page":"API","title":"DDD.loadIntegrationParameters","text":"loadIntegrationParameters(dict::Dict{T1,T2}) where {T1,T2}\n\nConstructs IntegrationParameters out of a dictionary.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.loadSlipSystem","page":"API","title":"DDD.loadSlipSystem","text":"loadSlipSystem(dict::Dict{T1,T2}) where {T1,T2}\n\nConstructs SlipSystem out of a dictionary.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.loadDislocationParameters","page":"API","title":"DDD.loadDislocationParameters","text":"loadDislocationParameters(dict::Dict{T1,T2}) where {T1,T2}\n\nConstructs DislocationParameters out of a dictionary.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.loadNetwork","page":"API","title":"DDD.loadNetwork","text":"loadNetwork(fileDislocationNetwork::AbstractString)\n\nConstructs DislocationNetwork from a JSON file.\n\n\n\n\n\nloadNetwork(dict::Dict{T1,T2}) where {T1,T2}\n\nConstructs DislocationNetwork from a dictionary.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.loadIntegrationTime","page":"API","title":"DDD.loadIntegrationTime","text":"loadIntegrationTime(fileIntegrationTime::AbstractString)\n\nConstructs IntegrationTime from a JSON file.\n\n\n\n\n\nloadIntegrationTime(dict::Dict{T1,T2}) where {T1,T2}\n\nConstructs IntegrationTime from a dictionary.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.loadParameters","page":"API","title":"DDD.loadParameters","text":"loadParameters(\n    fileDislocationParameters::T,\n    fileMaterialParameters::T,\n    fileFEMParameters::T,\n    fileIntegrationParameters::T,\n    fileSlipSystem::T,\n    fileDislocationLoop::T,\n) where {T <: AbstractString}\n\nConstructs simulation parameters, (DislocationParameters, MaterialParameters, FEMParameters, IntegrationParameters, SlipSystem, DislocationLoop) from JSON files.\n\n\n\n\n\n","category":"function"},{"location":"api/#Output-1","page":"API","title":"Output","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"saveJSON","category":"page"},{"location":"api/#DDD.saveJSON","page":"API","title":"DDD.saveJSON","text":"saveJSON(filename::AbstractString, args...; mode::AbstractString = \"w\")\n\nWrapper for JSON.print.\n\n\n\n\n\n","category":"function"},{"location":"api/#Types-1","page":"API","title":"Types","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"nodeTypeDln\nAbstractDlnSeg\nAbstractDlnStr\nAbstractDistribution\nAbstractMobility\nSlipSystem{T1,T2,T3}\nDislocationParameters{T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21}\nDislocationLoop{T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14}\nDislocationLoopCollection\nDislocationNetwork{T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14}\nnodeTypeFE\nAbstractMesh\nAbstractElementOrder\nAbstractShapeFunction\nAbstractModel\nFEMParameters{T1,T2,T3,T4,T5,T6,T7,T8,T9}\nRegularCuboidMesh{T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24}\nForceDisplacement{T1,T2,T3,T4}\nBoundaries{T1,T2,T3,T4,T5,T6,T7}\nAbstractIntegrator\nIntegrationParameters{T1,T2,T3,T4,T5,T6,T7,T8,T9,T10}\nIntegrationTime{T1,T2,T3}\nAbstractCrystalStruct\nMaterialParameters{T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13}","category":"page"},{"location":"api/#DDD.nodeTypeDln","page":"API","title":"DDD.nodeTypeDln","text":"@enum nodeTypeDln begin\n    noneDln = 0    # Undefined node, value at initialisation\n    intMobDln = 1  # Internal mobile node\n    intFixDln = 2  # Internal fixed node\n    srfMobDln = 3  # Mobile surface node\n    srfFixDln = 4  # Fixed surface node\n    extDln = 5     # External node\n    tmpDln = 6     # Temporary flag, used during topological operations\nend\n\nDifferent types of nodes behave differently. There are only a finite number of them so an enumerated type provides safety and efficiency. Each value represents a different type of node and therefore its behaviour.\n\nMeaning\n\nnoneDln are uninitialised nodes.\nintMobDln are mobile nodes internal to the convex hull of the domain. They take part in tractions, displacements and dislocation interactions.\nintFixDln are fixed nodes internal to the convex hull of the domain. They participate in the same way as intMobDln nodes except for the fact that their velocities is fixed are zero.\nsrfMobDln are mobile nodes that live on the surface of the convex hull of the domain, they are used to track slip steps and therefore participate in the same things as internal nodes but their velocities are restricted to the convex hull surface.\nsrfFixDln are fixed surface nodes and have the same characteristics as mobile surface nodes except for having zero velocity.\nextDln are external nodes that do not participate in dislocation interactions or forces but are used to calculate displacements and track slip steps.\ntmpDln are nodes that are temporarily flagged before they are assigned another type.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.AbstractDlnSeg","page":"API","title":"DDD.AbstractDlnSeg","text":"abstract type AbstractDlnSeg end\nstruct segNone <: AbstractDlnSeg end    # Undefined segment\nstruct segEdge <: AbstractDlnSeg end    # Edge segment\nstruct segEdgeN <: AbstractDlnSeg end   # Edge segment\nstruct segScrew <: AbstractDlnSeg end   # Screw segment\nstruct segMixed <: AbstractDlnSeg end   # Mixed segment\n\nThese types are used to automatically generate segments out of Burgers vectors b, slip planes n, and/or line direction l.\n\nsegEdge have b ⟂ t,\nsegEdgeN have b ⟂ t and b ∥ n ,\nsegScrew have b ∥ t ,\nsegMixed have noneDln of the above.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.AbstractDlnStr","page":"API","title":"DDD.AbstractDlnStr","text":"abstract type AbstractDlnStr end\nstruct loopPrism <: AbstractDlnStr end\nstruct loopShear <: AbstractDlnStr end\nconst loopPure = Union{loopPrism,loopShear}\nstruct loopMixed <: AbstractDlnStr end\nstruct loopJog <: AbstractDlnStr end\nstruct loopKink <: AbstractDlnStr end\nconst loopImpure = Union{loopMixed,loopJog,loopKink}\nconst loopDefined = Union{loopPure,loopImpure}\nstruct loopDln <: AbstractDlnStr end\n\nThese types are used to automatically generate dislocation loops for simulation initialisation.\n\nMeaning\n\nloopPrism are prismatic loops, their Burgers vectors are perpendicular to the their line direction. They are idealised loops that can be automatically generated as n-gons.\nloopShear are shear loops, their line direction goes through edge, screw and line segments as the loop goes round. They are idealised loops that can be automatically generated as n-gons.\nloopPure are idealised loops.\nloopMixed are loops with prismatic and shear character. They have to be hand-made or require a heuristic to automatically generate.\nloopDln is a generic loop used for adding methods to Base functions.\nloopKink and loopJog are structures formed by colliding dislocations. They are not currently used.\nloopImpure are non-idealised loops.\nloopDefined are defined loop types.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.AbstractDistribution","page":"API","title":"DDD.AbstractDistribution","text":"abstract type AbstractDistribution end\nstruct Zeros <: AbstractDistribution end\nstruct Rand <: AbstractDistribution end\nstruct Randn <: AbstractDistribution end\nstruct Regular <: AbstractDistribution end\n\nSpatial distributions for dislocation sources. These are used to automatically generate networks with a given distribution.\n\nMeaning\n\nZeros makes the network generation functions place the center of the generated dislocation loops at the origin. This can be used to generate a network and loops can be manually or pseudo-manually distributed in the domain.\nRand makes the network generation functions uniformly distribute the dislocations according to the range and buffer values in the dislocation loop structure.\nRand makes the network generation functions normally distribute the dislocations according to the range and buffer values in the dislocation loop structure.\nRand TBA, will regularly distribute dislocations according to the range, buffer and other args given to the dislocation network generator.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.AbstractMobility","page":"API","title":"DDD.AbstractMobility","text":"abstract type AbstractMobility end\nstruct mobBCC <: AbstractMobility end\nstruct mobFCC <: AbstractMobility end\nstruct mobHCP <: AbstractMobility end\n\nTypes to dispatch different mobility functions.\n\nMeaning\n\nmobBCC is used to dispatch the default BCC mobility function.\nmobFCC is used to dispatch the default FCC mobility function.\nmobHCP is used to dispatch the default HCP mobility function.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.SlipSystem","page":"API","title":"DDD.SlipSystem","text":"struct SlipSystem{T1,T2,T3}\n    crystalStruct::T1\n    slipPlane::T2\n    bVec::T3\nend\n\nStores slip systems. \n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.DislocationParameters","page":"API","title":"DDD.DislocationParameters","text":"struct DislocationParameters{T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21}\n    mobility::T1            # Dislocation core radius\n    dragCoeffs::T2          # Drag coefficients\n    coreRad::T3             # Dislocation core radius\n    coreRadSq::T4           # Dislocation core radius squared\n    coreRadMag::T5          # Magnitude of core radius\n    coreEnergy::T6          # Core energy\n    minSegLen::T7           # Minimum segment length\n    maxSegLen::T8           # Maximum segment length\n    twoMinSegLen::T9        # Minimum segment length times two\n    minArea::T10            # Minimum area for remeshing\n    maxArea::T11            # Maximum area for remeshing\n    minAreaSq::T12          # Minimum area for remeshing squared\n    maxAreaSq::T13          # Maximum area for remeshing squared\n    slipStepCritLen::T14    # Critical length for slip step tracking\n    slipStepCritArea::T15   # Critical area for slip slep tracking\n    remesh::T16             # Flag for remeshing\n    collision::T17          # Flag for collision\n    separation::T18         # Flag for separation\n    virtualRemesh::T19      # Flag for virtual remeshing\n    parCPU::T20             # Flag for CPU parallelisation\n    parGPU::T21             # Flag for GPU parallelisation\nend\n\nStores the dislocation parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.DislocationLoop","page":"API","title":"DDD.DislocationLoop","text":"struct DislocationLoop{T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14}\n    loopType::T1    # Loop type.\n    numSides::T2    # Number of sides in the loop.\n    nodeSide::T3    # Nodes per side of the loop.\n    numLoops::T4    # Number of loops to generate when making the network.\n    segLen::T5      # Segment lengths.\n    slipSystem::T6  # Slip system.\n    label::T7       # Node labels.\n    links::T8       # Links.\n    slipPlane::T9   # Slip planes.\n    bVec::T10       # Burgers vectors.\n    coord::T11      # Coordinates.\n    buffer::T12     # Buffer for distributions.\n    range::T13      # Range for distributions.\n    dist::T14       # Distribution.\nend\n\nStores a dislocation loop.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.DislocationLoopCollection","page":"API","title":"DDD.DislocationLoopCollection","text":"DislocationLoopCollection = Union{T,AbstractVector{T},NTuple{N,T} where N} where {T <: DislocationLoop}\n\nDefines a single, vector, and tuple of DislocationLoop types.\n\n\n\n\n\n","category":"constant"},{"location":"api/#DDD.DislocationNetwork","page":"API","title":"DDD.DislocationNetwork","text":"struct DislocationNetwork{T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14}\n    numNode::T1\n    numSeg::T2\n    maxConnect::T3\n    label::T4\n    links::T5\n    connectivity::T6\n    linksConnect::T7\n    slipPlane::T8\n    segIdx::T9\n    bVec::T10\n    coord::T11\n    nodeVel::T12\n    nodeForce::T13\n    segForce::T14\nend\n\nStores a dislocation network.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.nodeTypeFE","page":"API","title":"DDD.nodeTypeFE","text":"@enum nodeTypeFE begin\n    noneFE = 0  # Uninitialised node\n    corner = 1  # Corner node\n    edge = 2    # Edge node\n    face = 3    # Face node\n    intFE = 4   # Internal node\nend\n\nFinite element node type.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.AbstractMesh","page":"API","title":"DDD.AbstractMesh","text":"abstract type AbstractMesh end\nabstract type AbstractRegularCuboidMesh <: AbstractMesh end\nstruct DispatchRegularCuboidMesh <: AbstractRegularCuboidMesh end\n\nFE mesh types for dispatch.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.AbstractElementOrder","page":"API","title":"DDD.AbstractElementOrder","text":"abstract type AbstractElementOrder end\nstruct LinearElement <: AbstractElementOrder end\n\nFinite element orders for dispatch.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.AbstractShapeFunction","page":"API","title":"DDD.AbstractShapeFunction","text":"abstract type AbstractShapeFunction end\nabstract type AbstractShapeFunction3D <: AbstractShapeFunction end\nabstract type AbstractShapeFunction2D <: AbstractShapeFunction end\nstruct LinearQuadrangle3D <:AbstractShapeFunction3D end\nstruct LinearQuadrangle2D <:AbstractShapeFunction2D end\n\nShape function types for dispatch.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.AbstractModel","page":"API","title":"DDD.AbstractModel","text":"abstract type AbstractModel end\nabstract type AbstractCantileverBend <: AbstractModel end\nstruct CantileverLoad <: AbstractCantileverBend end\n\nAbstract types for dispatching different models.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.FEMParameters","page":"API","title":"DDD.FEMParameters","text":"struct FEMParameters{T1,T2,T3,T4,T5,T6,T7,T8,T9}\n    type::T1\n    order::T2\n    model::T3\n    dx::T4\n    dy::T5\n    dz::T6\n    mx::T7\n    my::T8\n    mz::T9\nend\n\nStores the finite element parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.RegularCuboidMesh","page":"API","title":"DDD.RegularCuboidMesh","text":"struct RegularCuboidMesh{T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24} <: AbstractRegularCuboidMesh\n    order::T1           # Element order\n    dx::T2              # Size in x\n    dy::T3              # Size in y\n    dz::T4              # Size in z\n    mx::T5              # Elements in x\n    my::T6              # Elements in y\n    mz::T7              # Elements in z\n    w::T8               # Width\n    h::T9               # Height\n    d::T10              # Depth\n    scale::T11          # Mesh scale\n    numElem::T12        # Number of elements\n    numNode::T13        # Number of nodes\n    C::T14              # Stiffness tensor\n    vertices::T15       # Vertices\n    faces::T16          # Faces\n    faceNorm::T17       # Face normals\n    faceMidPt::T18      # Face mid-points\n    cornerNode::T19     # Corner nodes set\n    edgeNode::T20       # Edge nodes set\n    faceNode::T21       # Face node set\n    coord::T22          # Node coordinates\n    connectivity::T23   # Node connectivity\n    K::T24              # Stiffness matrix\nend\n\nStores regular a cuboid mesh.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.ForceDisplacement","page":"API","title":"DDD.ForceDisplacement","text":"struct ForceDisplacement{T1,T2,T3,T4}\n    uTilde::T1  # Dislocation displacements.\n    uHat::T2    # Corrective displacements.\n    u::T3       # Displacement.\n    fTilde::T4  # Dislocation tractions.\n    fHat::T5    # Corrective tractions.\n    f::T6       # Force.\nend\n\nStores displacements and forces applied on the FE nodes.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.Boundaries","page":"API","title":"DDD.Boundaries","text":"struct Boundaries{T1,T2,T3,T4,T5,T6,T7}\n    uGamma::T1  # Nodes with displacement boundaries.\n    tGamma::T2  # Nodes with traction boundaries.\n    mGamma::T3  # Nodes with displacement and traction boundaries.\n    uDofs::T4   # Degrees of freedom with specified displacements.\n    tDofs::T5   # Degrees of feedom with specified tractions.\n    mDofs::T6   # Degrees of feedom with specified displacements and tractions.\n    tK::T7      # Stiffness matrix of traction degrees of freedom.\nend\n\nStores the nodes and degrees of freedom upon which the different boundary conditions are applied.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.AbstractIntegrator","page":"API","title":"DDD.AbstractIntegrator","text":"abstract type AbstractIntegrator end\nstruct AdaptiveEulerTrapezoid <: AbstractIntegrator end\n\nIntegrator types for dispatch.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.IntegrationParameters","page":"API","title":"DDD.IntegrationParameters","text":"struct IntegrationParameters{T1,T2,T3,T4,T5,T6,T7,T8,T9,T10}\n    method::T1\n    tmin::T2\n    tmax::T3\n    dtmin::T4\n    dtmax::T5\n    abstol::T6\n    reltol::T7\n    maxchange::T8\n    exponent::T9\n    maxiter::T10\nend\n\nStores integration parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.IntegrationTime","page":"API","title":"DDD.IntegrationTime","text":"struct IntegrationTime{T1,T2,T3}\n    dt::T1      # Current time step.\n    time::T2    # Current simulation time.\n    step::T3    # Current simulation step.\nend\n\nStore integration time and steps.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.AbstractCrystalStruct","page":"API","title":"DDD.AbstractCrystalStruct","text":"abstract type AbstractCrystalStruct end\nstruct BCC <: AbstractCrystalStruct end\nstruct FCC <: AbstractCrystalStruct end\nstruct HCP <: AbstractCrystalStruct end\n\nCrystal structure types.\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.MaterialParameters","page":"API","title":"DDD.MaterialParameters","text":"struct MaterialParameters{T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13}\n    crystalStruct::T1   # Crystal structure.\n    μ::T2               # Shear modulus.\n    μMag::3             # Magnitude of shear modulus.\n    ν::T4               # Poisson ratio.\n    E::T5               # Young's modulus.\n    omνInv::T6          # 1 / (1 - ν)\n    opνInv::T7          # 1 / (1 + ν)\n    νomνInv::T8         # ν / (1 - ν)\n    νopνInv::T9         # v / (1 + ν)\n    μ4π::T10            # μ / (4π)\n    μ8π::T11            # μ / (8π)\n    μ4πν::T12           # μ / (4π (1 - ν))\n    σPN::T13            # Peierls-Nabarro stress.\nend\n\nStore material parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#Constructors-1","page":"API","title":"Constructors","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"SlipSystem(;\n    crystalStruct::AbstractCrystalStruct,\n    slipPlane::AbstractArray,\n    bVec::AbstractArray\n)\nDislocationParameters(;\n    mobility::AbstractMobility,\n    dragCoeffs = (edge = 1.0, screw = 2.0, climb = 1e9),\n    coreRad = 1.0,\n    coreRadMag = 1.0,\n    coreEnergy = 1 / (4 * π) * log(coreRad / 0.1),\n    minSegLen = 2 * coreRad,\n    maxSegLen = 20 * coreRad,\n    minArea = coreRad^2 / sqrt(2),\n    maxArea = 100 * minArea,\n    slipStepCritLen = maxSegLen / 2,\n    slipStepCritArea = 0.5 * (slipStepCritLen^2) * sind(1),\n    remesh = true,\n    collision = true,\n    separation = true,\n    virtualRemesh = true,\n    parCPU = false,\n    parGPU = false,\n)\nDislocationLoop(\n    loopType::AbstractDlnStr,\n    numSides,\n    nodeSide,\n    numLoops,\n    segLen,\n    slipSystem,\n    _slipPlane,\n    _bVec,\n    label,\n    buffer,\n    range,\n    dist,\n)\nDislocationLoop(\n    loopType::loopPure,\n    numSides,\n    nodeSide,\n    numLoops,\n    segLen,\n    slipSystem,\n    _slipPlane::AbstractArray,\n    _bVec::AbstractArray,\n    label::AbstractVector{nodeTypeDln},\n    buffer,\n    range,\n    dist::AbstractDistribution,\n)\nDislocationLoop(\n    loopType::loopImpure,\n    numSides,\n    nodeSide,\n    numLoops,\n    segLen,\n    slipSystem,\n    _slipPlane::AbstractArray,\n    _bVec::AbstractArray,\n    label::AbstractVector{nodeTypeDln},\n    buffer,\n    range,\n    dist::AbstractDistribution,\n)\nDislocationLoop(;\n    loopType::AbstractDlnStr,\n    numSides,\n    nodeSide,\n    numLoops,\n    segLen,\n    slipSystem,\n    _slipPlane,\n    _bVec,\n    label,\n    buffer,\n    range,\n    dist,\n)\nDislocationNetwork(;\n    links::AbstractArray,\n    slipPlane::AbstractArray,\n    bVec::AbstractArray,\n    coord::AbstractArray,\n    label::AbstractVector{nodeTypeDln},\n    nodeVel::AbstractArray,\n    nodeForce::AbstractArray,\n    numNode = length(label),\n    numSeg = size(links, 2),\n    maxConnect = 4,\n    connectivity::AbstractArray = zeros(Int, 1 + 2 * maxConnect, length(label)),\n    linksConnect::AbstractArray = zeros(Int, 2, size(links, 2)),\n    segIdx::AbstractArray = zeros(Int, size(links, 2), 3),\n    segForce::AbstractArray = zeros(3, 2, size(links, 2)),\n)\nDislocationNetwork(\n    sources::DislocationLoopCollection,\n    maxConnect = 4,\n    args...;\n    memBuffer = nothing,\n    checkConsistency = true,\n    kw...,\n)\nDislocationNetwork!\nmakeNetwork!\nFEMParameters(; \n    type::AbstractMesh,\n    order::AbstractElementOrder,\n    model::AbstractModel,\n    dx, dy, dz, mx, my, mz\n)\nForceDisplacement(; uTilde, uHat, u, fTilde, fHat, f)\nBoundaries(; uGamma, tGamma, mGamma, uDofs, tDofs, mDofs, tK)\nBoundaries(\n    ::FEMParameters{T1,T2,T3,T4,T5} where {T1,T2,T3<:CantileverLoad,T4,T5},\n    femMesh::RegularCuboidMesh; \n    kw...\n)\nbuildMesh\nRegularCuboidMesh(\n    matParams::MaterialParameters,\n    femParams::FEMParameters{F1,F2,F3,F4,F5} where {F1<:DispatchRegularCuboidMesh,F2<:LinearElement,F3,F4,F5}\n)\nIntegrationParameters(;\n    method::AbstractIntegrator,\n    tmin = 0.0,\n    tmax = 1e13,\n    dtmin = 1e-3,\n    dtmax = Inf,\n    abstol = 1e-6,\n    reltol = 1e-6,\n    maxchange = 1.2,\n    exponent = 20.0,\n    maxiter = 10,\n)\nIntegrationTime(; dt = 0.0, time = 0.0, step = 0)\nMaterialParameters(;\n    crystalStruct::AbstractCrystalStruct,\n    μ = 1.0,\n    μMag = 1.0,\n    ν = 0.5,\n    σPN = 0.0,\n)","category":"page"},{"location":"api/#DDD.SlipSystem-Tuple{}","page":"API","title":"DDD.SlipSystem","text":"SlipSystem(;\n    crystalStruct::AbstractCrystalStruct,\n    slipPlane::AbstractArray,\n    bVec::AbstractArray\n)\n\nCreates a SlipSystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.DislocationParameters-Tuple{}","page":"API","title":"DDD.DislocationParameters","text":"DislocationParameters(;\n    mobility::AbstractMobility,\n    dragCoeffs = (edge = 1.0, screw = 2.0, climb = 1e9),\n    coreRad = 1.0,\n    coreRadMag = 1.0,\n    coreEnergy = 1 / (4 * π) * log(coreRad / 0.1),\n    minSegLen = 2 * coreRad,\n    maxSegLen = 20 * coreRad,\n    minArea = coreRad^2 / sqrt(2),\n    maxArea = 100 * minArea,\n    slipStepCritLen = maxSegLen / 2,\n    slipStepCritArea = 0.5 * (slipStepCritLen^2) * sind(1),\n    remesh = true,\n    collision = true,\n    separation = true,\n    virtualRemesh = true,\n    parCPU = false,\n    parGPU = false,\n)\n\nCreates DislocationParameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.DislocationLoop-Tuple{AbstractDlnStr,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any}","page":"API","title":"DDD.DislocationLoop","text":"DislocationLoop(\n    loopType::AbstractDlnStr,\n    numSides,\n    nodeSide,\n    numLoops,\n    segLen,\n    slipSystem,\n    _slipPlane,\n    _bVec,\n    label,\n    buffer,\n    range,\n    dist,\n)\n\nFallback for creating a generic DislocationLoop.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.DislocationLoop-Tuple{Union{loopPrism, loopShear},Any,Any,Any,Any,Any,AbstractArray,AbstractArray,AbstractArray{nodeTypeDln,1},Any,Any,AbstractDistribution}","page":"API","title":"DDD.DislocationLoop","text":"DislocationLoop(\n    loopType::loopPure,\n    numSides,\n    nodeSide,\n    numLoops,\n    segLen,\n    slipSystem,\n    _slipPlane::AbstractArray,\n    _bVec::AbstractArray,\n    label::AbstractVector{nodeTypeDln},\n    buffer,\n    range,\n    dist::AbstractDistribution,\n)\n\nConstructor for loopPure DislocationLoops.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.DislocationLoop-Tuple{Union{DDD.loopJog, DDD.loopKink, DDD.loopMixed},Any,Any,Any,Any,Any,AbstractArray,AbstractArray,AbstractArray{nodeTypeDln,1},Any,Any,AbstractDistribution}","page":"API","title":"DDD.DislocationLoop","text":"DislocationLoop(\n    loopType::loopImpure,\n    numSides,\n    nodeSide,\n    numLoops,\n    segLen,\n    slipSystem,\n    _slipPlane::AbstractArray,\n    _bVec::AbstractArray,\n    label::AbstractVector{nodeTypeDln},\n    buffer,\n    range,\n    dist::AbstractDistribution,\n)\n\nA fallback DislocationLoop constructor for other as of yet unimplemented loopImpure.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.DislocationLoop-Tuple{}","page":"API","title":"DDD.DislocationLoop","text":"DislocationLoop(;\n    loopType::AbstractDlnStr,\n    numSides,\n    nodeSide,\n    numLoops,\n    segLen,\n    slipSystem,\n    _slipPlane,\n    _bVec,\n    label,\n    buffer,\n    range,\n    dist,\n)\n\nCreate a DislocationLoop.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.DislocationNetwork-Tuple{}","page":"API","title":"DDD.DislocationNetwork","text":"DislocationNetwork(;\n    links::AbstractArray,\n    slipPlane::AbstractArray,\n    bVec::AbstractArray,\n    coord::AbstractArray,\n    label::AbstractVector{nodeTypeDln},\n    nodeVel::AbstractArray,\n    nodeForce::AbstractArray,\n    numNode = length(label),\n    numSeg = size(links, 2),\n    maxConnect = 4,\n    connectivity::AbstractArray = zeros(Int, 1 + 2 * maxConnect, length(label)),\n    linksConnect::AbstractArray = zeros(Int, 2, size(links, 2)),\n    segIdx::AbstractArray = zeros(Int, size(links, 2), 3),\n    segForce::AbstractArray = zeros(3, 2, size(links, 2)),\n)\n\nCreate a DislocationNetwork.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.DislocationNetwork","page":"API","title":"DDD.DislocationNetwork","text":"DislocationNetwork(\n    sources::DislocationLoopCollection,\n    maxConnect = 4,\n    args...;\n    memBuffer = nothing,\n    checkConsistency = true,\n    kw...,\n)\n\nCreates a DislocationNetwork out of a DislocationLoopCollection.\n\nArguments\n\nargs... are optional arguments that will be passed on to the loopDistribution function which distributes the loops in sources according to the type of their dist variable.\nkw... are optional keyword arguments that will also be passed to loopDistribution.\nmemBuffer is the numerical value for allocating memory in advance. The quantity, memBuffer × N, where N is the total number of nodes in sources, will be the initial number of entries allocated in the matrices that keep the network's data. If no memBuffer is provided, the number of entries allocated will be `round(N*log2(N)).\n\n\n\n\n\n","category":"type"},{"location":"api/#DDD.DislocationNetwork!","page":"API","title":"DDD.DislocationNetwork!","text":"DislocationNetwork!(\n    network::DislocationNetwork,\n    sources::DislocationLoopCollection,\n    args...;\n    memBuffer = nothing,\n    checkConsistency = true,\n    kw...,\n)\n\nAdds a DislocationLoopCollection to an existing DislocationNetwork.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.makeNetwork!","page":"API","title":"DDD.makeNetwork!","text":"makeNetwork!(\n    links,\n    slipPlane,\n    bVec,\n    coord,\n    label,\n    sources,\n    lims,\n    initIdx,\n    args...;\n    kw...,\n)\n\nInternal function called by DislocationNetwork to fill the arrays that define the network.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.FEMParameters-Tuple{}","page":"API","title":"DDD.FEMParameters","text":"FEMParameters(; \n    type::AbstractMesh,\n    order::AbstractElementOrder,\n    model::AbstractModel,\n    dx, dy, dz, mx, my, mz\n)\n\nCreates FEMParameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.ForceDisplacement-Tuple{}","page":"API","title":"DDD.ForceDisplacement","text":"ForceDisplacement(; uTilde, uHat, u, fTilde, fHat, f)\n\nCreates ForceDisplacement.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.Boundaries-Tuple{}","page":"API","title":"DDD.Boundaries","text":"Boundaries(; uGamma, tGamma, mGamma, uDofs, tDofs, mDofs, tK)\n\nCreates Boundaries.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.Boundaries-Tuple{FEMParameters{T1,T2,T3,T4,T5,T6,T7,T8,T9} where T9 where T8 where T7 where T6 where T5 where T4 where T3<:CantileverLoad where T2 where T1,RegularCuboidMesh}","page":"API","title":"DDD.Boundaries","text":"Boundaries(\n    ::FEMParameters{T1,T2,T3,T4,T5} where {T1,T2,T3<:CantileverLoad,T4,T5},\n    femMesh::RegularCuboidMesh; \n    kw...\n)\n\nCreates Boundaries for loading a hexahedral cantilever.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.buildMesh","page":"API","title":"DDD.buildMesh","text":"buildMesh(\n    matParams::MaterialParameters, \n    femParams::FEMParameters{F1,F2,F3,F4,F5} where {F1<:DispatchRegularCuboidMesh,F2,F3,F4,F5}\n)\n\nCreates a RegularCuboidMesh.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.RegularCuboidMesh-Tuple{MaterialParameters,FEMParameters{F1,F2,F3,F4,F5,T6,T7,T8,T9} where T9 where T8 where T7 where T6 where F5 where F4 where F3 where F2<:LinearElement where F1<:DispatchRegularCuboidMesh}","page":"API","title":"DDD.RegularCuboidMesh","text":"RegularCuboidMesh(\n    matParams::MaterialParameters,\n    femParams::FEMParameters{F1,F2,F3,F4,F5} where {F1<:DispatchRegularCuboidMesh,F2<:LinearElement,F3,F4,F5}\n)\n\nCreated by: E. Tarleton edmund.tarleton@materials.ox.ac.uk\n\n3D FEM code using linear 8 node element with 8 integration pts (2x2x2) per element.\n\n   4.-------.3\n   | \\       |\\\n   |  \\      | \\    my\n   1.--\\---- .2 \\\n    \\   \\     \\  \\\n     \\  8.--------.7\n      \\  |      \\ |  mz\n       \\ |       \\|\n         5.--------.6\n             mx\ny   ^z\n ↖  |\n  \\ |\n   \\|---->x\n\nnote: Note\nThis is rotated about the x axis w.r.t. to the local (s1, s2, s3) system. calc_σHat uses custom linear shape functions that eliminate the need for a Jacobian, speeding up the calculation. We keep the Jacobian in this function because it's only run at simulation initialisation so it's not performance critical, which lets us use standard shape functions.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.IntegrationParameters-Tuple{}","page":"API","title":"DDD.IntegrationParameters","text":"IntegrationParameters(;\n    method::AbstractIntegrator,\n    tmin = 0.0,\n    tmax = 1e13,\n    dtmin = 1e-3,\n    dtmax = Inf,\n    abstol = 1e-6,\n    reltol = 1e-6,\n    maxchange = 1.2,\n    exponent = 20.0,\n    maxiter = 10,\n)\n\nCreates IntegrationParameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.IntegrationTime-Tuple{}","page":"API","title":"DDD.IntegrationTime","text":"IntegrationTime(; dt = 0.0, time = 0.0, step = 0)\n\nCreates IntegrationTime.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDD.MaterialParameters-Tuple{}","page":"API","title":"DDD.MaterialParameters","text":"MaterialParameters(;\n    crystalStruct::AbstractCrystalStruct,\n    μ = 1.0,\n    μMag = 1.0,\n    ν = 0.5,\n    σPN = 0.0,\n)\n\nCreates MaterialParameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#Processing-1","page":"API","title":"Processing","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"calc_σTilde\ncalc_σTilde!\ncalcSegForce\ncalcSegForce!\ncalc_σHat\ncalcPKForce\ncalcPKForce!\ncalcSelfForce\ncalcSelfForce!\ncalcSegSegForce\ncalcSegSegForce!\ndlnMobility\ndlnMobility!\nsplitNode!\nrefineNetwork!\nremoveNode!\nremoveConnection!\nremoveLink!\nmergeNode!\ncoarsenNetwork!\nfindIntersectVolume\nmakeSurfaceNode!\nremeshSurfaceNetwork!\ncoarsenVirtualNetwork!\nshapeFunction\nshapeFunctionDeriv\nderiv!\nintegrate!","category":"page"},{"location":"api/#DDD.calc_σTilde","page":"API","title":"DDD.calc_σTilde","text":"calc_σTilde(\n    x0,\n    dlnParams::DislocationParameters,\n    matParams::MaterialParameters,\n    network::DislocationNetwork,\n    idx = nothing,\n)\n\nComputes the stress tensor, ̃σ, induced by dislocations on points x0.\n\nReturns\n\nσxx = σ[1, :]\nσyy = σ[2, :]\nσzz = σ[3, :]\nσxy = σ[4, :]\nσxz = σ[5, :]\nσyz = σ[6, :]\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.calc_σTilde!","page":"API","title":"DDD.calc_σTilde!","text":"calc_σTilde!(\n    σ,\n    x0,\n    dlnParams::DislocationParameters,\n    matParams::MaterialParameters,\n    network::DislocationNetwork,\n    idx = nothing,\n)\n\nIn-place computation of the stress tensor,̃σ, induced by dislocations on points x0.\n\nReturns\n\nσxx = σ[1, :]\nσyy = σ[2, :]\nσzz = σ[3, :]\nσxy = σ[4, :]\nσxz = σ[5, :]\nσyz = σ[6, :]\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.calcSegForce","page":"API","title":"DDD.calcSegForce","text":"calcSegForce(\n    dlnParams::DislocationParameters,\n    matParams::MaterialParameters,\n    mesh::AbstractMesh,\n    forceDisplacement::ForceDisplacement,\n    network::DislocationNetwork,\n    idx = nothing,\n)\n\nCompute total force on dislocation segments.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.calcSegForce!","page":"API","title":"DDD.calcSegForce!","text":"calcSegForce!(\n    dlnParams::DislocationParameters,\n    matParams::MaterialParameters,\n    mesh::AbstractMesh,\n    forceDisplacement::ForceDisplacement,\n    network::DislocationNetwork,\n    idx = nothing,\n)\n\nIn-plce computation of total force on dislocation segments.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.calc_σHat","page":"API","title":"DDD.calc_σHat","text":"calc_σHat(\n    mesh::RegularCuboidMesh{T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14} where {T1 <: LinearElement,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14},\n    forceDisplacement::ForceDisplacement,\n    x0,\n)\n\nCompute the stress, ̂σ, on a dislocation segment x0 as a result of body forces on a RegularCuboidMesh composed of LinearElement()(@ref). Used by calcPKForce.\n\nReturns\n\nσ = [\n        σxx σxy σxz\n        σxy σyy σyz\n        σxz σyz σzz\n    ]\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.calcPKForce","page":"API","title":"DDD.calcPKForce","text":"calcPKForce(\n    mesh::AbstractMesh,\n    forceDisplacement::ForceDisplacement,\n    network::DislocationNetwork,\n    idx = nothing,\n)\n\nCompute the Peach-Koehler force on segments by using calc_σHat.\n\nf = (hatmathbbsigma cdot overrightarrowb) times overrightarrowt\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.calcPKForce!","page":"API","title":"DDD.calcPKForce!","text":"calcPKForce!(\n    mesh::AbstractMesh,\n    forceDisplacement::ForceDisplacement,\n    network::DislocationNetwork,\n    idx = nothing,\n)\n\nIn-place computation of the Peach-Koehler force on segments by using calc_σHat.\n\nf = (hatmathbbsigma cdot overrightarrowb) times overrightarrowt\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.calcSelfForce","page":"API","title":"DDD.calcSelfForce","text":"calcSelfForce(\n    dlnParams::DislocationParameters,\n    matParams::MaterialParameters,\n    network::DislocationNetwork,\n    idx = nothing,\n)\n\nCompute the self-interaction force on dislocation segments.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.calcSelfForce!","page":"API","title":"DDD.calcSelfForce!","text":"calcSelfForce!(\n    dlnParams::DislocationParameters,\n    matParams::MaterialParameters,\n    network::DislocationNetwork,\n    idx = nothing,\n)\n\nIn-place computation of the self-interaction force on dislocation segments.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.calcSegSegForce","page":"API","title":"DDD.calcSegSegForce","text":"calcSegSegForce(\n    dlnParams::DislocationParameters,\n    matParams::MaterialParameters,\n    network::DislocationNetwork,\n    idx = nothing,\n)\n\nCompute the segment-segment forces for every dislocation segment.\n\nDetails found in Appendix A.1. in \"Enabling Strain Hardening Simulations with Dislocation Dynamics\" by A. Arsenlis et al.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.calcSegSegForce!","page":"API","title":"DDD.calcSegSegForce!","text":"calcSegSegForce!(\n    dlnParams::DislocationParameters,\n    matParams::MaterialParameters,\n    network::DislocationNetwork,\n    idx = nothing,\n)\n\nIn-place computation of the segment-segment forces for every dislocation segment.\n\nDetails found in Appendix A.1. in \"Enabling Strain Hardening Simulations with Dislocation Dynamics\" by A. Arsenlis et al.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.dlnMobility","page":"API","title":"DDD.dlnMobility","text":"dlnMobility(\n    dlnParams::DislocationParameters{T1,T2,T3,T4} where {T1 <: mobBCC,T2,T3,T4},\n    matParams::MaterialParameters,\n    network::DislocationNetwork,\n    idx = nothing,\n)\n\nCompute the nodal force and velocities for a BCC material.\n\nOriginal by Bruce Bromage at the Department of Materials of the University of Oxford, @brucebromage on github.\n\nThis is outdated, new capabilities include rotating the frame of reference and better handling of cross-slip.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.dlnMobility!","page":"API","title":"DDD.dlnMobility!","text":"dlnMobility!(\n    dlnParams::DislocationParameters{T1,T2,T3,T4} where {T1 <: mobBCC,T2,T3,T4},\n    matParams::MaterialParameters,\n    network::DislocationNetwork,\n    idx = nothing,\n)\n\nIn-place computation of the nodal force and velocities for a BCC material.\n\nOriginal by Bruce Bromage at the Department of Materials of the University of Oxford, @brucebromage on github.\n\nThis is outdated, new capabilities include rotating the frame of reference and better handling of cross-slip.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.splitNode!","page":"API","title":"DDD.splitNode!","text":"splitNode!(network::DislocationNetwork, splitNode, splitConnect, midCoord, midVel)\n\nSplits node splitNode along connection splitConnect, puts it at coordinate midCoord with velocity midVel. If it is called from within refineNetwork!, midCoord and midVel are the coordinate between splitNode and the node connected to it via splitConnect and gives it the mean velocity of the two nodes.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.refineNetwork!","page":"API","title":"DDD.refineNetwork!","text":"refineNetwork!(\n    dlnParams::DislocationParameters,\n    matParams::MaterialParameters,\n    mesh::AbstractMesh,\n    forceDisplacement::ForceDisplacement,\n    network::DislocationNetwork,\n)\n\nRefines a dislocation network to ensure all the segments are shorter than the maximum allowable length and so no two links form a triangle with an area over the maximum allowed.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.removeNode!","page":"API","title":"DDD.removeNode!","text":"removeNode!(network::DislocationNetwork, nodeGone, lastNode = nothing)\n\nRemoves node nodeGone from network.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.removeConnection!","page":"API","title":"DDD.removeConnection!","text":"removeConnection!(network::DislocationNetwork, nodeKept, connectGone)\n\nRemoves connection connectGone from nodeKept.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.removeLink!","page":"API","title":"DDD.removeLink!","text":"removeLink!(network::DislocationNetwork, linkGone, lastLink = nothing)\n\nRemoves link linkGone and uses lastLink to reoganise the network.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.mergeNode!","page":"API","title":"DDD.mergeNode!","text":"mergeNode!(network::DislocationNetwork, nodeKept, nodeGone)\n\nMerges nodeGone into nodeKept.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.coarsenNetwork!","page":"API","title":"DDD.coarsenNetwork!","text":"coarsenNetwork!(\n    dlnParams::DislocationParameters,\n    matParams::MaterialParameters,\n    mesh::AbstractMesh,\n    forceDisplacement::ForceDisplacement,\n    network::DislocationNetwork,\n)\n\nCoarsens network such that no links are smaller than the minimum allowable length and so that no two links form triangles with area under the minimum allowed.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.findIntersectVolume","page":"API","title":"DDD.findIntersectVolume","text":"findIntersectVolume(mesh::AbstractMesh, l, l0, tmpArr)\n\nFind the shortest intersecting distance between a vector l passing through the point l0 and an AbstractMesh.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.makeSurfaceNode!","page":"API","title":"DDD.makeSurfaceNode!","text":"makeSurfaceNode!(mesh::AbstractMesh,  network::DislocationNetwork, node1, node2, idx)\n\nCreates a surface node between node1 and node2, using connection idx of node1 of a DislocationNetwork on the surface of an AbstractMesh\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.remeshSurfaceNetwork!","page":"API","title":"DDD.remeshSurfaceNetwork!","text":"remeshSurfaceNetwork!(mesh::AbstractMesh, network::DislocationNetwork)\n\nRemeshes a DislocationNetwork's nodes on the surface of an AbstractMesh.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.coarsenVirtualNetwork!","page":"API","title":"DDD.coarsenVirtualNetwork!","text":"coarsenVirtualNetwork!(dlnParams::DislocationParameters, network::DislocationNetwork)\n\nCheck whether virtual nodes can be eliminated based on:\n\nIf they are not connected to any surface nodes\nIf they are not due to an angle change in the simulated volume surface\n\nBruce Bromage, Github @brucebromage Michromechanical Testing Group Department of Materials, University of Oxford bruce.bromage@materials.ox.ac.uk May 2017\n\nAdapted Jan 2021 Daniel Celis Garza, Github @dcelisgarza\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.shapeFunction","page":"API","title":"DDD.shapeFunction","text":"shapeFunction(::LinearQuadrangle3D, x, y, z)\n\nComputes the linear shape functions N[1:8] for an (x, y, z) point on a 3D linear quadrangle.\n\n\n\n\n\nshapeFunction(::LinearQuadrangle3D, x::AbstractVector, y::AbstractVector, z::AbstractVector)\n\nComputes the linear shape functions N[1:8][p] for (x, y, z) point p on a 3D linear quadrangle.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.shapeFunctionDeriv","page":"API","title":"DDD.shapeFunctionDeriv","text":"shapeFunctionDeriv(shape<:AbstractShapeFunction, x, y, z)\n\nComputes the derivatives of the linear shape functions N[1:3, 1:8] for an (x, y, z) point on a 3D linear quadrangle.\n\nReturns\n\ndNdS[x, n](x,y,z) := x'th derivative of shape function n.\n\n\n\n\n\nshapeFunctionDeriv(shape<:AbstractShapeFunction, x::AbstractVector, y::AbstractVector, z::AbstractVector)\n\nComputes the derivatives of the linear shape functions N[1:3, 1:8] for an (x, y, z) point on a 3D linear quadrangle.\n\nReturns\n\ndNdS[x, n, p](x,y,z) := x'th derivative of shape function n for point p.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.deriv!","page":"API","title":"DDD.deriv!","text":"deriv!(\n    dlnParams::DislocationParameters,\n    matParams::MaterialParameters,\n    mesh::AbstractMesh,\n    forceDisplacement::ForceDisplacement,\n    network::DislocationNetwork,\n)\n\nComputes the nodal velocities of a network.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.integrate!","page":"API","title":"DDD.integrate!","text":"integrate!(\n    intParams::IntegrationParameters{T1,T2,T3} where {T1 <: AdaptiveEulerTrapezoid,T2,T3},\n    intVars::IntegrationTime,\n    dlnParams::DislocationParameters,\n    matParams::MaterialParameters,\n    mesh::AbstractMesh,\n    forceDisplacement::ForceDisplacement,\n    network::DislocationNetwork,\n)\n\nIntegrates nodal velocities using a time-adaptive Euler-Trapezoid method.\n\n\n\n\n\n","category":"function"},{"location":"api/#Utility-1","page":"API","title":"Utility","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"loopDistribution\nlimits!\ntranslatePoints!\nmakeSegment\nmakeConnect\nmakeConnect!\ngetSegmentIdx\ngetSegmentIdx!\ncheckNetwork","category":"page"},{"location":"api/#DDD.loopDistribution","page":"API","title":"DDD.loopDistribution","text":"loopDistribution(::Rand, n, args...; kw...)\n\nReturns a 3 × n matrix whose points follow a random uniform distribution. Used by DislocationNetwork when the dist parameter of DislocationLoop is Rand().\n\n\n\n\n\nloopDistribution(::Zeros, n, args...; kw...)\n\nReturns a 3 × n zeros matrix. Used by DislocationNetwork when the dist parameter of DislocationLoop is Zeros().\n\n\n\n\n\nloopDistribution(::Rand, n, args...; kw...)\n\nReturns a 3 × n matrix whose points follow a random normal distribution. Used by DislocationNetwork when the dist parameter of DislocationLoop is Randn().\n\n\n\n\n\nloopDistribution(::Rand, n, args...; kw...)\n\nReturns a 3 × n matrix whose points follow are regularly placed. Used by DislocationNetwork when the dist parameter of DislocationLoop is Regular().\n\nnote: Note\nNot yet implemented.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.limits!","page":"API","title":"DDD.limits!","text":"limits!(lims, segLen, range, buffer)\n\nCompute the bounding limits within which a DislocationLoop will be distributed in a DislocationNetwork.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.translatePoints!","page":"API","title":"DDD.translatePoints!","text":"translatePoints!(coord, lims, disp)\n\nTranslates coordinates using the limits and displacements calculated by limits! and loopDistribution.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.makeSegment","page":"API","title":"DDD.makeSegment","text":"makeSegment(::segEdge, slipPlane, bVec)\n\nReturn the edge segment (slipPlane × bVec) / || slipPlane × bVec ||. Used to create segments for DislocationNetwork.\n\n\n\n\n\nmakeSegment(::segEdge, slipPlane, bVec)\n\nReturn the edge segment slipPlane / || slipPlane ||. Used to create segments for DislocationNetwork.\n\n\n\n\n\nmakeSegment(::segScrew, slipPlane, bVec)\n\nReturn the screw segment bVec / || bVec ||. Used to create segments for DislocationNetwork.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.makeConnect","page":"API","title":"DDD.makeConnect","text":"makeConnect(links, maxConnect)\n\nCreates connectivity and linksConnect matrices for DislocationNetwork. \n\nconnectivity contains the number of other other nodes each node is connected to, up to maxConnect other nodes. Every (2i, j) entry contains a node connected to node j. Every (2i+1, j) coordinate contains whether that node is the first or second node in the link.\nlinksConnect relates connections enabled by a link. Analogous to the connectivity of a link.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.makeConnect!","page":"API","title":"DDD.makeConnect!","text":"makeConnect!(network::DislocationNetwork)\n\nMutates the connectivity and linksConnect matrices of network. Works the same as makeConnect.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.getSegmentIdx","page":"API","title":"DDD.getSegmentIdx","text":"getSegmentIdx(links, label)\n\nFinds the indices of a link and corresponding nodes.\n\nReturns\n\nn × 3 matrix is of the form [i, node1, node2]. \n\ni can be used to find the Burgers vector, slip plane and segment forces of segment i, eg bVec[:, i]. \nnode1 and node2 can be used to find the coordinate and velocity of the nodes, eg l = coord[:, node2] - coord[:, node1].\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.getSegmentIdx!","page":"API","title":"DDD.getSegmentIdx!","text":"getSegmentIdx!(network::DislocationNetwork)\n\nMutates the segIdx matrix in network. Works the same way as getSegmentIdx.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.checkNetwork","page":"API","title":"DDD.checkNetwork","text":"checkNetwork(network::DislocationNetwork)\n\nChecks the validity of the dislocation network. It ensures the following conditions are met by the member variables of network:\n\nconnectivity and links have the same number of non-zero entries;\nall entries in bVec are non-zero;\nonly the trailing columns of connectivity are zeros;\nconsistency between connectivity and links;\nbVec is conserved among connected nodes;\nentries in links are unique;\nconsistency betwen connectivity and linksConnect\n\n\n\n\n\n","category":"function"},{"location":"api/#Post-Processing-1","page":"API","title":"Post Processing","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"plotNodes\nplotNodes!\nplotFEDomain","category":"page"},{"location":"api/#DDD.plotNodes","page":"API","title":"DDD.plotNodes","text":"plotNodes(network::DislocationNetwork, args...; kw...)\n\nPlots DislocationNetwork.\n\n\n\n\n\nplotNodes(mesh::AbstractMesh, network::DislocationNetwork, args...; kw...)\n\nPlots DislocationNetwork inside AbstractMesh.\n\n\n\n\n\nplotNodes(loop::DislocationLoop, args...; kw...)\n\nPlots DislocationLoop.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.plotNodes!","page":"API","title":"DDD.plotNodes!","text":"plotNodes!(fig, network::DislocationNetwork, args...; kw...)\n\nIn-place plots DislocationNetwork.\n\n\n\n\n\nplotNodes!(fig, mesh::AbstractMesh, network::DislocationNetwork, args...; kw...)\n\nIn-place plots DislocationNetwork inside AbstractMesh.\n\n\n\n\n\nplotNodes!(fig, loop::DislocationLoop, args...; kw...)\n\nIn-place plots DislocationLoop.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.plotFEDomain","page":"API","title":"DDD.plotFEDomain","text":"plotFEDomain(mesh::AbstractMesh)\n\nPlots corners, edges and surfaces of AbstractMesh.\n\n\n\n\n\n","category":"function"},{"location":"api/#Misc-support-functions-1","page":"API","title":"Misc support functions","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"compStruct\ninternalAngle\nexternalAngle\nrot3D\n⊗\nlinePlaneIntersect\ngausslegendre(n::Integer, a, b)","category":"page"},{"location":"api/#DDD.compStruct","page":"API","title":"DDD.compStruct","text":"compStruct(arg1, arg2; verbose::Bool = false)\n\nCompares values of the fields of two variables arg1 and arg2 with the same structure. If verbose = true, it will print which fields are different from each other.\n\nExamples\n\njulia> struct MyStruct1; x; end\njulia> test1 = MyStruct1(1)\nMyStruct1(1)\njulia> test2 = MyStruct1(5)\nMyStruct1(5)\njulia> compStruct(test1, test2; verbose = true)\nStructures differ in field: x.\nfalse\njulia> compStruct(1, 1; verbose = true)\ntrue\njulia> compStruct(1, [1]; verbose = true)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.internalAngle","page":"API","title":"DDD.internalAngle","text":"internalAngle(n::Int)\n\nCompute the interior angle of a regular polygon with n sides.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.externalAngle","page":"API","title":"DDD.externalAngle","text":"externalAngle(n::Int)\n\nCompute the exterior angle of a regular polygon with n sides.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.rot3D","page":"API","title":"DDD.rot3D","text":"rot3D(xyz, uvw, abc, θ)\n\nRotate point xyz about the vector uvw that crosses point abc by the angle θ. Further details found here.\n\nExamples\n\njulia> rot3D([1;1;1],[1;0;0],[0;0;0],π/2)\n3-element Array{Float64,1}:\n  1.0\n -0.9999999999999999\n  1.0\njulia> rot3D([1;1;1],[1;0;0],[0;0;0],-π/2)\n3-element Array{Float64,1}:\n1.0\n1.0\n-0.9999999999999999\njulia> rot3D([1;1;1],[1;0;0],[0;0;0],π)\n3-element Array{Float64,1}:\n  1.0\n -1.0000000000000002\n -0.9999999999999999\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.:⊗","page":"API","title":"DDD.:⊗","text":"⊗(x::AbstractVector, y::AbstractVector)\n\nTensor product.\n\n\n\n\n\n","category":"function"},{"location":"api/#DDD.linePlaneIntersect","page":"API","title":"DDD.linePlaneIntersect","text":"linePlaneIntersect(n::T, p0::T, l::T, l0::T) where {T <: AbstractVector}\n\nFinds the intersect between a line and a plane. n is the plane normal, p0 is a point on the plane, l is the line vector, l0 is a point on a line.\n\n\n\n\n\n","category":"function"},{"location":"api/#FastGaussQuadrature.gausslegendre-Tuple{Integer,Any,Any}","page":"API","title":"FastGaussQuadrature.gausslegendre","text":"gausslegendre(n::Integer, a, b)\n\nCompute Gauss-Legendre quadrature points and weights for the interval [a, b].\n\n\n\n\n\n","category":"method"},{"location":"#DDD-1","page":"Home","title":"DDD","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"(Image: Dev) (Image: Build Status) (Image: Build Status) (Image: Codecov) (Image: Coveralls)","category":"page"}]
}
