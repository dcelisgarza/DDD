<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · DDD.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.svg" alt="DDD.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DDD.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Example-1"><span>Example</span></a></li><li><a class="tocitem" href="#Initialisation-1"><span>Initialisation</span></a></li><li><a class="tocitem" href="#IO-1"><span>IO</span></a></li><li class="toplevel"><a class="tocitem" href="#TODO/WIP-1"><span>TODO/WIP</span></a></li><li><a class="tocitem" href="#Shaky,-move-y-bois-1"><span>Shaky, move-y bois</span></a></li><li><a class="tocitem" href="#Working-Objectives-1"><span>Working Objectives</span></a></li></ul></li><li><a class="tocitem" href="Dislocations/">Dislocations</a></li><li><a class="tocitem" href="motivation/">Motivation</a></li><li><a class="tocitem" href="idx/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/dcelisgarza/DDD.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="DDD-1"><a class="docs-heading-anchor" href="#DDD-1">DDD</a><a class="docs-heading-anchor-permalink" href="#DDD-1" title="Permalink"></a></h1><p>&lt;!– <a href="https://dcelisgarza.github.io/DDD.jl/stable"><img src="https://img.shields.io/badge/docs-stable-blue.svg" alt="Stable"/></a> –&gt; <a href="https://dcelisgarza.github.io/DDD.jl/dev"><img src="https://img.shields.io/badge/docs-dev-blue.svg" alt="Dev"/></a> <a href="https://travis-ci.com/dcelisgarza/DDD.jl"><img src="https://travis-ci.com/dcelisgarza/DDD.jl.svg?branch=master" alt="Build Status"/></a> <a href="https://ci.appveyor.com/project/dcelisgarza/DDD-jl"><img src="https://ci.appveyor.com/api/projects/status/github/dcelisgarza/DDD.jl?svg=true" alt="Build Status"/></a> <a href="https://codecov.io/gh/dcelisgarza/DDD.jl"><img src="https://codecov.io/gh/dcelisgarza/DDD.jl/branch/master/graph/badge.svg" alt="Codecov"/></a> <a href="https://coveralls.io/github/dcelisgarza/DDD.jl?branch=master"><img src="https://coveralls.io/repos/github/dcelisgarza/DDD.jl/badge.svg?branch=master" alt="Coveralls"/></a></p><p>New generation of 3D Discrete Dislocation Dynamics codes.</p><p>Dislocation dynamics is a complex field with an enormous barrier to entry. The aim of this project is to create a codebase that is:</p><ul><li>Easy to use.</li><li>Easy to maintain.</li><li>Easy to develop for.</li><li>Modular.</li><li>Idiot proof.</li><li>Well documented and tested.</li><li>Performant.</li><li>Easily parallelisable.</li></ul><h1 id="Example-1"><a class="docs-heading-anchor" href="#Example-1">Example</a><a class="docs-heading-anchor-permalink" href="#Example-1" title="Permalink"></a></h1><h2 id="Initialisation-1"><a class="docs-heading-anchor" href="#Initialisation-1">Initialisation</a><a class="docs-heading-anchor-permalink" href="#Initialisation-1" title="Permalink"></a></h2><p>Before running a simulation we need to initialise the simulation. For this example, we will use the keyword initialisers because they automatically calculate derived quantities, perform input validations, provide default values, and are make for self-documenting code.</p><p>Dislocations live in a material, as such we need a few constants that describe it. These are encapsulated in the immutable &lt;sup&gt;<a href="#1">1</a>&lt;/sup&gt; structure <code>MaterialParameters</code>. Note that we use unicode to denote variables as per convention, <code>\mu -&gt; μ</code> and <code>\nu -&gt; ν</code>. Here we create a basic material.</p><pre><code class="language-julia">julia&gt; MaterialParameters = MaterialParameters(;
          μ = 1.0,                  # Shear modulus.
          μMag = 145e3,             # Shear modulus magnitude.
          ν = 0.28,                 # Poisson ratio.
          E = 1.0,                  # Young&#39;s modulus, MPa.
          crystalStruct = BCC(),    # Crystal structure.
          σPN = 0.0                 # Peierls-Nabarro stress for the material.
        )
MaterialParameters{Float64,BCC}(1.0, 145000.0, 0.28, 1.0, 1.3888888888888888, 0.3888888888888889, 0.07957747154594767, 0.039788735772973836, 0.11052426603603843, BCC(), 0.0)</code></pre><p>Note that a few extra constants have been automatically calculated by the constructor. We find these using <code>fieldnames()</code>.</p><pre><code class="language-julia">julia&gt; fieldnames(typeof(MaterialParameters))
(:μ, :μMag, :ν, :E, :σPN, :omνInv, :νomνInv, :μ4π, :μ8π, :μ4πν, :crystalStruct)</code></pre><p>Where <code>omνInv = 1/(1-ν)</code>, <code>νomνInv = v/(1-ν)</code>, <code>μ4π = μ/(4π)</code>, <code>μ8π = μ/(8π)</code>, <code>μ4πν = μ/[4π(1-ν)]</code>. This avoids recomputing them later.</p><p>Our dislocations also have certain constant parameters and flags that are encapsulated in their own immutable structure, <code>DislocationParameters</code>. The numeric parameters are somewhat arbitrary as long as they hold certain proportions.</p><pre><code class="language-julia">julia&gt; DislocationParameters = DislocationParameters(;
          coreRad = 90.0,       # Dislocation core radius, referred to as a.
          coreRadMag = 3.2e-4,  # Magnitude of the core radius.
          minSegLen = 320.0,    # Minimum segment length.
          maxSegLen = 1600.0,   # Maximum segment length.
          minArea = 45000.0,    # Minimum allowable area enclosed by two segments.
          maxArea = 20*45000.0, # Maximum allowable area enclosed by two segments.
          maxConnect = 4,       # Maximum number of connections a node can have.
          remesh = true,        # Flag for remeshing.
          collision = true,     # Flag for collision checking.
          separation = true,    # Flag for node separation.
          virtualRemesh = true, # Flag for remeshing virtual nodes.
          parCPU = false,       # Parallelise on CPU
          parGPU = false,       # Parallelise on GPU
          edgeDrag = 1.0,       # Drag coefficient for edge segments.
          screwDrag = 2.0,      # Drag coefficient for screw segments.
          climbDrag = 1e10,     # Drag coefficient along the climb direction.
          lineDrag = 0.0,       # Drag coefficient along the line direction.
          mobility = mobBCC(),  # Mobility type for mobility function specialisation.
        )
DislocationParameters{Float64,Int64,Bool,mobBCC}(90.0, 8100.0, 0.00032, 320.0, 1600.0, 45000.0, 900000.0, 4, true, true, true, true, true, true, 1.0, 2.0, 1.0e10, 0.0, mobBCC())</code></pre><p>The integration parameters are placed into the following immutable structure.</p><pre><code class="language-julia">julia&gt; IntegrationParameters(;
      method = CustomTrapezoid(),
      tmin = 0.0,
      tmax = 1e10,
      dtmin = 1e-6,
      dtmax = 1e15,
      abstol = 1e-6,
      reltol = 1e-6,
      maxchange = 1.2,
      exponent = 20.0,
      maxiter = 10,
  )

IntegrationParameters{CustomTrapezoid,Float64,Int64}(CustomTrapezoid(), 0.0, 1.0e10, 1.0e-6, 1.0e15, 1.0e-6, 1.0e-6, 1.2, 20.0, 10)</code></pre><p>And we keep track of the time, step, and time step in this mutable one.</p><pre><code class="language-julia">julia&gt; IntegrationTime(;
      dt = 100,
      time = 0.0,
      step = 0,
)
IntegrationTime{Float64,Int64}(100.0, 0.0, 0)</code></pre><p>Within a given material, we have multiple slip systems, which can be loaded into their own immutable structure. Here we only define a single slip system, but we have the capability of adding <code>n</code> slip systems by making the <code>slipPlane</code> and <code>bVec</code> arguments <code>m × n</code> matrices rather than <code>m</code> vectors.</p><pre><code class="language-julia">julia&gt; slipSystems = SlipSystem(;
          crystalStruct = BCC(),
          slipPlane = [1.0; 1.0; 1.0],  # Slip plane.
          bVec = [1.0; -1.0; 0.0]       # Burgers vector.
       )
SlipSystem{BCC,Array{Float64,1}}(BCC(), [1.0, 1.0, 1.0], [1.0, -1.0, 0.0])</code></pre><p>We also need dislocation sources. We make use of Julia&#39;s type system to create standard functions for loop generation. We provide a way to easily and quickly generate loops whose segments inhabit the same slip system. However, new <code>DislocationLoop()</code> methods can be made by subtyping <code>AbstractDlnStr</code>, and dispatching on the new type. One may of also course also use the default constructor and build the initial structures manually.</p><p>Here we make a regular pentagonal prismatic dislocation loop, and a regular hexagonal prismatic dislocation loop. The segments may be of arbitrary length, but having asymmetric sides may result in very ugly, irregular dislocations that may be unphysical or may end up remeshing as soon as the simulation gets under way. As such, we recommend making the segment lengths symmetric.</p><pre><code class="language-julia">julia&gt; prisPentagon = DislocationLoop(
          loopPrism();    # Prismatic loop, all segments are edge segments.
          numSides = 5,   # 5-sided loop.
          nodeSide = 1,   # One node per side, if 1 nodes will be in the corners.
          numLoops = 20,  # Number of loops of this type to generate when making a network.
          segLen = 10 * ones(5),  # Length of each segment between nodes, equal to the number of nodes.
          slipSystem = 1, # Slip System (assuming slip systems are stored in a file, this is the index).
          _slipPlane = slipSystems.slipPlane,  # Slip plane of the segments.
          _bVec = slipSystems.bVec,            # Burgers vector of the segments.
          label = nodeType[1; 2; 1; 2; 1],    # Node labels, has to be equal to the number of nodes.
          buffer = 0.0,   # Buffer to increase the dislocation spread.
          range = Float64[          # Distribution range
                        -100 100; # xmin, xmax          
                        -100 100; # ymin, ymax
                        -100 100  # zmin, zmax
                      ],
          dist = Rand(),  # Loop distribution.
      )
DislocationLoop{loopPrism,Int64,Array{Float64,1},Int64,Array{Int64,2},Array{Float64,2},Array{nodeType,1},Float64,Rand}(loopPrism(), 5, 1, 20, [10.0, 10.0, 10.0, 10.0, 10.0], 1, [1 2 … 4 5; 2 3 … 5 1], [0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258; 0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258; 0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258], [0.7071067811865475 0.7071067811865475 … 0.7071067811865475 0.7071067811865475; -0.7071067811865475 -0.7071067811865475 … -0.7071067811865475 -0.7071067811865475; 0.0 0.0 … 0.0 0.0], [-1.932030909139515 4.820453044614565 … -1.785143053581134 -6.014513813778146; -1.932030909139515 4.820453044614565 … -1.785143053581134 -6.014513813778146; -8.055755266097462 -5.087941102678986 … 8.123251093712414 0.10921054317980072], nodeType[DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob], 0.0, [-100.0 100.0; -100.0 100.0; -100.0 100.0], Rand())

julia&gt; shearHexagon = DislocationLoop(
          loopShear();    # Shear loop
          numSides = 6,
          nodeSide = 3,   # 3 nodes per side, it devides the side into equal segments.
          numLoops = 20,
          segLen = 10 * ones(3 * 6) / 3,  # The hexagon&#39;s side length is 10, each segment is 10/3.
          slipSystem = 1,
          _slipPlane = slipSystems.slipPlane,
          _bVec = slipSystems.bVec,
          label = nodeType[1; 2; 1; 2; 1; 2; 1; 2; 1; 2; 1; 2; 1; 2; 1; 2; 1; 2],
          buffer = 0.0,
          range = Float64[
                        -100 100;
                        -100 100;
                        -100 100
                      ],
          dist = Rand(),
      )
DislocationLoop{loopShear,Int64,Array{Float64,1},Int64,Array{Int64,2},Array{Float64,2},Array{nodeType,1},Float64,Rand}(loopShear(), 6, 3, 20, [3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335], 1, [1 2 … 17 18; 2 3 … 18 1], [0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258; 0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258; 0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258], [0.7071067811865475 0.7071067811865475 … 0.7071067811865475 0.7071067811865475; -0.7071067811865475 -0.7071067811865475 … -0.7071067811865475 -0.7071067811865475; 0.0 0.0 … 0.0 0.0], [5.443310539518175 6.8041381743977185 … 1.3608276348795458 4.082482904638633; -6.804138174397717 -5.443310539518174 … -6.804138174397715 -8.164965809277255; 1.3608276348795436 -1.3608276348795432
… 5.443310539518167 4.082482904638622], nodeType[DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix], 0.0, [-100.0 100.0; -100.0 100.0; -100.0 100.0], Rand())</code></pre><p>The dislocation loops will be centred about the origin, but the <code>range</code>, <code>buffer</code> and <code>dist</code> parameters will distribute them about the simulation domain when the network is generated. The type of <code>dist</code> must be a concrete subtype of <code>AbstractDistribution</code> and a corresponding <code>loopDistribution()</code> method should be defined. If a non-suported distribution is required, you only need to create a concrete subtype of <code>AbstractDistribution</code> and a new method of <code>loopDistribution()</code> to dispatch on the new type. This is all the reworking needed, since multiple dispatch will take care of any new distributions when generating the dislocation network.</p><p>Note the use of a <code>nodeType</code> array. This is an enumerated type which ensures node types are limited to only those supported by the model while lowering the memory footprint and increasing performance.</p><p>We can plot our loops with <code>plotNodes</code>. We use <code>plotlyjs()</code> because it provides a nice interactive experience but any <code>Plots.jl</code> compatible backend will work. Since both loops have the same slip system but one is a shear and the other a prismatic loop, they are orthogonal to each other.</p><pre><code class="language-julia">julia&gt; using Plots
julia&gt; plotlyjs()
julia&gt; fig1 = plotNodes(
          shearHexagon,
          m = 1,
          l = 3,
          linecolor = :blue,
          markercolor = :blue,
          legend = false,
        )
julia&gt; plotNodes!(fig1, prisPentagon, m = 1, l = 3,
                  linecolor = :red, markercolor = :red, legend = false)
julia&gt; plot!(fig1, camera=(100,35), size=(400,400))</code></pre><p><img src="/examples/loops.png" alt="loops"/></p><p>After generating our primitive loops, we can create a network using either a vector of dislocation loops or a single dislocation loop. The network may also be created manually, and new constructor methods may be defined for bespoke cases. For our purposes, we use the constructor that dispatches on <code>Union{DislocationLoop, AbstractVector{&lt;:DislocationLoop}}</code>, meaning a single variable whose type is <code>DislocationLoop</code> or a vector of them. Here we use a vector with both our loop structures.</p><p>Since the networks are constantly evolving entities, this necessarily means we need a mutable structure.</p><pre><code class="language-julia">julia&gt; network = DislocationNetwork(
          [shearHexagon, prisPentagon]; # Dispatch type, bespoke functions dispatch on this.
          memBuffer = 1 # Buffer for memory allocation.
       )
 DislocationNetwork{Array{Int64,2},Array{Float64,2},Array{nodeType,1},Int64,Array{Int64,2},Array{Float64,3}}([1 2 … 459 460; 2 3 … 460 456], [0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258; 0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258; 0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258], [0.7071067811865475 0.7071067811865475 … 0.7071067811865475 0.7071067811865475; -0.7071067811865475 -0.7071067811865475 … -0.7071067811865475 -0.7071067811865475; 0.0 0.0 … 0.0 0.0], [46.39761283211718 47.75844046699673 … -57.496002894414175 -61.72537365461118; -49.937613036904054 -48.57678540202451 … -59.28380906452193 -63.51317982471895; 41.67317243370178 38.9515171639427 … -2.1285556467706765 -10.14259619730329], nodeType[DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix  …  DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob], [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0], 460, 460, 4, [2 2 … 2 2; 1 1 … 458 459; … ; 0 0 … 0 0; 0 0 … 0 0], [1 2 … 2 2; 1 1 … 1 2], [1 1 2; 2 2 3; … ; 459 459 460; 460 460 456],
 [0.0 0.0; 0.0 0.0; 0.0 0.0]
 [0.0 0.0; 0.0 0.0; 0.0 0.0]
 [0.0 0.0; 0.0 0.0; 0.0 0.0]
 ...
 [0.0 0.0; 0.0 0.0; 0.0 0.0]
 [0.0 0.0; 0.0 0.0; 0.0 0.0]
 [0.0 0.0; 0.0 0.0; 0.0 0.0])</code></pre><p>This method automatically takes the previously defined loops, and scatters them according to the parameters provided in the <code>DislocationLoop</code> structure. Furthermore, <code>memBuffer</code> defaults to <code>N log2(N)</code> loops where <code>N</code> is the total number of nodes and links. If <code>memBuffer</code> is provided, the number of nodes allocated is <code>memBuffer * N</code>. Here we allocate just enough memory for all the nodes but no more. The software is capable of expanding the arrays as needed using the same <code>N log2(N)</code> heuristic as it approximates graph growth. Minimising memory management is advisable to increase performance.</p><p>This function will also automatically calculate other quantities to keep track of the network&#39;s links, nodes and segments.</p><pre><code class="language-julia">julia&gt; fieldnames(typeof(network))
(:links, :slipPlane, :bVec, :coord, :label, :nodeVel, :numNode, :numSeg, :maxConnect, :connectivity, :linksConnect, :segIdx, :segForce)</code></pre><p>We can also view our network with <code>plotNodes</code>.</p><pre><code class="language-julia">julia&gt; fig2 = plotNodes(
          network,
          m = 1,
          l = 3,
          linecolor = :blue,
          markercolor = :blue,
          legend = false,
        )
julia&gt; plot!(fig2, camera=(110,40), size=(400,400))</code></pre><p><img src="/examples/network.png" alt="network"/></p><p>&lt;a name=&quot;1&quot;&gt;1&lt;/a&gt;: Immutability is translated into code performance.</p><h2 id="IO-1"><a class="docs-heading-anchor" href="#IO-1">IO</a><a class="docs-heading-anchor-permalink" href="#IO-1" title="Permalink"></a></h2><p>The package provides a way to load and save its parameters using <code>JSON</code> files. While this is <em>not</em> the most performant format for IO, it is a popular and portable, web-friendly file format that is very human readable (and therefore easy to manually create). It also produces smaller file sizes both compressed and uncompressed. Which is why it is so popular for online data sharing.</p><p><code>JSON</code> files are representations of dictionaries with <code>(key, value)</code> pairs, which are analogous to the <code>(key, value)</code> pair of structures. This makes it so any changes to any structure will automatically be taken care of by the <code>JSON</code> library. Arrays are recursively linearised into vectors of vectors using the calling language&#39;s preferred storage order. This means arrays preserve their shape and dimensionality regardless of whether the inputting or outputting language stores arrays in column- or row-major order.</p><p><code>JSON.jl</code> is surprisingly performant, on par with the in-built serialiser and faster than other specialised IO libraries, only <code>JLD2</code> is faster. However <code>JLD2</code> is no longer actively maintained. However, the memory allocated during writing is quite a lot larger with <code>JSON.jl</code> than all other methods, but it also generates the smallest compressed and uncompressed files.</p><h3 id="Sample-JSON-File-1"><a class="docs-heading-anchor" href="#Sample-JSON-File-1">Sample JSON File</a><a class="docs-heading-anchor-permalink" href="#Sample-JSON-File-1" title="Permalink"></a></h3><p>This is a sample <code>JSON</code> file for a dislocation loop. They can be compactified by editors to decrease storage space by removing unnecessary line breaks and spaces. Here we show a somewhat longified view which is very human readable and trivially easy to create manually. Note that arrays are recursively linearised as vectors of vectors, where the linearisation follows the calling language&#39;s memory order. This means arrays will keep their shape and dimensionality regardless of the language that opens the JSON file.</p><pre><code class="language-JSON">{
  &quot;loopType&quot;: &quot;DDD.loopPrism()&quot;,
  &quot;numSides&quot;: 4,
  &quot;nodeSide&quot;: 2,
  &quot;numLoops&quot;: 1,
  &quot;segLen&quot;: [1, 1, 1, 1, 1, 1, 1, 1],
  &quot;slipSystem&quot;: 1,
  &quot;label&quot;: [2, 1, 2, 1, 2, 1, 2, 1],
  &quot;buffer&quot;: 0,
  &quot;range&quot;: [[0, 0, 0], [0, 0, 0]],
  &quot;dist&quot;: &quot;DDD.Zeros()&quot;
}</code></pre><p>The keys are on the left side of the colon and the values on the right. This would get loaded to a dictionary with the same <code>(key, value)</code> pair shown here. Since the keys are the structure&#39;s field names and the values their value, everything can be easily matched to the constructor function.</p><p>Since <code>JSON</code> files represent dictionaries, they automatically accommodate changes to structures. Irrelevant data can also be added as long as all keys remain unique. <code>JSON</code> also allows for arrays of dictionaries, so multiple structures can be loaded/read at the same time, this is achieved simply by wrapping the entries in square brackets and separating by commas just like other arrays.</p><h3 id="Initialisation,-Data-Dump,-and-Reloading-1"><a class="docs-heading-anchor" href="#Initialisation,-Data-Dump,-and-Reloading-1">Initialisation, Data Dump, and Reloading</a><a class="docs-heading-anchor-permalink" href="#Initialisation,-Data-Dump,-and-Reloading-1" title="Permalink"></a></h3><p>One can load all their parameters at once like so.</p><pre><code class="language-julia">fileDislocationParameters = &quot;../inputs/simParams/sampleDislocationParameters.json&quot;
fileMaterialParameters = &quot;../inputs/simParams/sampleMaterialParameters.json&quot;
fileIntegrationParameters = &quot;../inputs/simParams/sampleIntegrationParameters.json&quot;
fileSlipSystem = &quot;../data/slipSystems/SlipSystems.json&quot;
fileDislocationLoop = &quot;../inputs/dln/samplePrismShear.json&quot;
fileIntVar = &quot;../inputs/simParams/sampleIntegrationTime.json&quot;
dlnParams, matParams, intParams, slipSystems, dislocationLoop = loadParametersJSON(
    fileDislocationParameters,
    fileMaterialParameters,
    fileIntegrationParameters,
    fileSlipSystem,
    fileDislocationLoop,
)
intVars = loadIntegrationTimeJSON(fileIntVar)</code></pre><p>which not only loads the data but returns the aforementioned structures. If there is a single file holding all the parameters, then all the filenames would be the same, but nothing else would change as the file would be loaded into a large dictionary and only the relevant <code>(key, value)</code> pairs are used in each case.</p><p>Users may also load individual structures as follows.</p><pre><code class="language-julia">dictDislocationParameters = loadJSON(fileDislocationParameters)
DislocationParameters = loadDislocationParametersJSON(dictDislocationParameters)

dictMaterialParameters = loadJSON(fileMaterialParameters)
MaterialParameters = loadMaterialParametersJSON(dictMaterialParameters)

dictIntegrationParameters = loadJSON(fileIntegrationParameters)
IntegrationParameters = loadIntegrationParametersJSON(dictIntegrationParameters)

dictSlipSystem = loadJSON(fileSlipSystem)
slipSystems = loadSlipSystemJSON(dictSlipSystem)

# There can be multiple dislocation types per simulation.
dictDislocationLoop = loadJSON(fileDislocationLoop)
dislocationLoop = zeros(DislocationLoop, length(dictDislocationLoop))
for i in eachindex(dislocationLoop)
    dislocationLoop[i] = loadDislocationLoopJSON(dictDislocationLoop[i], slipSystems)
end</code></pre><p>Individually loading files like this is useful when recovering previous save states where the data was dumped into a single file, as shown here.</p><pre><code class="language-julia"># Dump simulation parameters into a single file. Creates an array where each entry is one of the structs.
paramDump = &quot;../outputs/simParams/sampleDump.json&quot;
saveJSON(paramDump, dlnParams, matParams, intParams, slipSystems, dislocationLoop)

# Dump network data into a separate file.
networkDump = &quot;../outputs/dln/sampleNetwork.json&quot;
saveJSON(networkDump, network, intVars)

# Reload parameters.
simulation = loadJSON(paramDump)
dlnParams2 = loadDislocationParametersJSON(simulation[1])
matParams2 = loadMaterialParametersJSON(simulation[2])
intParams2 = loadIntegrationParametersJSON(simulation[3])
slipSystems2 = loadSlipSystemJSON(simulation[4])
dislocationLoop2 = zeros(DislocationLoop, length(simulation[5]))
for i in eachindex(dislocationLoop2)
    dislocationLoop2[i] = loadDislocationLoopJSON(simulation[5][i], slipSystems2)
end

# Reload network.
network2 = loadNetworkJSON(networkDump[1])
intVars2 = loadIntegrationTimeJSON(networkDump[2])</code></pre><p>The reason why <code>network</code> and <code>intVars</code> are saved separately is because they change as the simulation advances, while the parameters stay the same. Saving the parameters multiple times per simulation is redundant.</p><h3 id="Against-the-Unbridled-Pursuit-of-Performance-1"><a class="docs-heading-anchor" href="#Against-the-Unbridled-Pursuit-of-Performance-1">Against the Unbridled Pursuit of Performance</a><a class="docs-heading-anchor-permalink" href="#Against-the-Unbridled-Pursuit-of-Performance-1" title="Permalink"></a></h3><p>For the sake of open, reproducible and portable science it is recommended users utilise <code>JSON</code> or a standard delimited file format for their IO. If IO is a performance bottleneck these are some incremental steps one should take to improve it before creating a custom IO format. Beware that your mileage may vary when using other IO formats, some may not be fully mature yet others may be abandoned in favour of better implementations.</p><ol><li>Use buffered IO.</li><li>Use Julia&#39;s in-built task and asyncronous functionality via <code>tasks</code> and <code>async</code> for either multiple IO streams or an asyncronous IO process while the other threads/cores carry on with the simulation.</li><li>Use internal serialiser, as of June 30, 2020 it offers no performance improvement other than in memory allocation during io stream buffering.</li><li>Use <a href="https://github.com/JuliaIO/JLD2.jl"><code>JLD2</code></a>. Though the package is no longer under active development.</li><li>Use <code>DelimitedFiles</code>.</li><li>Use binary streams.</li><li>Use <a href="https://github.com/JuliaIO/Parquet.jl"><code>Parquet</code></a></li><li>Create your own format and IO stream.</li></ol><p>TO BE WRITTEN: HOW TO EXTEND METHODS TO EXPAND FUNCTIONALITY</p><h1 id="TODO/WIP-1"><a class="docs-heading-anchor" href="#TODO/WIP-1">TODO/WIP</a><a class="docs-heading-anchor-permalink" href="#TODO/WIP-1" title="Permalink"></a></h1><h2 id="Shaky,-move-y-bois-1"><a class="docs-heading-anchor" href="#Shaky,-move-y-bois-1">Shaky, move-y bois</a><a class="docs-heading-anchor-permalink" href="#Shaky,-move-y-bois-1" title="Permalink"></a></h2><p>The integration may be buggy, I haven&#39;t tested it yet. Coarsen and refine have been tested have passed all of them.</p><p>This is a WIP but it shows network remeshing (coarsen and refining) and time integration with no applied stress.</p><p><img src="/examples/shaky.gif" alt="shaky"/></p><p>This shows the same but without network coarsening.</p><p><img src="/examples/nocoarsen.gif" alt="nocoarsen"/></p><p>This shows the same but without network refining and lower error bounds.</p><p><img src="/examples/norefine.gif" alt="norefine"/></p><p>This is just the integration.</p><p><img src="/examples/integ.gif" alt="integ"/></p><h2 id="Working-Objectives-1"><a class="docs-heading-anchor" href="#Working-Objectives-1">Working Objectives</a><a class="docs-heading-anchor-permalink" href="#Working-Objectives-1" title="Permalink"></a></h2><ul><li>[x] IO<ul><li>[x] Input validation<ul><li>[ ] Sensible input generators</li></ul></li><li>[ ] Performance<ul><li>[ ] Compression</li><li>[ ] Asyncronicity</li></ul></li></ul></li><li>[ ] Topology functions<ul><li>[ ] Internal Remeshing<ul><li>[x] Coarsen mesh</li><li>[x] Refine mesh</li><li>[ ] Surface remeshing</li><li>[ ] Virtual node remeshing</li></ul></li></ul></li><li>[x] Self-segment force</li><li>[x] Seg-seg force<ul><li>[ ] Test tiny segment edge case</li><li>[ ] Distributed and gpu parallelisation</li></ul></li><li>[ ] PK force<ul><li>[x] Implementation</li><li>[ ] Tests</li></ul></li><li>[ ] Post processing<ul><li>[x] Plot nodes<ul><li>[ ] Asyncronicity</li></ul></li><li>[ ] Plot recipe</li><li>[ ] Statistical analysis</li></ul></li><li>[ ] Mobility function<ul><li>[x] Generic mobility function</li><li>[x] BCC</li><li>[ ] FCC</li></ul></li><li>[ ] Integration<ul><li>[x] Refactor integrator structures</li><li>[ ] CustomTrapezoid<ul><li>[x] Implementation</li><li>[ ] Testing</li></ul></li><li>[ ] Look into using <a href="https://github.com/SciML/DifferentialEquations.jl">DifferentialEquations.jl</a> for structure and perhaps use/extension of methods</li><li>[ ] Make integrator</li></ul></li><li>[ ] Couple to FEM, perhaps use a package from <a href="http://www.juliafem.org/">JuliaFEM</a>.<ul><li>[ ] Mesh and FE matrices generation</li><li>[ ] Boundary conditions<ul><li>[ ] Neuman</li><li>[ ] Dirichlet</li></ul></li><li>[ ] Displacements<ul><li>[ ] Parallelisation</li></ul></li><li>[ ] Tractions<ul><li>[ ] Parallelisation</li></ul></li></ul></li><li>[ ] Polyhedral operations for FEM coupling. <a href="https://juliareach.github.io/LazySets.jl/release-1.11/man/convex_hulls.html">Create convex hull and check if a point is inside the convex hull.</a></li></ul><h3 id="Tentative-Objectives-1"><a class="docs-heading-anchor" href="#Tentative-Objectives-1">Tentative Objectives</a><a class="docs-heading-anchor-permalink" href="#Tentative-Objectives-1" title="Permalink"></a></h3><ul><li>[ ] Keep an eye on <a href="https://github.com/JuliaIO">JuliaIO</a>, <a href="https://github.com/JuliaFEM/">JuliaFEM</a>, <a href="https://github.com/sciml">SciML</a> because their methods might be useful.</li></ul></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="Dislocations/">Dislocations »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 9 January 2021 01:00">Saturday 9 January 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
