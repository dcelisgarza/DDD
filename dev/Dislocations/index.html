<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Dislocations · DDD.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="DDD.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DDD.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Dislocations</a><ul class="internal"><li><a class="tocitem" href="#Types,-Structs-and-Constructors-1"><span>Types, Structs and Constructors</span></a></li></ul></li><li><a class="tocitem" href="../motivation/">Motivation</a></li><li><a class="tocitem" href="../idx/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Dislocations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Dislocations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/dcelisgarza/DDD.jl/blob/master/docs/src/Dislocations.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Dislocation-Generation-1"><a class="docs-heading-anchor" href="#Dislocation-Generation-1">Dislocation Generation</a><a class="docs-heading-anchor-permalink" href="#Dislocation-Generation-1" title="Permalink"></a></h1><h2 id="Types,-Structs-and-Constructors-1"><a class="docs-heading-anchor" href="#Types,-Structs-and-Constructors-1">Types, Structs and Constructors</a><a class="docs-heading-anchor-permalink" href="#Types,-Structs-and-Constructors-1" title="Permalink"></a></h2><p>Dislocations are described, generated and validated by custom types, structures and functions. By subtyping the provided types with new concrete types, users can define functions which dispatch specifically on their new types while minimising the need for code rewrites, as multiple dispatch takes care of everything during JIT compilation. Structures have not had their default constructors overwritten, we provide custom constructors whose use is recommended instead.</p><p>In discrete dislocation dynamics, dislocations are described by nodes connected by segments. The nodes are labelled according to their type, which is used by the software to decide how they are treated. However, labels are discrete variables, so they cannot take on any value. Additionally, accidentally using non-existent node types may produce silent and difficult to track errors. It is also impractical to validate node types at runtime. We solve these issues by defining a custom enumerated type, which not only limits possible values but informs users and developers of what the values represent.</p><article class="docstring"><header><a class="docstring-binding" id="DDD.nodeType" href="#DDD.nodeType"><code>DDD.nodeType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Since there is only a finite number of node types making the node type an enumerated type provides safety.</p><pre><code class="language-none">@enum nodeType begin
    none = 0    # Undefined node, value at initialisation.
    intMob = 1  # Internal mobile node.
    intFix = 2  # Internal fixed node.
    srfMob = 3  # Mobile surface node.
    srfFix = 4  # Fixed surface node.
    ext = 5     # External node.
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L12">source</a></section></article><p>Of course, mislabelling a node with an erroneous but defined value may still occur. Preventing such bugs is the task of users and developers, however the problem may is eased by the self-descriptive nature of enumerated types.</p><p>Dislocations also have different idealised segment types which are characterised by the relationship between the line direction and Burgers vector. These idealised types are used in the code for in loop generation. We&#39;ve defined a few common types, most of which are not currently used but may prove useful in the future, for example in the statistical analysis of the dislocation network.</p><article class="docstring"><header><a class="docstring-binding" id="DDD.AbstractDlnSeg" href="#DDD.AbstractDlnSeg"><code>DDD.AbstractDlnSeg</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Dislocation segment types.</p><pre><code class="language-none">abstract type AbstractDlnSeg end
struct segNone &lt;: AbstractDlnSeg end    # Undefined segment
struct segEdge &lt;: AbstractDlnSeg end    # Edge segment
struct segEdgeN &lt;: AbstractDlnSeg end   # Edge segment
struct segScrew &lt;: AbstractDlnSeg end   # Screw segment
struct segMixed &lt;: AbstractDlnSeg end   # Mixed segment</code></pre><p>where <code>segEdge</code> have <span>$(\bm{b} \perp \bm{t}) \perp \bm{n}$</span>, <code>segEdgeN</code> have <span>$(\bm{b} \perp \bm{t}) \parallel \bm{n}$</span>, <code>segScrew</code> have <span>$\bm{b} \parallel \bm{t}$</span>, <code>segMixed</code> have <span>$\bm{b} \not\perp \bm{t}~ \&amp;~ \bm{b} \not\perp \bm{n}$</span> and <span>$\bm{b}$</span> is the Burgers vector and <span>$\bm{n}$</span> the slip plane.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/9378703c52045bedd5ca9c8229655a7569955ed8/src/Type/DislocationType.jl#LL25-L36">source</a></section></article><p>Dislocation loops are idealised as having different classifications. Prismatic loops are made up only of edge segments generally with the same slip system; shear loops are made up of a mixture of segment types with the same slip system; jogs and kinks are steps not contained in the slip plane. These idealisations can be used to automate loop generation with minimal rewriting via multiple dispatch. We provide the following types for such a purpose.</p><article class="docstring"><header><a class="docstring-binding" id="DDD.AbstractDlnStr" href="#DDD.AbstractDlnStr"><code>DDD.AbstractDlnStr</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Dislocation loop types.</p><pre><code class="language-none">abstract type AbstractDlnStr end
struct loopDln &lt;: AbstractDlnStr end    # Unclassified loop
struct loopPrism &lt;: AbstractDlnStr end  # Prismatic loop
struct loopShear &lt;: AbstractDlnStr end  # Shear loop
struct loopJog &lt;: AbstractDlnStr end    # Jog
struct loopKink &lt;: AbstractDlnStr end   # Kink</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/9378703c52045bedd5ca9c8229655a7569955ed8/src/Type/DislocationType.jl#LL44-L54">source</a></section></article><p>Generating dislocation networks often involves distributing the initial loops within the simulation domain in a particular way. We again define custom structures that enable us to make use of multiple dispatch.</p><article class="docstring"><header><a class="docstring-binding" id="DDD.AbstractDistribution" href="#DDD.AbstractDistribution"><code>DDD.AbstractDistribution</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Initial statistical distributions of dislocations in the domain.</p><pre><code class="language-none">abstract type AbstractDistribution end
struct Zeros &lt;: AbstractDistribution end
struct Rand &lt;: AbstractDistribution end
struct Randn &lt;: AbstractDistribution end
struct Regular &lt;: AbstractDistribution end</code></pre><p>Distributions for dislocation sources.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/9378703c52045bedd5ca9c8229655a7569955ed8/src/Type/DislocationType.jl#LL66-L76">source</a></section></article><p>Mobility functions describe how dislocations move within a material. There are many variations of such functions and users may want/need to use different functions for different purposes. Creating concrete mobility types lets users define a function for their new concrete mobility type and carry on with their lives.</p><article class="docstring"><header><a class="docstring-binding" id="DDD.AbstractMobility" href="#DDD.AbstractMobility"><code>DDD.AbstractMobility</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Dislocation mobility types.</p><pre><code class="language-none">abstract type AbstractMobility end
struct mobBCC &lt;: AbstractMobility end
struct mobFCC &lt;: AbstractMobility end
struct mobHCP &lt;: AbstractMobility end</code></pre><p>Mobility functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/9378703c52045bedd5ca9c8229655a7569955ed8/src/Type/DislocationType.jl#LL83-L92">source</a></section></article><p>As previously mentioned, idealised dislocation segments live on slip systems, which are pairings of slip plane and Burgers vector. These can be stored in the following structure.</p><article class="docstring"><header><a class="docstring-binding" id="DDD.SlipSystem" href="#DDD.SlipSystem"><code>DDD.SlipSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Slip systems.</p><pre><code class="language-none">struct SlipSystem{T1, T2}
    crystalStruct::T1   # Crystal structure
    slipPlane::T2       # Slip plane
    bVec::T2            # Burgers vector
end</code></pre><p>Structure to store slip systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/9378703c52045bedd5ca9c8229655a7569955ed8/src/Type/DislocationType.jl#LL98-L108">source</a></section></article><p>As slip systems are defined with respect to pure edge dislocations, we recommended users use the keyword constructor as it validates the orthogonality of paired Burgers vector and slip plane.</p><article class="docstring"><header><a class="docstring-binding" id="DDD.SlipSystem-Union{Tuple{}, Tuple{T2}, Tuple{T1}} where T2&lt;:(AbstractArray{T,N} where N where T) where T1&lt;:AbstractCrystalStruct" href="#DDD.SlipSystem-Union{Tuple{}, Tuple{T2}, Tuple{T1}} where T2&lt;:(AbstractArray{T,N} where N where T) where T1&lt;:AbstractCrystalStruct"><code>DDD.SlipSystem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SlipSystem(crystalStruct::T1, slipPlane::T2, bVec::T2) where {T1 &lt;: AbstractCrystalStruct, T2 &lt;: AbstractArray{T, N} where {T, N}}</code></pre><p>Keyword constructor for <a href="#DDD.SlipSystem"><code>SlipSystem</code></a>. Throws error if <span>$\bm{b} \not\perp \bm{n}$</span> where <span>$\bm{b}$</span> is the Burgers vector and <span>$\bm{n}$</span> the slip plane.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/9378703c52045bedd5ca9c8229655a7569955ed8/src/Type/DislocationConstructor.jl#LL1-L6">source</a></section></article><p>The simulation requires certain parameters pertaining to the dislocation network being modelled. These values control certain aspects of the simulation and are stored in the following structure.</p><article class="docstring"><header><a class="docstring-binding" id="DDD.DislocationParameters" href="#DDD.DislocationParameters"><code>DDD.DislocationParameters</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Dislocation loop parameters.</p><pre><code class="language-none">struct DislocationParameters{T1, T2, T3, T4}
    coreRad::T1         # Core radius
    coreRadSq::T1       # Square of core radius
    coreRadMag::T1      # Magnitude of core radius
    minSegLen::T1       # Minimum segment length
    maxSegLen::T1       # Maximum segment length
    twoMinSegLen::T1    # Twice minimum segment length
    minArea::T1         # Minimum area enclosed by 3 segments
    maxArea::T1         # Maximum area enclosed by 3 segments
    minAreaSq::T1       # Squared min area
    maxAreaSq::T1       # Squared max area
    edgeDrag::T1        # Drag coefficient edge dislocation
    screwDrag::T1       # Drag coefficient screw dislocation
    climbDrag::T1       # Drag coefficient climb direction
    lineDrag::T1        # Drag coefficient line direction
    maxConnect::T2      # Maximum connectivity
    remesh::T3          # Remesh flag
    collision::T3       # Collision flag
    separation::T3      # Separation flag
    virtualRemesh::T3   # Virtual remeshing flag
    parCPU::T3          # Parallelise on CPU
    parGPU::T3          # Parallelise on GPU
    mobility::T4        # Mobility law
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/9378703c52045bedd5ca9c8229655a7569955ed8/src/Type/DislocationType.jl#LL133-L161">source</a></section></article><p>We recommend the use of the keyword constructor as it performs sanity checks on various parameters, ensuring a hierarchy of values is maintained.</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>DislocationParameters(;     coreRad::T1,     coreRadMag::T1,     minSegLen::T1,     maxSegLen::T1,     minArea::T1,     maxArea::T1,     maxConnect::T2,     remesh::T3,     collision::T3,     separation::T3,     virtualRemesh::T3,     edgeDrag::T1,     screwDrag::T1,     climbDrag::T1,     lineDrag::T1,     mobility::T4, ) where {T1, T2 &lt;: Int, T3 &lt;: Bool, T4 &lt;: AbstractMobility}</code>. Check Documenter&#39;s build log for details.</p></div></div><p>Dislocation loops form the basis of a network, we provide a structure to store these loops, whether idealised or otherwise.</p><article class="docstring"><header><a class="docstring-binding" id="DDD.DislocationLoop" href="#DDD.DislocationLoop"><code>DDD.DislocationLoop</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Dislocation loop.</p><pre><code class="language-none">struct DislocationLoop{T1, T2, T3, T4, T5, T6, T7, T8, T9}
    loopType::T1    # Loop type
    numSides::T2    # Number of sides per loop
    nodeSide::T2    # Number of nodes per side
    numLoops::T2    # Number of loops to generate
    segLen::T3      # Segment lengths
    slipSystem::T4  # Slip system
    links::T5       # Links matrix
    slipPlane::T6   # Slip plane for each link
    bVec::T6        # Burgers vector for each link
    coord::T6       # Coordinates of each node
    label::T7       # Label of each node
    buffer::T8      # Mean distance buffer separating each loop centre
    range::T6       # Distribution range of generated loops
    dist::T9        # Distribution of generated loops
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/9378703c52045bedd5ca9c8229655a7569955ed8/src/Type/DislocationType.jl#LL189-L209">source</a></section></article><p>Again we recommend the use of the key-word only constructor as it provides an interface to call specific constructors which dispatch on <code>loopType</code> and generate the loop automatically. The default constructor should only be used for truly custom loops, however creating a concrete subtype of <a href="#DDD.AbstractDlnStr"><code>AbstractDlnStr</code></a> and a constructor which dispatches on this new type is highly recommended since it facilitates testing, reproducibility and seamlessly integrates with existing infrastructure.</p><article class="docstring"><header><a class="docstring-binding" id="DDD.DislocationLoop-Union{Tuple{}, Tuple{T8}, Tuple{T7}, Tuple{T6}, Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}} where T8&lt;:AbstractDistribution where T7&lt;:(AbstractArray{T,N} where N where T) where T6 where T5&lt;:AbstractArray{nodeType,1} where T4&lt;:(AbstractArray{T,N} where N where T) where T3 where T2&lt;:Int64 where T1&lt;:AbstractDlnStr" href="#DDD.DislocationLoop-Union{Tuple{}, Tuple{T8}, Tuple{T7}, Tuple{T6}, Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}} where T8&lt;:AbstractDistribution where T7&lt;:(AbstractArray{T,N} where N where T) where T6 where T5&lt;:AbstractArray{nodeType,1} where T4&lt;:(AbstractArray{T,N} where N where T) where T3 where T2&lt;:Int64 where T1&lt;:AbstractDlnStr"><code>DDD.DislocationLoop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DislocationLoop(;
    loopType::T1,
    numSides::T2,
    nodeSide::T2,
    numLoops::T2,
    segLen::T3,
    slipSystem::T2,
    _slipPlane::T4,
    _bVec::T4,
    label::T5,
    buffer::T6,
    range::T7,
    dist::T8,
) where {
    T1 &lt;: AbstractDlnStr,
    T2 &lt;: Int,
    T3 &lt;: Union{T where {T}, AbstractArray{T, N} where {T, N}},
    T4 &lt;: AbstractArray{T, N} where {T, N},
    T5 &lt;: AbstractVector{nodeType},
    T6,
    T7 &lt;: AbstractArray{T, N} where {T, N},
    T8 &lt;: AbstractDistribution,
}</code></pre><p>Generic keyword constructor for <a href="#DDD.DislocationLoop"><code>DislocationLoop</code></a>. Calls other constructors that dispatch on <a href="@ref"><code>loopType</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/9378703c52045bedd5ca9c8229655a7569955ed8/src/Type/DislocationConstructor.jl#LL367-L394">source</a></section></article><p>The first concrete <a href="#DDD.DislocationLoop"><code>DislocationLoop</code></a> constructor is the &quot;zero&quot; constructor. The way Julia&#39;s multiple dispatch works is by dispatching on the most specific method for the inputs provided. Therefore this constructor will be called whenever the loop type is <code>loopDln()</code>.</p><article class="docstring"><header><a class="docstring-binding" id="DDD.DislocationLoop-Union{Tuple{T1}, Tuple{T8}, Tuple{T7}, Tuple{T6}, Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}} where T8&lt;:AbstractDistribution where T7&lt;:(AbstractArray{T,N} where N where T) where T6 where T5&lt;:AbstractArray{nodeType,1} where T4&lt;:(AbstractArray{T,N} where N where T) where T3 where T2&lt;:Int64 where T1&lt;:loopDln" href="#DDD.DislocationLoop-Union{Tuple{T1}, Tuple{T8}, Tuple{T7}, Tuple{T6}, Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}} where T8&lt;:AbstractDistribution where T7&lt;:(AbstractArray{T,N} where N where T) where T6 where T5&lt;:AbstractArray{nodeType,1} where T4&lt;:(AbstractArray{T,N} where N where T) where T3 where T2&lt;:Int64 where T1&lt;:loopDln"><code>DDD.DislocationLoop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DislocationLoop(;
    loopType::T1,
    numSides::T2,
    nodeSide::T2,
    numLoops::T2,
    segLen::T3,
    slipSystem::T2,
    _slipPlane::T4,
    _bVec::T4,
    label::T5,
    buffer::T6,
    range::T7,
    dist::T8,
) where {
    T1 &lt;: AbstractDlnStr,
    T2 &lt;: Int,
    T3 &lt;: Union{T where {T}, AbstractArray{T, N} where {T, N}},
    T4 &lt;: AbstractArray{T, N} where {T, N},
    T5 &lt;: AbstractVector{nodeType},
    T6,
    T7 &lt;: AbstractArray{T, N} where {T, N},
    T8 &lt;: AbstractDistribution,
}</code></pre><p>Generic keyword constructor for <a href="#DDD.DislocationLoop"><code>DislocationLoop</code></a>. Calls other constructors that dispatch on <a href="@ref"><code>loopType</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/9378703c52045bedd5ca9c8229655a7569955ed8/src/Type/DislocationConstructor.jl#LL367-L394">source</a></section></article><p>We also provide a catch-all constructor that generates shear or prismatic loops depending on whether <code>loopType</code> is <code>loopShear()</code> or <code>loopPrism()</code>. It acts as a fallback for other loop types but generates prismatic loops. Such behaviour can be overridden by defining new methods which dispatch on more a specific <code>loopType</code>.</p><article class="docstring"><header><a class="docstring-binding" id="DDD.DislocationLoop-Union{Tuple{T1}, Tuple{T8}, Tuple{T7}, Tuple{T6}, Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}} where T8&lt;:AbstractDistribution where T7&lt;:(AbstractArray{T,N} where N where T) where T6 where T5&lt;:AbstractArray{nodeType,1} where T4&lt;:(AbstractArray{T,N} where N where T) where T3 where T2&lt;:Int64 where T1&lt;:AbstractDlnStr" href="#DDD.DislocationLoop-Union{Tuple{T1}, Tuple{T8}, Tuple{T7}, Tuple{T6}, Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}} where T8&lt;:AbstractDistribution where T7&lt;:(AbstractArray{T,N} where N where T) where T6 where T5&lt;:AbstractArray{nodeType,1} where T4&lt;:(AbstractArray{T,N} where N where T) where T3 where T2&lt;:Int64 where T1&lt;:AbstractDlnStr"><code>DDD.DislocationLoop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DislocationLoop(;
    loopType::T1,
    numSides::T2,
    nodeSide::T2,
    numLoops::T2,
    segLen::T3,
    slipSystem::T2,
    _slipPlane::T4,
    _bVec::T4,
    label::T5,
    buffer::T6,
    range::T7,
    dist::T8,
) where {
    T1 &lt;: AbstractDlnStr,
    T2 &lt;: Int,
    T3 &lt;: Union{T where {T}, AbstractArray{T, N} where {T, N}},
    T4 &lt;: AbstractArray{T, N} where {T, N},
    T5 &lt;: AbstractVector{nodeType},
    T6,
    T7 &lt;: AbstractArray{T, N} where {T, N},
    T8 &lt;: AbstractDistribution,
}</code></pre><p>Generic keyword constructor for <a href="#DDD.DislocationLoop"><code>DislocationLoop</code></a>. Calls other constructors that dispatch on <a href="@ref"><code>loopType</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/9378703c52045bedd5ca9c8229655a7569955ed8/src/Type/DislocationConstructor.jl#LL367-L394">source</a></section></article><p>The <code>dist</code> parameter refers to a concrete subtype of <a href="#DDD.AbstractDistribution"><code>AbstractDistribution</code></a>. When defining a new distribution it is important to define a new version of the <a href="#DDD.loopDistribution"><code>loopDistribution</code></a> function.</p><article class="docstring"><header><a class="docstring-binding" id="DDD.loopDistribution" href="#DDD.loopDistribution"><code>DDD.loopDistribution</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">loopDistribution(dist&lt;:AbstractDistribution, n::Int, args...; kw...)
loopDistribution(dist::Zeros, n::Int, args...; kw...) = zeros(3, n)
loopDistribution(dist::Rand, n::Int, args...; kw...) = rand(3, n)
loopDistribution(dist::Randn, n::Int, args...; kw...) = randn(3, n)
loopDistribution(dist::Regular, n::Int, args...; kw...) = error(&quot;loopDistribution: regular distribution yet not implemented&quot;)</code></pre><p>Returns a <code>3 × n</code> matrix whose points follow the distribution defined by the method dispatching on the concrete subtype of <code>dist</code>. When creating custom <a href="#DDD.AbstractDistribution"><code>AbstractDistribution</code></a> subtypes, a corresponding <code>loopDistribution</code> method must be created for the custom distribution to be used in the <a href="#DDD.DislocationLoop"><code>DislocationLoop</code></a> constructors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/9378703c52045bedd5ca9c8229655a7569955ed8/src/Type/DislocationUtil.jl#LL88-L97">source</a></section></article><p>The dislocation loops contain all the data relevant to a single loop. This data is then used to populate a dislocation network, which is a mutable structure because it evolves over time.</p><article class="docstring"><header><a class="docstring-binding" id="DDD.DislocationNetwork" href="#DDD.DislocationNetwork"><code>DDD.DislocationNetwork</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Dislocation network.</p><pre><code class="language-none">struct DislocationNetwork{T1, T2, T3, T4, T5, T6}
    links::T1
    slipPlane::T2
    bVec::T2
    coord::T2
    label::T3
    nodeVel::T2
    nodeForce::T2
    numNodeSegConnect::T4   # Number of nodes, segments and max connectivity in network
    connectivity::T5        # Connectivity matrix
    linksConnect::T5        # Links involved in connection
    segIdx::T5              # Contains segment index and the nodes of the nodes in said link
    segForce::T6            # Force on each node of each segment
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/9378703c52045bedd5ca9c8229655a7569955ed8/src/Type/DislocationType.jl#LL227-L245">source</a></section></article><p>Again we provide a keyword constructor which performs some sanity checks and loads the data into the structure. This is the constructor to use when loading data from a previously generated network.</p><article class="docstring"><header><a class="docstring-binding" id="DDD.DislocationNetwork-Union{Tuple{}, Tuple{T6}, Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}} where T6&lt;:(AbstractArray{T,N} where N where T) where T5&lt;:(AbstractArray{Int64,N} where N) where T4&lt;:Int64 where T3&lt;:AbstractArray{nodeType,1} where T2&lt;:(AbstractArray{T,N} where N where T) where T1&lt;:(AbstractArray{T,N} where N where T)" href="#DDD.DislocationNetwork-Union{Tuple{}, Tuple{T6}, Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}} where T6&lt;:(AbstractArray{T,N} where N where T) where T5&lt;:(AbstractArray{Int64,N} where N) where T4&lt;:Int64 where T3&lt;:AbstractArray{nodeType,1} where T2&lt;:(AbstractArray{T,N} where N where T) where T1&lt;:(AbstractArray{T,N} where N where T)"><code>DDD.DislocationNetwork</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DislocationNetwork(;
    links::T1,
    slipPlane::T2,
    bVec::T2,
    coord::T2,
    label::T3,
    nodeVel::T2,
    nodeForce::T2,
    numNodeSegConnect::T4 = [0, 0, 0],
    connectivity::T5 = zeros(Int, 0, 0),
    linksConnect::T5 = zeros(Int, 2, 0),
    segIdx::T5 = zeros(Int, 2, 3),
    segForce::T6 = zeros(3, 2, 0),
) where {
    T1 &lt;: AbstractArray{T, N} where {T, N},
    T2 &lt;: AbstractArray{T, N} where {T, N},
    T3 &lt;: AbstractVector{nodeType},
    T4 &lt;: Int,
    T5 &lt;: AbstractArray{Int, N} where {N},
    T6 &lt;: AbstractArray{T, N} where {T, N},
}</code></pre><p>Keyword constructor for <a href="#DDD.DislocationNetwork"><code>DislocationNetwork</code></a>, performs validations but creates dislocation network as provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/9378703c52045bedd5ca9c8229655a7569955ed8/src/Type/DislocationConstructor.jl#LL434-L459">source</a></section></article><p>However, if the aim is to generate a new network then use the following constructor.</p><article class="docstring"><header><a class="docstring-binding" id="DDD.DislocationNetwork-Union{Tuple{T1}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T2,Vararg{Any,N} where N}} where T3&lt;:Bool where T2&lt;:Int64 where T1&lt;:(Union{AbstractArray{T,1}, T} where T&lt;:DislocationLoop)" href="#DDD.DislocationNetwork-Union{Tuple{T1}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T2,Vararg{Any,N} where N}} where T3&lt;:Bool where T2&lt;:Int64 where T1&lt;:(Union{AbstractArray{T,1}, T} where T&lt;:DislocationLoop)"><code>DDD.DislocationNetwork</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DislocationNetwork(
    sources::T1,
    maxConnect::T2 = 4,
    args...;                        # Optional arguments
    memBuffer = nothing,            # Buffer for memory allocation
    checkConsistency::T3 = true,    # Check consistency of generated network
    kw...,                          # Other keyword arguments
) where {
    T1 &lt;: Union{T, AbstractVector{T}} where {T &lt;: DislocationLoop},
    T2 &lt;: Int,
    T3 &lt;: Bool,
}</code></pre><p>Out of place constructor for <a href="#DDD.DislocationNetwork"><code>DislocationNetwork</code></a>. Generates a new dislocation network from previously generated sources.</p><p><strong>Argument Explanation</strong></p><ul><li><code>args...</code> are optional arguments that will be passed on to the <code>loopDistribution</code> function which distributes the loops in <code>sources</code> according to the type of their <code>dist</code> variable.</li><li><code>kw...</code> are optional keyword arguments that will also be passed to <code>loopDistribution</code>.</li><li><code>memBuffer</code> is the numerical value for allocating memory in advance, the quantity <span>$\textrm{memBuffer} \times N$</span> where <code>N</code> is the total number of nodes in <code>sources</code>, will be the initial number of entries allocated in the matrices that keep the network&#39;s data, if it is <code>nothing</code> then the number of entries is <span>$\textrm{round}(N \log_{2}(N))$</span>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/9378703c52045bedd5ca9c8229655a7569955ed8/src/Type/DislocationConstructor.jl#LL502-L524">source</a></section></article><p>If adding to an existing network, use the mutating (also called in-place) constructor.</p><article class="docstring"><header><a class="docstring-binding" id="DDD.DislocationNetwork!-Union{Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T2}, Tuple{T1,T2,T3,Vararg{Any,N} where N}} where T4&lt;:Bool where T3&lt;:Int64 where T2&lt;:(Union{AbstractArray{T,1}, T} where T&lt;:DislocationLoop) where T1&lt;:DislocationNetwork" href="#DDD.DislocationNetwork!-Union{Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T2}, Tuple{T1,T2,T3,Vararg{Any,N} where N}} where T4&lt;:Bool where T3&lt;:Int64 where T2&lt;:(Union{AbstractArray{T,1}, T} where T&lt;:DislocationLoop) where T1&lt;:DislocationNetwork"><code>DDD.DislocationNetwork!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function DislocationNetwork!(
    network::T1,
    sources::T2,
    maxConnect::T3 = 4,
    args...;
    checkConsistency::T3 = true,
    kw...,
) where {
    T1 &lt;: DislocationNetwork,
    T2 &lt;: Union{T, AbstractVector{T}} where {T &lt;: DislocationLoop},
    T3 &lt;: Int,
    T4 &lt;: Bool,
}</code></pre><p>In-place constructor for <a href="#DDD.DislocationNetwork"><code>DislocationNetwork</code></a>. Generates a new dislocation network from already generated sources. If the matrices already in <code>network</code> are not large enough to accommodate the additions from <code>sources</code>, it will automatically allocate <span>$\textrm{round}(N \log_{2}(N))$</span> new entries where <code>N</code> is the total number of nodes in <code>sources</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/9378703c52045bedd5ca9c8229655a7569955ed8/src/Type/DislocationConstructor.jl#LL604-L621">source</a></section></article><p>Dislocation network constructors use a few internal functions to distribute loops about the domain as well as create auxiliary matrices and verify the integrity of the generated network. As previously mentioned, <a href="#DDD.loopDistribution"><code>loopDistribution</code></a> is used to generate points from a particular distribution. These points must be scaled and adjusted by limits generated the <code>limits</code> function.</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>limits!(     lims::T1,     segLen::T2,     range::T1,     buffer::T2, ) where {T1 &lt;: AbstractArray{T, N} where {T, N}, T2}</code>. Check Documenter&#39;s build log for details.</p></div></div><p>The limits, together with the aforementioned distributions are used to translate coordinates with the <code>translatePoints!</code> function.</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>translatePoints!(     coord::T1,     lims::T1,     disp::T2, ) where {T1 &lt;: AbstractArray{T, N} where {T, N}, T2 &lt;: AbstractVector{T} where {T}}</code>. Check Documenter&#39;s build log for details.</p></div></div><p>In order to traverse the network, it is useful to define a few auxiliary matrices containing relational information about nodes and links. These are created by the <code>makeConnect</code> functions.</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>makeConnect(     links::T1,     maxConnect::T2, ) where {T1 &lt;: AbstractArray{T, N} where {T, N}, T2 &lt;: Int}</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="DDD.makeConnect!-Tuple{DislocationNetwork}" href="#DDD.makeConnect!-Tuple{DislocationNetwork}"><code>DDD.makeConnect!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">makeConnect!(network::DislocationNetwork)</code></pre><p>In-place version of <a href="@ref"><code>makeConnect</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/9378703c52045bedd5ca9c8229655a7569955ed8/src/Type/DislocationUtil.jl#LL213-L218">source</a></section></article><p>It&#39;s also useful to define another matrix for indexing segments quickly, this matrix is defined by the <code>getSegmentIdx</code> functions.</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>getSegmentIdx(     links::T1,     label::T2, ) where {T1 &lt;: AbstractArray{T, N} where {T, N}, T2 &lt;: AbstractVector{nodeType}}</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="DDD.getSegmentIdx!-Tuple{DislocationNetwork}" href="#DDD.getSegmentIdx!-Tuple{DislocationNetwork}"><code>DDD.getSegmentIdx!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getSegmentIdx!(network::DislocationNetwork)</code></pre><p>In-place version of <a href="@ref"><code>getSegmentIdx</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/9378703c52045bedd5ca9c8229655a7569955ed8/src/Type/DislocationUtil.jl#LL280-L285">source</a></section></article><p>The validity of the network can be checked by <code>checkNetwork</code>.</p><article class="docstring"><header><a class="docstring-binding" id="DDD.checkNetwork-Tuple{DislocationNetwork}" href="#DDD.checkNetwork-Tuple{DislocationNetwork}"><code>DDD.checkNetwork</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">checkNetwork(network::DislocationNetwork)</code></pre><p>Checks the validity of the dislocation network. It ensures the following conditions are met by the member variables of <code>network</code>:</p><ol><li><code>connectivity</code> and <code>links</code> have the same number of non-zero entries;</li><li>all entries in <code>bVec</code> are non-zero;</li><li>only the trailing columns of <code>connectivity</code> are zeros;</li><li>consistency between <code>connectivity</code> and <code>links</code>;</li><li><code>bVec</code> is conserved among connected nodes;</li><li>entries in <code>links</code> are unique;</li><li>consistency betwen <code>connectivity</code> and <code>linksConnect</code></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/9378703c52045bedd5ca9c8229655a7569955ed8/src/Type/DislocationUtil.jl#LL315-L328">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../motivation/">Motivation »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 13 January 2021 20:02">Wednesday 13 January 2021</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
